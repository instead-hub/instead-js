{"click.lua":"local std = stead\nlocal input = std.ref '@input'\n-- luacheck: globals click\nclick = std.obj {\nnam = '@click';\n-- luacheck: no unused args\nfilter = function(s, press, btn, x, y, px, py)\n-- luacheck: unused args\nreturn press and px\nend\n}\nfunction input:click(press, btn, x, y, px, py)\nlocal a\nif not click:filter(press, btn, x, y, px, py) then\nreturn\nend\nfor _, v in std.ipairs {press, btn, x, y, px, py} do\na = (a and (a..', ') or ' ') .. std.dump(v)\nend\nreturn '@click'.. (a or '')\nend\nstd.mod_cmd(function(cmd)\nif cmd[1] ~= '@click' then\nreturn\nend\nlocal r, v\nr, v = std.call(std.here(), 'onclick', cmd[2], cmd[3], cmd[4], cmd[5], cmd[6], cmd[7])\nif not r and not v then\nr, v = std.call(std.game, 'onclick', cmd[2], cmd[3], cmd[4], cmd[5], cmd[6], cmd[7])\nend\nif not r and not v then -- nothing todo\nreturn nil, false\nend\nreturn r, v\nend)\n","dbg-ru.lua":"local kbden = {\nshifted = {\n[\"1\"] = \"!\",\n[\"2\"] = \"@\",\n[\"3\"] = \"#\",\n[\"4\"] = \"$\",\n[\"5\"] = \"%\",\n[\"6\"] = \"^\",\n[\"7\"] = \"&\",\n[\"8\"] = \"*\",\n[\"9\"] = \"(\",\n[\"0\"] = \")\",\n[\"-\"] = \"_\",\n[\"=\"] = \"+\",\n[\"[\"] = \"{\",\n[\"]\"] = \"}\",\n[\"\\\\\"] = \"|\",\n[\";\"] = \":\",\n[\"'\"] = \"\\\"\",\n[\",\"] = \"<\",\n[\".\"] = \">\",\n[\"/\"] = \"?\",\n}\n}\nlocal kbdru = {\n[\"q\"] = \"й\",\n[\"w\"] = \"ц\",\n[\"e\"] = \"у\",\n[\"r\"] = \"к\",\n[\"t\"] = \"е\",\n[\"y\"] = \"н\",\n[\"u\"] = \"г\",\n[\"i\"] = \"ш\",\n[\"o\"] = \"щ\",\n[\"p\"] = \"з\",\n[\"[\"] = \"х\",\n[\"]\"] = \"ъ\",\n[\"a\"] = \"ф\",\n[\"s\"] = \"ы\",\n[\"d\"] = \"в\",\n[\"f\"] = \"а\",\n[\"g\"] = \"п\",\n[\"h\"] = \"р\",\n[\"j\"] = \"о\",\n[\"k\"] = \"л\",\n[\"l\"] = \"д\",\n[\";\"] = \"ж\",\n[\"'\"] = \"э\",\n[\"z\"] = \"я\",\n[\"x\"] = \"ч\",\n[\"c\"] = \"с\",\n[\"v\"] = \"м\",\n[\"b\"] = \"и\",\n[\"n\"] = \"т\",\n[\"m\"] = \"ь\",\n[\",\"] = \"б\",\n[\".\"] = \"ю\",\n[\"`\"] = \"ё\",\nshifted = {\n[\"q\"] = \"Й\",\n[\"w\"] = \"Ц\",\n[\"e\"] = \"У\",\n[\"r\"] = \"К\",\n[\"t\"] = \"Е\",\n[\"y\"] = \"Н\",\n[\"u\"] = \"Г\",\n[\"i\"] = \"Ш\",\n[\"o\"] = \"Щ\",\n[\"p\"] = \"З\",\n[\"[\"] = \"Х\",\n[\"]\"] = \"Ъ\",\n[\"a\"] = \"Ф\",\n[\"s\"] = \"Ы\",\n[\"d\"] = \"В\",\n[\"f\"] = \"А\",\n[\"g\"] = \"П\",\n[\"h\"] = \"Р\",\n[\"j\"] = \"О\",\n[\"k\"] = \"Л\",\n[\"l\"] = \"Д\",\n[\";\"] = \"Ж\",\n[\"'\"] = \"Э\",\n[\"z\"] = \"Я\",\n[\"x\"] = \"Ч\",\n[\"c\"] = \"С\",\n[\"v\"] = \"М\",\n[\"b\"] = \"И\",\n[\"n\"] = \"Т\",\n[\"m\"] = \"Ь\",\n[\",\"] = \"Б\",\n[\".\"] = \"Ю\",\n[\"`\"] = \"Ё\",\n[\"1\"] = \"!\",\n[\"2\"] = \"@\",\n[\"3\"] = \"#\",\n[\"4\"] = \";\",\n[\"5\"] = \"%\",\n[\"6\"] = \":\",\n[\"7\"] = \"?\",\n[\"8\"] = \"*\",\n[\"9\"] = \"(\",\n[\"0\"] = \")\",\n[\"-\"] = \"_\",\n[\"=\"] = \"+\",\n}\n}\nreturn { main = kbden, alt = kbdru }\n","dbg.lua":"-- luacheck: globals dprint\n-- luacheck: read globals walk disable enable drop take remove\nlocal std = stead\nlocal type = std.type\nlocal table = std.table\nlocal input = std.ref '@input'\nlocal string = std.string\nlocal pairs = std.pairs\nlocal ipairs = std.ipairs\nlocal okey\nlocal txt = std.ref '@iface'\nlocal instead = std.ref '@instead'\nlocal iface = txt\nlocal kbden = {\nshifted = {\n[\"1\"] = \"!\",\n[\"2\"] = \"@\",\n[\"3\"] = \"#\",\n[\"4\"] = \"$\",\n[\"5\"] = \"%\",\n[\"6\"] = \"^\",\n[\"7\"] = \"&\",\n[\"8\"] = \"*\",\n[\"9\"] = \"(\",\n[\"0\"] = \")\",\n[\"-\"] = \"_\",\n[\"=\"] = \"+\",\n[\"[\"] = \"{\",\n[\"]\"] = \"}\",\n[\"\\\\\"] = \"|\",\n[\";\"] = \":\",\n[\"'\"] = \"\\\"\",\n[\",\"] = \"<\",\n[\".\"] = \">\",\n[\"/\"] = \"?\",\n}\n}\nlocal kbdalt = false\nlocal function txt_esc(s)\nlocal rep = function(self)\nreturn txt:nb(self)\nend\nif not s then return end\nlocal r = s:gsub(\"[<>]+\", rep):gsub(\"[ \\t]\", rep);\nreturn r\nend\nlocal function dispof(v)\nlocal d = std.titleof(v) or std.dispof(v)\nlocal tag = (type(v.tag) == 'string' and v.tag)\nif type(d) ~= 'string' then\nd = tag or 'n/a'\nelse\nd = d..((tag and '/'..tag) or '')\nend\nreturn d\nend\nlocal function show_obj(s, o, pfx, verbose)\nlocal wh = o:where()\nif wh then\nwh = '@'..std.tostr(std.nameof(wh))..'['..(dispof(wh))..']'\nelse\nwh = ''\nend\ns:printf(\"%s%s%snam: %s%s | disp:%s\\n\",\npfx or '',\no:disabled() and '%' or '',\no:closed() and '-' or '',\nstd.tostr(std.nameof(o)),\nwh,\ndispof(o))\nif verbose then\nfor k, v in pairs(o) do\ns:printf(\"*[%s] = %s\\n\", std.tostr(k), std.dump(v) or 'n/a')\nend\nreturn\nend\nfor _, v in ipairs(o.obj) do\npfx = (pfx or '' .. '    ')\nshow_obj(s, v, pfx)\nend\nend\nlocal function show_room(s, o)\ns:printf(\"nam: %s | title: %s | disp: %s\\n\",\nstd.tostr(std.nameof(o)), std.tostr(std.titleof(o) or 'n/a'), dispof(o))\ns:printf(\"    way: \")\nfor k, v in ipairs(o.way) do\nif k ~= 1 then\ns:printf(\" | \")\nend\ns:printf(\"%s[%s]\", std.tostr(std.nameof(v)), dispof(v))\nend\ns:printf(\"\\n\")\nend\nlocal take = take\nlocal function show_decl(s, t)\nlocal d = std.ref '@declare':declarations()\nfor k, v in pairs(d) do\nif not t or v[\"type\"] == t then\nlocal dump = std.dump(_G[k])\nif dump == '' then dump = std.tostr(_G[k]) end\ns:printf(\"%s %s = %s\\n\", v[\"type\"], k, dump)\nend\nend\nend\nlocalcommands = {\n{ nam = 'quit',\nact = function(s)\ns.on = false\ns:disable();\nreturn std.nop()\nend;\n};\n{ nam = 'find',\n{ nam = 'obj',\nact = function(s, par)\nif not par then\nreturn\nend\nstd.for_each_obj(function(v)\nif v == s then\nreturn\nend\nlocal disp = dispof(v)\nlocal nam = std.tostr(std.nameof(v))\nif disp:find(par, 1, true) or nam:find(par, 1, true) then\ns:printf(\"nam: %s disp: %s\\n\", nam, disp)\nend\nend)\nend\n};\n{ nam = 'dsc',\nact = function(s, par)\nif not par then\nreturn\nend\nstd.for_each_obj(function(v)\nif v == s then\nreturn\nend\nlocal dsc = std.par(' ', std.call(v, 'dsc'), std.call(v, 'decor')) or ''\nlocal st, e = dsc:find(par, 1, true)\nif st then\nlocal nam = std.tostr(std.nameof(v))\nlocal disp = dispof(v)\nst = st - 32\nif st < 0 then st = 1 end\ns:printf(\"nam: %s disp: %s dsc: %s\\n\", nam, disp, dsc:sub(st, e + 32))\nend\nend)\nend\n};\n};\n{ nam = 'show',\n{ nam = 'obj',\nact = function(s, par)\nif par == '*' then\nlocal objs = {}\nstd.for_each_obj(function(v)\nif not v:type 'room' then\ntable.insert(objs, v)\nend\nend)\ntable.sort(objs, function(a, b)\nreturn std.tostr(std.nameof(a)) < std.tostr(std.nameof(b))\nend)\nfor i = 1, #objs do\nshow_obj(s, objs[i])\nend\nreturn\nend\nif not par then\nfor i = 1, #std.here().obj do\nshow_obj(s, std.here().obj[i])\nend\nreturn\nend\ns:printf(\"[object]\\n\")\nlocal st, r = std.pcall(function()\nshow_obj(s, std.object(std.tonum(par) or par), '    ', true) end)\nif not st then\ns:printf(\"%s\\n\", r)\nreturn\nend\nreturn\nend;\n},\n{ nam = 'inv',\nact = function(s)\ns:printf(\"[inventory]\\n\")\nfor _, v in ipairs(std.me():inventory()) do\nshow_obj(s, v, '    ')\nend\nend;\n};\n{ nam = 'room',\nact = function(s, par)\nif par == '*' then\nlocal rooms = {}\nstd.for_each_obj(function(v)\nif v:type 'room' then\ntable.insert(rooms, v)\nend\nend)\ntable.sort(rooms, function(a, b)\nreturn std.tostr(std.nameof(a)) < std.tostr(std.nameof(b))\nend)\nfor i = 1, #rooms do\nshow_room(s, rooms[i])\nend\nreturn\nend\nlocal r, v = std.pcall(function() return par and std.object(par) or std.here() end)\nif not r then\ns:printf(\"%s\\n\", v)\nreturn\nend\nif not std.is_obj(v, 'room') then\ns:printf(\"It is not the room.\\n\")\nreturn\nend\ns:printf(\"[room]\\n    \")\nshow_room(s, v)\ns:printf(\"[objects]\\n\")\nfor _, o in ipairs(std.here().obj) do\nshow_obj(s, o, '    ')\nend\nend;\n};\n{\nnam = 'declare',\nact = function(s, par)\nif par == '*' then\nshow_decl(s)\nelse\nshow_decl(s, 'declare')\nend\nend\n},\n{\nnam = 'global',\nact = function(s, _)\nshow_decl(s, 'global')\nend\n},\n{\nnam = 'const',\nact = function(s, _)\nshow_decl(s, 'const')\nend\n}\n};\n{ nam = 'take',\n  act = function(s, par)\nif not par then\nreturn\nend\nlocal st, r, v = s:eval(take, std.tonum(par) or par)\nif not st then\ns:printf(\"%s\\n\", r)\nreturn\nend\nreturn r, v\n  end;\n},\n{ nam = 'drop',\n  act = function(s, par)\nif not par then\nreturn\nend\nlocal st, r, v = s:eval(drop, std.tonum(par) or par)\nif not st then\ns:printf(\"%s\\n\", r)\nreturn\nend\nreturn r, v\n  end;\n},\n{ nam = 'remove',\n  act = function(s, par)\nif not par then\nreturn\nend\nlocal st, r, v = s:eval(remove, std.tonum(par) or par)\nif not st then\ns:printf(\"%s\\n\", r)\nreturn\nend\nreturn r, v\n  end;\n},\n{ nam = 'enable',\n  act = function(s, par)\nif not par then\nreturn\nend\nlocal st, r, v = s:eval(enable, std.tonum(par) or par)\nif not st then\ns:printf(\"%s\\n\", r)\nreturn\nend\nreturn r, v\n  end;\n},\n{ nam = 'disable',\n  act = function(s, par)\nif not par then\nreturn\nend\nlocal st, r, v = s:eval(disable, std.tonum(par) or par)\nif not st then\ns:printf(\"%s\\n\", r)\nreturn\nend\nreturn r, v\n  end;\n},\n{ nam = 'dump',\nact = function(s, par)\nif not par then\nreturn\nend\nlocal f, err = std.eval('return ('..par..')')\nif not f then\ns:printf(\"%s\\n\", err)\nreturn\nend\nerr, f = std.pcall(f)\nif not err then\ns:printf(\"%s\\n\", f)\nreturn\nend\nif std.is_obj(f) then\nshow_obj(s, f, '', true)\nelse\ns:printf(\"%s\\n\", std.dump(f))\nend\nend\n};\n{ nam = 'eval',\nact = function(s, par)\nif not par then\nreturn\nend\nlocal f, err = std.eval(par)\nif not f then\ns:printf(\"%s\\n\", err)\nreturn\nend\nf, err = std.pcall(f)\nif not f then\ns:printf(\"%s\\n\", err)\nreturn\nend\nend\n};\n{ nam = 'walk',\nact = function(s, par)\nif not par then\nreturn\nend\nlocal st, r, v = s:eval(walk, par, false)\nif not st then\ns:printf(\"%s\\n\", r)\nreturn\nend\nreturn r, v\nend;\n};\n{ nam = 'clear',\nact = function(s)\ns:cls()\nend;\n};\n{ nam = 'help',\nact = function(s)\ns:printf([[Use <tab> key to complete words.\nUse <up>/<down> for history.\nUse ctrl-l to clear screen.\nUse ctrl-d or f6 to enter/exit debugger.\nSome useful commands:\n    show obj * - show all objects\n    show room * - show all rooms\n    find obj <string> - search obj\n    find dsc <string> - search obj (in dsc and decor)\n    show obj <name> - show object (in verbose mode)\n    show room <name> - show room\n    show room - show here\n    walk <name> - walk anywhere\n]]);\nend;\n};\nlookup = function(s, inp)\nlocal cmd = std.split(inp)\nlocal cur = s\nlocal found\nlocal last_found\nfor k, v in ipairs(cmd) do\nfound = nil\nfor _, c in ipairs(cur) do\nif v == c.nam then\ncur = c\nfound = k\nlast_found = k\nbreak\nend\nend\nif not found then\nbreak\nend\nend\nlocal par\nif last_found then\nfor i = last_found + 1, #cmd do\npar = (par and (par .. ' ') or '').. cmd[i]\nend\nelse\npar = inp\nend\nreturn cur, par\nend;\ncompletion = function(s, inp)\nlocal cmd, par = s:lookup(inp)\nif not cmd then\nreturn\nend\nif #cmd == 0 then\nif par then\nlocal vars = {}\nstd.for_each_obj(function(v, var)\nif std.tostr(v.nam):find(par, 1, true) == 1 and std.tostr(v.nam) ~= par then\ntable.insert(var, std.tostr(v.nam))\nend\nend, vars)\nreturn vars\nend\nreturn\nend\nlocal var = {}\nfor i = 1, #cmd do\nif cmd[i].nam:find(par or '', 1, true) == 1 then\ntable.insert(var, cmd[i].nam)\nend\nend\nreturn var\nend;\nsave = function() end;\n};\nlocal embed ={\non = false;\nkey_shift = false;\ncursor = 1;\ninput = '';\noutput = [[INSTEAD dbg 0.1\nWritten by Peter Kosyh in 2017\nType \"help\" to see help\n]];\nhint = '';\nhistory = {};\nhistory_pos = 1;\nkey_alt = false;\nkey_ctrl = false;\nkbd_alt_xlat = false;\n__last_disp = false;\n__nostrict = false;\nlast_timer = false;\n};\nlocal theme = {}\nlocal function theme_var(a, b)\nlocal ov = instead.theme_var(a)\nif b then\ntheme[a] = ov\nreturn instead.theme_var(a, b)\nend\nreturn ov\nend\nlocal function theme_reset()\nfor k, v in pairs(theme) do\ninstead.theme_var(k, v)\nend\ntheme = {}\nend\nlocal funcs = {}\nlocal function instead_func(a)\nlocal ov = instead[a]\nfuncs[a] = ov\nstd.rawset(instead, a, function() end)\nend\nlocal function instead_reset()\nfor k, v in pairs(funcs) do\nstd.rawset(instead, k, v)\nend\nfuncs = {}\nend\nlocal std_dbg = {}\nlocal function std_debug(a)\nif not a then\nfor k, v in pairs(std_dbg) do\nstd['debug_'..k] = v\nend\nreturn\nend\nstd_dbg[a] = std['debug_'..a]\nstd['debug_'..a] = false\nend\nlocal render_callback = false\nlocal dbg = std.obj {\npri = 16384;\nnam = '@dbg';\nembed;\n{ commands = commands },\nenable = function(s)\ninstead_func('get_picture')\ninstead_func('get_fading')\ninstead_func('get_title')\ninstead_func('get_ways')\nrender_callback = (std.ref '@sprite').render_callback(false)\nlocal timer = stead.ref '@timer'\ns.last_timer = timer:get()\ntimer:stop()\nstd_debug('input')\nstd_debug('output')\nstd_debug('xref')\ns.__last_disp = std.game:lastdisp()\ns.__nostrict = std.nostrict or false\nlocal w, h = std.tonum(theme_var 'scr.w'), std.tonum(theme_var 'scr.h')\ntheme_var('scr.gfx.mode', 'embedded')\ntheme_var('scr.gfx.bg', '')\ntheme_var('scr.col.bg', 'white')\ntheme_var('win.col.fg', 'black')\ntheme_var('inv.mode', 'disabled')\nlocal padw = w > 320 and 16 or 0\nlocal padh = h > 320 and 16 or 0\ntheme_var('win.x', padw)\ntheme_var('win.y', padh)\ntheme_var('win.w', w - padw)\ntheme_var('win.h', h - padh)\ntheme_var('menu.button.x', w)\ntheme_var('menu.button.y', h)\ntheme_var('win.fnt.size', 16)\ntheme_var('win.scroll.mode', 3)\nstd.nostrict = true\niface:raw_mode(true)\nend;\ndisable = function(s)\ntheme_reset()\nstd_debug()\nstd.nostrict = s.__nostrict\ninstead_reset()\nstd.ref('@sprite').render_callback(render_callback)\niface:raw_mode(false)\nlocal timer = stead.ref '@timer'\ntimer:set(s.last_timer)\nstd.game:lastdisp(s.__last_disp)\nend;\ninp_split = function(s)\nlocal pre = s.input:sub(1, s.cursor - 1);\nlocal post = s.input:sub(s.cursor);\nreturn pre, post\nend;\neval = function(s, fn, ...)\nlocal st, r, _ = std.pcall(fn, ...)\nif not st then\n--s:printf(\"%s\\n\", r)\nreturn false, r\nelse\ns.on = false\ns:disable()\nif std.me():moved() then\nreturn true, nil, true\nelse\nreturn true, std.nop()\nend\nend\nend;\ncls = function(s)\ns.output = '';\ns.hint = '';\nend;\ncompletion = function(s, edit)\nlocal hint = s.commands:completion(s.input)\nif not hint or #hint == 0 then\ns.hint = ''\nreturn\nend\nif #hint == 1 and edit ~= false then\nlocal _, par = s.commands:lookup(s.input)\nif par then\nlocal len = par:len()\ns.input = s.input:sub(1, s.input:len() - len)\nend\ns.input = s.input .. hint[1]..' '\ns.cursor = #s.input + 1\ns:completion(edit)\nreturn\nend\ns.hint = ''\nfor _, v in ipairs(hint) do\ns.hint = s.hint .. v .. ' '\nend\nend;\nprintf = function(s, fmt, ...)\ns.output = s.output .. std.string.format(fmt, ...)\nend;\nexec = function(s)\nlocal c, par = s.commands:lookup(s.input)\nif not c or not c.act then\nreturn s:completion()\nend\nif #s.history == 0 or s.history[#s.history] ~= s.input then\ntable.insert(s.history, s.input)\nend\ns.history_pos = 0\ns:printf('$ '..s.input..'\\n')\ns.input = ''\ns.hint = ''\ns.cursor = 1\nreturn c.act(s, par)\nend;\ndsc = function(s) -- display debugger\nstd.pr (txt_esc(s.output))\nif s.kbd_alt_xlat then\nstd.pr (txt:bold '&')\nelse\nstd.pr (txt:bold ' ')\nend\nlocal pre, post = s:inp_split()\nstd.pr (txt:bold '$ '.. txt:bold(txt_esc(pre))..txt:bold '|'..txt:bold(txt_esc(post)) ..'\\n')\nif s.hint == '' then s.hint = '?' end\nstd.pr (s.hint ..'\\n')\nstd.pr (txt:anchor())\nend;\nkey = function(s, press, key)\nif key:find 'shift' then\ns.key_shift = press\nreturn\nelseif key:find 'ctrl' then\ns.key_ctrl = press\nreturn\nelseif key:find 'alt' then\ns.key_alt = press\nif s.on then\nif not press and kbdalt then\ns.kbd_alt_xlat = not s.kbd_alt_xlat\nend\nreturn 'look'\nend\nreturn\nend\nif not press then\nreturn\nend\nif s.key_ctrl or s.key_alt then\nif s.on and key == 'q' then\nreturn '@dbg toggle'\nend\nif key == 'q' or key == 'r' then\nreturn\nend\nend\nif s.key_shift then\nif key == 'up' or key == 'down' then\nreturn\nend\nend\nif (key == 'f7'and not s.key_ctrl and not s.key_alt) or (s.key_ctrl and key == 'd') then\nreturn '@dbg toggle'\nend\nif s.on then\nreturn '@dbg key '..string.format(\"%q\", key)\nend\nend;\n}\nlocal function utf_bb(b, pos)\nif type(b) ~= 'string' or b:len() == 0 then\nreturn 0\nend\nlocal utf8 = (std.game.codepage == 'UTF-8' or std.game.codepage == 'utf-8')\nif not utf8 then return 1 end\nlocal i = pos or b:len()\nlocal l = 0\nwhile b:byte(i) >= 0x80 and b:byte(i) <= 0xbf do\ni = i - 1\nl = l + 1\nif i <= 1 then\nbreak\nend\nend\nreturn l + 1\nend\nlocal function utf_ff(b, pos)\nif type(b) ~= 'string' or b:len() == 0 then\nreturn 0\nend\nlocal utf8 = (std.game.codepage == 'UTF-8' or std.game.codepage == 'utf-8')\nif not utf8 then return 1 end\nlocal i = pos or 1\nlocal l = 0\nif b:byte(i) < 0x80 then\nreturn 1\nend\ni = i + 1\nl = l + 1\nwhile b:byte(i) >= 0x80 and b:byte(i) <= 0xbf do\ni = i + 1\nl = l + 1\nif i > b:len() then\nbreak\nend\nend\nreturn l\nend\nlocal function key_xlat(s)\nlocal kbd\nif s == 'return' then return '\\n' end\nif s == 'space' then return ' ' end\nif s:len() > 1 then\nreturn\nend\nif dbg.kbd_alt_xlat and (std.game.codepage == 'UTF-8' or std.game.codepage == 'utf-8') and kbdalt then\nkbd = kbdalt\nelse\nkbd = kbden\nend\nif kbd and dbg.key_shift then\nkbd = kbd.shifted;\nend\nif not kbd[s] then\nif dbg.key_shift then\nreturn s:upper();\nend\nreturn s;\nend\nreturn kbd[s]\nend\nstd.mod_cmd(function(cmd)\nif cmd[1] ~= '@dbg' then\nif dbg.on then\nif cmd[1] == 'look' then\nstd.abort()\nreturn std.call(dbg, 'dsc')\nend\nreturn nil, false\nend\nreturn\nend\nif cmd[2] == 'toggle' then\ndbg.on = not dbg.on\nif dbg.on then\ndbg:enable()\nstd.abort()\nreturn std.call(dbg, 'dsc')\nelse\ndbg:disable()\nreturn std.nop()\nend\nelseif cmd[2] == 'key' then\nlocal key = cmd[3]\nif key:find 'return' and not dbg.key_ctrl and not dbg.key_alt then\nlocal r, v = dbg:exec()\nif r ~= nil or v ~= nil then\nreturn r, v\nend\nelseif key:find '^backspace' then\nif dbg.input == '' then\nstd.abort()\nreturn std.call(dbg, 'dsc'), true\nend\nlocal pre, post = dbg:inp_split()\nif not pre or pre == '' then\nstd.abort()\nreturn std.call(dbg, 'dsc'), true\nend\nlocal i = utf_bb(pre)\ndbg.input = dbg.input:sub(1, pre:len() - i) .. post\ndbg.cursor = dbg.cursor - i\nelseif key:find '^tab' then\ndbg:completion()\nelseif key:find 'home' or (key == 'a' and dbg.key_ctrl) then\ndbg.cursor = 1\nelseif key:find 'end'  or (key == 'e' and dbg.key_ctrl) then\ndbg.cursor = #dbg.input + 1\nelseif (key == 'k' and dbg.key_ctrl) then\ndbg.cursor = 1\ndbg.input = ''\nelseif (key == 'l' and dbg.key_ctrl) then\ndbg:cls()\nelseif key:find '^right' then\nif dbg.cursor <= dbg.input:len() then\nlocal i = utf_ff(dbg.input, dbg.cursor)\ndbg.cursor = dbg.cursor + i\nend\nif dbg.cursor > dbg.input:len() then dbg.cursor = dbg.input:len() + 1 end\nelseif key:find '^left' then\nif dbg.cursor > 1 then\nlocal i = utf_bb(dbg.input, dbg.cursor - 1)\ndbg.cursor = dbg.cursor - i\nend\nif dbg.cursor < 1 then dbg.cursor = 1 end\nelseif key:find '^up' then\nlocal s = dbg\nif #s.history == 0 then\nreturn\nend\nif s.history_pos == 0 then\ns.history_pos = #s.history + 1\nend\ns.history_pos = s.history_pos - 1\nif s.history_pos == 0 then\ns.history_pos = 1\nend\ns.input = s.history[s.history_pos]\ns.cursor = #s.input + 1\nelseif key:find '^down' then\nlocal s = dbg\nif #s.history == 0 or s.history_pos == #s.history then\nreturn\nend\ns.history_pos = s.history_pos + 1\nif s.history_pos > #s.history then\ns.history_pos = #s.history\nend\ns.input = s.history[s.history_pos]\ns.cursor = #s.input + 1\nelseif key_xlat(key) then\nlocal k = key_xlat(key)\nlocal pre, post = dbg:inp_split()\ndbg.cursor = dbg.cursor + k:len()\ndbg.input = pre .. k .. post\nelse\nreturn nil, false\nend\ndbg:completion(false)\nstd.abort()\nreturn std.call(dbg, 'dsc'), true\nend\nend, -100)\nfunction std.dprint(...)\nlocal a = { ... }\ndbg:printf(\"dbg> \");\nfor i = 1, #a do\nif i ~= 1 then\ndbg:printf(\"%s\", ' ')\nstd.io.stderr:write(' ')\nend\ndbg:printf(\"%s\", std.tostr(a[i]))\nstd.io.stderr:write(std.tostr(a[i]))\nend\ndbg:printf(\"\\n\")\nstd.io.stderr:write('\\n')\nstd.io.stderr:flush()\nend\ndprint = std.dprint\nlocal oldlang\nlocal hooked = false\nstd.mod_start(function(_)\nlocal st, r\nif oldlang ~= LANG then\nst, r = std.pcall(function() return require ('dbg-'..LANG) end)\nif st and r then\nstd.dprint(\"dbg: Using '\"..LANG..\"' keyboard layout.\")\nkbden, kbdalt = r.main, r.alt\nend\nend\noldlang = LANG\niface:raw_mode(false)\nif not hooked then\nokey = input.key;\nhooked = true\nend\nstd.rawset(input, 'key', function(_, ...) return dbg:key(...) or (okey and okey(input, ...)) end)\nend, -100)\nstd.mod_done(function()\nhooked = false\niface:raw_mode(false)\nstd.rawset(input, 'key', okey)\nend, -100)\n-- std.rawset(_G, 'dbg',  std.ref '@dbg')\n","declare.lua":"-- luacheck: globals const global declare\nlocal declarations = {}\nlocal variables = {}\nlocal std = stead\nlocal type = std.type\nlocal rawget = std.rawget\nlocal rawset = std.rawset\nlocal pairs = std.pairs\nlocal table = std.table\nlocal next = std.next\nlocal function __declare_one(k, v, t)\nlocal link\nif type(k) ~= 'string' then -- k:find(\"^[a-zA-Z_][a-zA-Z0-9_]*$\") then\nstd.err (\"Wrong declaration name: \"..k, 3)\nend\nif declarations[k] then\nstd.err (\"Duplicate declaration: \"..k, 3)\nend\nlink = rawget(_G, k)\ndeclarations[k] = { value = v, type = t, link = link }\nif link and v ~= link then\nstd.err(\"Overwite global declaration: \"..std.tostr(k), 3)\nend\nif t == 'global' then\nif type(v) == 'function' and not std.functions[v] then\nstd.err(\"Use declare to declare function: \"..k, 3)\nend\nrawset(_G, k, v)\nvariables[k] = true\nend\nif type(v) == 'function' and not std.functions[v] then\nstd.functions[v] = k\nend\nif std.__in_init and std.is_obj(v, 'list') then\ntable.insert(v.__in_init, v)\nend\nend\nlocal function __declare(n, t)\nif stead.game then\nstd.err (\"Use \"..t..\" only in global context\", 2)\nend\nif type(n) == 'string' then\nreturn function(v)\nif v == nil then\nv = false\n--std.err(\"Wrong declaration: \"..std.tostr(t), 2)\nend\n__declare_one(n, v, t)\nend\nend\nif type(n) ~= 'table' then\nstd.err (\"Wrong parameter to \"..n, 2)\nend\nfor k, v in std.pairs(n) do\n__declare_one(k, v, t)\nend\nreturn n\nend\nfunction std.const(n)\nreturn __declare(n, 'const')\nend\nfunction std.global(n)\nreturn __declare(n, 'global')\nend\nfunction std.declare(n)\nreturn __declare(n, 'declare')\nend\nlocal function do_depends(t, tables, deps)\nif type(t) ~= 'table' then return end\nif tables[t] then\ndeps[t] = tables[t]\nend\nfor _, v in pairs(t) do\nif type(v) == 'table' and not std.getmt(v) then\ndo_depends(v, tables, deps)\nend\nend\nend\nlocal function makedeps(nam, depends, deps)\nlocal ndeps = {}\nlocal rc = false\nlocal t = rawget(_G, nam)\nif type(t) ~= 'table' then\nreturn\nend\nif type(depends[nam]) ~= 'table' then\nreturn\nend\nlocal d = depends[nam]\nfor k, v in pairs(d) do\nlocal dd = depends[v]\nif dd and k ~= t then\nndeps[k] = v\nrc = rc or makedeps(v, depends, deps)\nend\nend\nif not next(ndeps) then\ndepends[nam] = nil\ntable.insert(deps, t)\nrc = true\nelse\ndepends[nam] = ndeps\nend\nreturn rc\nend\nlocal function mod_save(fp)\n-- save global variables\nstd.tables = {}\nlocal tables = {}\nlocal deps = {}\nfor k, v in pairs(declarations) do -- name all table variables\nlocal o = rawget(_G, k) or v.value\nif type(o) == 'table' then\nif not tables[o] then\ntables[o] = k\nend\nend\nend\nfor k, _ in pairs(variables) do\nlocal d = {}\nlocal o = rawget(_G, k)\ndo_depends(o, tables, d)\nif k == tables[o] then -- self depend\nd[o] = nil\nend\nif next(d) then\ndeps[k] = d\nend\nend\nstd.tables = tables -- save all depends\nfor k, _ in pairs(variables) do -- write w/o deps\nlocal o = rawget(_G, k)\nif not deps[k] then\nstd.save_var(o, fp, k)\nend\nend\nfor k, _ in pairs(variables) do\nlocal d = {}\nwhile makedeps(k, deps, d) do\nfor i=1, #d do\nstd.save_var(d[i], fp, k)\nend\nd = {}\nend\nend\nend\nlocal function mod_init()\nstd.setmt(_G, {\n__index = function(_, n)\nlocal d = declarations[n]\nif d then --\nif std.game and (d.type ~= 'const') then\nrawset(_, n, d.value)\nend\nreturn d.value\nend\nlocal f = std.getinfo(2, \"S\").source\nstd.err (\"Uninitialized global variable: \"..n..\" in \"..f, 2)\nend;\n__newindex = function(t, k, v)\nif not std.game and std.is_obj(v) then -- autodeclare objects\n__declare_one(k, v, 'declare')\nend\nlocal d = declarations[k]\nif d then\nif v == d.value then\nreturn --nothing todo\nend\nif not std.game then\nd.value = v\nreturn\nend\nif d.type == 'const' then\nstd.err (\"Modify read-only constant: \"..k, 2)\nelse\nd.value = v\nrawset(t, k, v)\nend\nreturn\nend\nif std.game or type(v) ~= 'function' then\nlocal f = std.getinfo(2, \"S\").source\nif f ~= '=[C]' then\nstd.err (\"Set uninitialized variable: \"..k..\" in \"..f, 2)\nend\nend\nrawset(t, k, v)\nend\n})\nend\nstd.obj {\nnam = '@declare';\nini = function(_, ...)\n-- init all list objs\nfor _, v in pairs(declarations) do\nif std.is_obj(v.value, 'list') then\nv.value:__ini(...)\nend\nend\nend;\ndeclarations = function()\nreturn declarations;\nend;\nvariables = function()\nreturn variables\nend;\n}\nlocal function mod_done()\nstd.setmt(_G, {})\nlocal decl = {}\nfor k, v in pairs(declarations) do\nlocal o = std.rawget(_G, k) or v.value\nif std.is_system(o) then -- save system declarations\ndecl[k] = v\nelseif not v.link then\nrawset(_G, k, nil)\nend\nend\nstd.tables = {}\nstd.functions = {}\ndeclarations = decl\nvariables = {}\nend\nstd.mod_init(mod_init)\nstd.mod_done(mod_done)\nstd.mod_save(mod_save)\nconst = std.const\nglobal = std.global\ndeclare = std.declare\n","dlg.lua":"-- luacheck: read globals iface\nlocal std = stead\nlocal type = std.type\nlocal table = std.table\nstd.phrase_prefix = '-- '\nstd.phrase_show = true\nlocal function phr_prefix(d, nr)\nif type(std.phrase_prefix) == 'string' then\nd = std.phrase_prefix .. d\nelseif type(std.phrase_prefix) == 'function' then\nd = std.phrase_prefix(nr) .. d\nend\nreturn d\nend\nstd.dlg = std.class({\n__dlg_type = true;\nnew = function(s, v)\nif v.current == nil then\nv.current = false\nend\nv.dlg_enter = v.enter\nv.enter = nil\nv.__stack = {}\nif type(v.phr) == 'table' then\nif not v.obj then v.obj = {} end\nif type(v.obj) == 'table' then\ntable.insert(v.obj, 1, v.phr)\nend\nend\nv = std.room(v)\nstd.setmt(v, s)\nv:__recreate()\nreturn v\nend;\n__recreate = function(s)\nfor i = 1, #s.obj do\nif not std.is_obj(s.obj[i]) then\ns.obj[i] = std.phr(s.obj[i])\nend\nend\nend;\nwith = function(self, ...)\nstd.room.with(self, ...)\nself:__recreate()\nreturn self\nend;\nscene = function(s)\nlocal title, dsc, lact\ntitle = iface:title(std.titleof(s))\ndsc = std.call(s, 'dsc')\nif not std.me():moved() then\ns.__lact = std.game:lastreact() or s.__lact\nlact = iface:em(s.__lact)\nend\nreturn std.par(std.scene_delim, title or false, lact or false, dsc)\nend;\nph_onact = function(_, w) -- show dsc by default\nif not std.phrase_show then\nreturn\nend\nlocal r, v = std.call(w, 'dsc')\nif type(r) == 'string' then\nreturn phr_prefix(r)\nend\nreturn r, v\nend;\nempty = function(s, w)\nif not w then\nif not s.current then\nreturn true\nend\nreturn s.current:empty()\nend\nw = s:lookup(w)\nif not w then\nreturn true\nend\nreturn w:empty()\nend;\nenter = function(s, ...)\ns.__llact = false\ns.__stack = {}\ns.current = nil\ns:for_each(function(self) self:open() end) -- open all phrases\nlocal r, v = std.call(s, 'dlg_enter', ...)\nif std.here() ~= s or #s.__stack > 0 then\nreturn r, v\nend\nlocal rr, vv = s:push(s.current)\nif not vv then\nstd.err(\"Wrong dialog: \"..std.tostr(s), 2)\nend\nreturn std.par(std.scene_delim, r or false, rr or false), v\nend;\npush = function(s, p)\nlocal c = s.current\nlocal r = s:select(p)\nlocal t\nif r ~= false then\nif c then\ntable.insert(s.__stack, c)\nend\nif r.dsc ~= nil and r.ph_act == nil and r.next == nil then -- no rection\nt = std.call(r, 'dsc')\nend\nif s.current ~= r or std.me():moved() then\nreturn t\nend\nif r:empty() then\nlocal tt, vv = s:pop()\nt = std.par(std.scene_delim, t or false, tt or false)\nif not vv then\ntt = std.walkout(s:from())\nt = std.par(std.scene_delim, t or false, tt or false)\nend\nend\nend\nreturn t, r ~= false\nend;\nreset = function(s, phr)\ns.__stack = {}\nreturn s:push(phr)\nend;\npop = function(s, phr)\nif #s.__stack == 0 then\nreturn false\nend\nif phr then\nlocal l = {}\nfor i = 1, #s.__stack do\ntable.insert(l, s.__stack[i])\nif s.stack[i] == phr then\nbreak\nend\nend\ns.__stack = l\nend\nlocal p\nwhile #s.__stack > 0 do\np = table.remove(s.__stack, #s.__stack) -- remove top\np = s:select(p)\nif not p then\nreturn false\nend\nif p:empty() then\nlocal r, v = std.call(p, 'onempty')\nif v then\nreturn r, p\nend\nelse\nreturn false, p\nend\nend\nreturn false\nend;\nselect = function(s, p)\nif #s.obj == 0 then\nreturn false\nend\nif not p then -- get first one\np = s.obj[1]\nend\nlocal c = s:lookup(p)\nif not c then\nstd.err(\"Wrong dlg:select argumant: \"..std.tostr(p), 2)\nend\nc:select()\n-- if c:disabled() then -- select always enables phrase\n--c:enable()\n-- end\ns.current = c\nreturn c\nend;\nsrch = function(s, w)\nlocal oo = s.current -- lookup in current\nif not oo then\nreturn\nend\nlocal r, l, i = s:lookup(w)\nif not r then\nreturn\nend\nif not std.is_obj(r, 'phr') then -- simple object\nreturn std.room.srch(s, w)\nend\nw = oo.obj:for_each(function(v) -- aliases\nv = v:__alias()\nif not v:visible() then\nreturn\nend\nif v == r then\nreturn v\nend\nend)\nif not w then\nreturn\nend\nreturn r, l, i\nend;\ndisplay = function(s)\nlocal deco = std.call(s, 'decor'); -- static decorations\nreturn std.par(std.scene_delim, deco or false, s:ph_display())\nend;\nph_display = function(s)\nlocal r, nr\nnr = 1\nlocal oo = s.current\nif not oo then -- nothing to show\nreturn\nend\noo:select() -- to recheck all\nfor i = 1, #oo.obj do\nlocal o = oo.obj[i]\no = o:__alias()\nif o:visible() then\nif r then\nr = r .. '^'\nend\nlocal d = std.call(o, 'dsc')\nif type(d) == 'string' then\nd = phr_prefix(d, nr)\nd = o:__xref(d, true)\nr = (r or '').. d\nnr = nr + 1\nend\nend\nend\nreturn r\nend;\n}, std.room)\nstd.phr = std.class({\n__phr_type = true;\nnew = function(s, t)\nlocal disabled\nlocal a = t\nlocal o = {\nobj = {}\n}\nfor i = 1, #a do\nlocal v = a[i]\nif i == 1 and type(v) == 'boolean' then\nif not v then\ndisabled = true\nelse\no.always = true\nend\nelseif type(v) == 'table' then\nif not std.is_obj(v, 'phr') then\nv = s:new(v)\nend\ntable.insert(o.obj, v)\nelseif o.tag == nil and v ~= nil and std.is_tag(v) then\no.tag = v\nelseif o.dsc == nil and v ~= nil then\no.dsc = v\nelseif o.act == nil and v ~= nil then\no.act = v\nend\nend\nfor k, v in std.pairs(a) do\nif type(k) == 'string' then\no[k] = v\nend\nend\n--if o.act == nil then\n--std.err(\"Wrong phrase (no act)\", 2)\n--end\no.ph_act = o.act\no.act = nil\ndisabled = disabled or (o.hidden == true)\no = std.obj(o)\nstd.setmt(o, s)\nif disabled then o = o:disable() end\nreturn o\nend,\n__alias = function(s)\nif s.alias ~= nil then\nlocal ss = std.here():lookup(s.alias)\nif not std.is_obj(ss) then\nstd.err(\"Wrong alias: \"..std.tostr(s.alias), 3)\nend\ns = ss\nend\nreturn s\nend;\ncheck = function(s)\n--s = s:__alias()\nif type(s.cond) == 'function' then\nif s:cond() then\ns:enable()\nelse\ns:disable()\nend\nend\nend;\nempty = function(s)\nfor i = 1, #s.obj do\nlocal o = s.obj[i]\nif not o:disabled() and not o:closed() then\nreturn false\nend\nend\nreturn true\nend;\nvisible = function(s)\nreturn not s:disabled() and not s:closed()\nend;\nact = function(s, ...)\nlocal r, _\nlocal n = s\n--s = s:__alias()\nlocal onact, v = std.call(std.here(), 'ph_onact', s)\nif not v then\nreturn onact\nend\nlocal w = s:where()\nif w and w.only then -- only one choice\nfor i = 1, #w.obj do\nlocal o = w.obj[i]\nif not o.always then\no:close()\nend\nend\nelseif not s.always then\ns:close()\nend\nlocal cur = std.here().current\nr, _ = std.call(s, 'ph_act', ...)\nr = std.par(std.scene_delim, onact or false, r or false)\nif std.me():moved() or cur ~= std.here().current then\nreturn r, v\nend\nif std.is_tag(s.next) then\nn = s.next\nend\ncur:select() -- conditions\nlocal t\nlocal rr, vv = std.here():push(n)\nif not vv then\nt = std.walkout(std.here():from())\nend\nreturn std.par(std.scene_delim, r or false, rr or false, t or false), v\nend,\nselect = function(s)\nif not s.always then\ns:close()\nend\nfor i = 1, #s.obj do\nlocal o = s.obj[i]\no = o:__alias()\no:check()\nend\nend;\n}, std.obj)\n","events.lua":"local std = stead\nlocal input = std.ref '@input'\nlocal instead = std.ref '@instead'\n-- luacheck: no self\nfunction input:event(...)\n-- luacheck: self\nlocal a\nfor _, v in std.ipairs {...} do\na = (a and (a..', ') or ' ') .. std.dump(v)\nend\nreturn '@user_event'.. a or ''\nend\nstd.mod_cmd(function(cmd)\nif cmd[1] ~= '@user_event' then\nreturn\nend\nlocal r, v =  std.call(instead, 'onevent', cmd[2])\nif not r and not v then -- nothing todo\nreturn nil, false\nend\nreturn r, v\nend)\n","ext/gui.lua":"-- sdl-instead specific methods\nlocal std = stead\nlocal instead = std.obj {\nnam = '@instead';\nversion_table = {3, 2, 2};\nini = function(s) -- after reset always do fade\ns.need_fading(true)\nend;\n}\n-- luacheck: read globals instead_clipboard\n-- luacheck: read globals instead_wait_use\n-- luacheck: read globals instead_grab_events\n-- luacheck: no self\ninstead.clipboard = instead_clipboard\ninstead.wait_use = instead_wait_use\ninstead.grab_events = instead_grab_events\nfunction instead.atleast(...)\nfor k, v in std.ipairs {...} do\nif std.type(v) ~= 'number' then\nreturn false\nend\nif v > (instead.version_table[k] or 0) then\nreturn false\nend\nif v < (instead.version_table[k] or 0) then\nreturn true\nend\nend\nreturn true\nend\nfunction instead.version(...)\nif #{...} == 0 then\nreturn instead.version_table\nend\nif not instead.atleast(...) then\nlocal v = false\nfor _, n in std.ipairs({...}) do\nif std.type(n) ~= 'number' then\nstd.err([[Wrong instead.version argument: ]]..std.tostr(n), 2)\nend\nv = (v and (v .. '.') or '').. std.tostr(n)\nend\nstd.err ([[The game requires instead engine of version ]] ..(v or '???').. [[ or higher.\nhttps://instead-hub.github.io]], 2)\nend\nend\nfunction instead.need_fading(v)\nlocal ov = instead.__need_fading\nif v ~= nil then\ninstead.__need_fading = v\nend\nreturn ov\nend\nlocal iface = std '@iface'\nlocal type = std.type\nlocal dict = {}\ninstead.inv_delim = '\\n'\ninstead.hinv_delim = ' | '\ninstead.ways_delim = ' | '\nlocal function get_bool(o, nam)\nif type(o[nam]) == 'boolean' then\nreturn o[nam]\nend\nif type(o[nam]) == 'function' then\nreturn o:nam()\nend\nreturn nil\nend\ninstead.notitle = false\ninstead.get_title = std.cacheable('title', function()\nif get_bool(instead, 'notitle') then\nreturn\nend\nreturn iface:fmt(iface:bold(std.titleof(stead.here())), false)\nend)\ninstead.noways = false\ninstead.get_ways = std.cacheable('ways', function()\nif get_bool(instead, 'noways') then\nreturn\nend\nlocal str = iface:cmd(\"way\");\nif str then\nstr = std.string.gsub(str, '\\n$','');\nstr = std.string.gsub(str, '\\\\?['..std.delim ..']',\n{ [std.delim] = instead.ways_delim, [ '\\\\'..std.delim ] = std.delim });\nreturn iface:center(str);\nend\nreturn str\nend)\ninstead.noinv = false\ninstead.get_inv = std.cacheable('inv', function(horiz)\nif get_bool(instead, 'noinv') then\nreturn\nend\nlocal str = iface:cmd(\"inv\");\nif str then\nstr = std.string.gsub(str, '\\n$','');\nif not horiz then\nstr = std.string.gsub(str, '\\\\?['.. std.delim ..']',\n{ [std.delim] = instead.inv_delim, ['\\\\'..std.delim] = std.delim });\nelse\nstr = std.string.gsub(str, '\\\\?['.. std.delim ..']',\n{ [std.delim] = instead.hinv_delim, ['\\\\'..std.delim] = std.delim });\nend\nend\nreturn str\nend)\ninstead.nopic = false\n-- luacheck: push ignore savedpicture\nlocal savedpicture\n-- luacheck: pop\ninstead.get_picture = std.cacheable('pic', function()\nif get_bool(instead, 'nopic') then\nreturn\nend\nlocal s = stead.call(std.here(), 'pic')\nif not s then\ns = stead.call(std.ref 'game', 'pic')\nend\nsavedpicture = s -- to save picture sprite from unload\nreturn s and std.tostr(s)\nend)\nlocal last_picture\ninstead.fading_value = 4 -- default fading\nfunction instead.get_fading()\nif not instead.fading then\nreturn false\nend\nif type(instead.fading) == 'function' and\nnot instead.fading() then\nreturn false\nend\nreturn true, instead.fading_value\nend\nfunction instead.fading()\nlocal pic = instead.get_picture()\nif type(pic) == 'string' and pic:find('spr:', 1, true) == 1 then\npic = 'spr:'\nend\nif std.me():need_scene() or instead.need_fading() or pic ~= last_picture then\nlast_picture = pic\nreturn true\nend\nend\nfunction instead.get_restart()\nlocal restart = instead.__restart or false\ninstead.__restart = nil\nreturn restart\nend\nfunction instead.get_menu()\nlocal menu = instead.__menu\ninstead.__menu = nil\nreturn menu\nend\ninstead.nosave = false\ninstead.noautosave = false\nfunction instead.isEnableSave()\nlocal s = get_bool(instead, 'nosave')\nreturn not s\nend\nfunction instead.isEnableAutosave()\nif instead.get_autosave() then\nreturn true\nend\nreturn not get_bool(instead, 'noautosave')\nend\nfunction instead.autosave(slot)\ninstead.__autosave = true\ninstead.__autosave_slot = slot\nend\nfunction instead.get_autosave()\nreturn instead.__autosave or false, instead.__autosave_slot\nend\nfunction instead.menu(n)\nif n == nil then\nn = 'main'\nelseif type(n) ~= 'string' and n ~= false then\nn = 'toggle'\nend\ninstead.__menu = n\nend\nfunction instead.restart(v)\nif v == false then v = false else v = true end\ninstead.__restart = v\nend\nfunction iface:title() -- hide title\nreturn\nend\n-- luacheck: globals stat\nstd.stat = std.class({\n__stat_type = true;\n}, std.obj);\n-- luacheck: globals menu\nstd.menu = std.class({\n__menu_type = true;\nnew = function(_, v)\nif type(v) ~= 'table' then\nstd.err (\"Wrong argument to std.menu:\"..std.tostr(v), 2)\nend\nv = std.obj(v)\n--std.setmt(v, self)\nreturn v\nend;\ninv = function(s, ...)\nlocal r, v\nif s.menu ~= nil then\nr, v = std.call(s, 'menu', ...) -- special method while in inv\nelse\nr, v = std.call(s, 'act', ...) -- fallback to act\nend\nif not r and not v then\nreturn true, false -- menu mode\nend\nreturn r, v\nend;\n}, std.obj);\nstd.setmt(std.phr, std.menu) -- make phrases menus\nstd.setmt(std.ref '@', std.menu) -- make xact menu\nfunction iface:esc(str)\nstr = str:gsub(\"\\\\?[\\\\<>]\", { ['\\\\\\\\'] = '\\\\\\\\\\\\\\\\\\\\', ['>'] = iface:nb('>'), ['<'] = iface:nb('<') })\nreturn str\nend\nfunction iface:xref(str, o, ...)\nif type(str) ~= 'string' then\nstd.err (\"Wrong parameter to iface:xref: \"..std.tostr(str), 2)\nend\nif not std.is_obj(o) or std.is_obj(o, 'stat') or o:disabled() then\nreturn str\nend\nlocal a = { ... }\nlocal args = ''\nfor i = 1, #a do\nif type(a[i]) ~= 'string' and type(a[i]) ~= 'number' and type(a[i]) ~= 'boolean' then\nstd.err (\"Wrong argument to iface:xref: \"..std.tostr(a[i]), 2)\nend\nargs = args .. ' '..std.dump(a[i])\nend\nlocal xref = std.string.format(\"%s%s\", std.deref_str(o), args)\n-- std.string.format(\"%s%s\", iface:esc(std.deref_str(o)), iface:esc(args))\nif not dict[xref] then\ntable.insert(dict, xref)\ndict[xref] = #dict\nend\nxref = std.tostr(dict[xref])\nif std.cmd[1] == 'way' then\nreturn std.string.format(\"<a:go %s>\", xref)..str..\"</a>\"\nelseif std.is_obj(o, 'menu') or std.is_system(o) then\nreturn std.string.format(\"<a:act %s>\", xref)..str..\"</a>\"\nelseif std.cmd[1] == 'inv' then\nreturn std.string.format(\"<a:use %s>\", xref)..str..\"</a>\"\nend\nreturn std.string.format(\"<a:obj/act %s>\", xref)..str..\"</a>\"\nend\nfunction iface:em(str)\nif type(str) == 'string' then\nreturn '<i>'..str..'</i>'\nend\nend\nfunction iface:center(str)\nif type(str) == 'string' then\nreturn '<c>'..str..'</c>'\nend\nend\nfunction iface:just(str)\nif type(str) == 'string' then\nreturn '<j>'..str..'</j>'\nend\nend\nfunction iface:left(str)\nif type(str) == 'string' then\nreturn '<l>'..str..'</l>'\nend\nend\nfunction iface:right(str)\nif type(str) == 'string' then\nreturn '<r>'..str..'</r>'\nend\nend\nfunction iface:bold(str)\nif type(str) == 'string' then\nreturn '<b>'..str..'</b>'\nend\nend\nfunction iface:top(str)\nif type(str) == 'string' then\nreturn '<t>'..str..'</t>'\nend\nend\nfunction iface:bottom(str)\nif type(str) == 'string' then\nreturn '<d>'..str..'</d>'\nend\nend\nfunction iface:middle(str)\nif type(str) == 'string' then\nreturn '<m>'..str..'</m>'\nend\nend\nfunction iface:nb(str)\nif type(str) == 'string' then\nreturn \"<w:\"..str:gsub(\"\\\\\", \"\\\\\\\\\\\\\\\\\"):gsub(\">\",\"\\\\>\"):gsub(\"%^\",\"\\\\^\")..\">\";\nend\nend\nfunction iface:anchor()\nreturn '<a:#>'\nend\nfunction iface:img(str)\nif str then\nreturn \"<g:\"..std.tostr(str)..\">\"\nend\nend;\nfunction iface:imgl(str)\nif str then\nreturn \"<g:\"..std.tostr(str)..\"\\\\|left>\"\nend\nend;\nfunction iface:imgr(str)\nif str then\nreturn \"<g:\"..std.tostr(str)..\"\\\\|right>\"\nend\nend\nfunction iface:under(str)\nif type(str) == 'string' then\nreturn \"<u>\"..str..\"</u>\"\nend\nend;\nfunction iface:st(str)\nif type(str) == 'string' then\nreturn \"<s>\"..str..\"</s>\"\nend\nend\nfunction iface:tab(str, al)\nif type(str) == 'number' then\nstr = std.tostr(str)\nend\nif type(str) ~= 'string' then\nreturn\nend\nif al == 'right' then\nstr = str .. \",right\"\nelseif al == 'center' then\nstr = str .. \",center\"\nend\nreturn '<x:'..str..'>'\nend\nfunction iface:y(str, al)\nif stead.tonum(str) then\nstr = stead.tostr(str)\nend\nif stead.type(str) ~= 'string' then\nreturn nil;\nend\nif al == 'middle' then\nstr = str .. \",middle\"\nelseif al == 'top' then\nstr = str .. \",top\"\nend\nreturn '<y:'..str..'>'\nend;\nfunction iface:input(event, ...)\nlocal input = std.ref '@input'\nif type(input) ~= 'table' then\nreturn\nend\nif event == 'kbd' then\nif type(input.key) == 'function' then\nreturn input:key(...); -- pressed, event\nend\nelseif event == 'mouse' then\nif type(input.click) == 'function' then\nreturn input:click(...); -- pressed, x, y, mb\nend\nelseif event == 'finger' then\nif type(input.finger) == 'function' then\nreturn input:finger(...); -- pressed, x, y, finger\nend\nelseif event == 'event' then\nif type(input.event) == 'function' then\nreturn input:event(...);\nend\nend\nreturn\nend\nlocal iface_cmd = iface.cmd -- save old\nfunction iface:cmd(inp)\nlocal a = std.split(inp)\nif a[1] == 'act' or a[1] == 'use' or a[1] == 'go' then\nif a[1] == 'use' then\nlocal use = std.split(a[2], ',')\nfor i = 1, 2 do\nlocal u = std.tonum(use[i])\nif u then\nuse[i] = dict[u]\nend\nend\na[2] = std.join(use, ',')\nelseif std.tonum(a[2]) then\na[2] = dict[std.tonum(a[2])]\nend\ninp = std.join(a)\nend\nreturn iface_cmd(self, inp)\nend\nstd.obj { -- input object\nnam = '@input';\n};\n-- some aliases\nmenu = std.menu\nstat = std.stat\nstd.mod_init(function()\nstd.rawset(_G, 'instead', instead)\nrequire \"ext/sandbox\"\nend)\nstd.mod_cmd(function()\ninstead.need_fading(false)\nend)\nstd.mod_step(function(state)\nif state then\ndict = {}\nend\nend)\nstd.mod_start(function()\ndict = {}\nend)\nstd.mod_done(function()\nlast_picture = nil\nend)\nstd.mod_save(function()\ninstead.__autosave = nil\ninstead.__autosave_slot = nil\nend)\nif std.rawget(_G, 'DEBUG') then\nrequire 'dbg'\nend\n","ext/paths.lua":"local std = stead\nlocal instead = std.ref '@instead'\n-- luacheck: read globals instead_savepath\n-- luacheck: read globals instead_gamepath\n-- luacheck: read globals instead_exepath\n-- luacheck: globals io\ninstead.savepath = instead_savepath\nstd.savepath = instead_savepath\ninstead.gamepath = instead_gamepath\ninstead.exepath = instead_exepath\nio.open = stead.hook(io.open, function(f, path, acc, ...)\nif std.type(path) == 'string' and path:sub(1, 1) ~= '/' and not\n(path:sub(2, 2) == ':' and path:find(\"^[A-Z]\", 1) == 1) then\npath = instead.gamepath()..'/'..path\nend\nreturn f(path, acc, ...)\nend)\n","ext/sandbox.lua":"-- luacheck: globals STANDALONE\n-- luacheck: read globals instead\n-- luacheck: globals io os debug\n-- luacheck: read globals instead_realpath\nlocal function sandbox()\nif STANDALONE or not instead.gamepath then -- not standalone or not sdl-instead\nreturn\nend\n-- luacheck: no unused args\nlocal check_path = function(realpath, type, find, gsub, savepath, gamepath, path)\n-- luacheck: unused args\nif not path then\nreturn false\nend\npath = realpath(path)\nif not path then\nreturn false\nend\nlocal spath = realpath(savepath)\nif not spath then\nreturn false\nend\nlocal s = find(path, spath..'/', 1, true)\nif s ~= 1 then\nspath = realpath(gamepath);\nif spath then\ns = find(path, spath..'/', 1, true)\nend\nend\nif s ~= 1 then\nreturn false\nend\nreturn true\nend\nlocal build_sandbox_open = function(realpath, error, type, find, gsub, savepath, gamepath)\nreturn stead.hook(io.open, function(f, path, acc, ...)\n  if type(acc) ~= 'string' or not find(acc, \"[aw+]\") then -- only write access\n  return f(path, acc, ...)\n  end\n-- luacheck: no unused args\n  if not check_path(realpath, type, find, gsub, savepath, gamepath, path) then\n-- luacheck: unused args\n  error (\"Access denied (write): \".. path, 3);\n  return false\n  end\n  return f(path, acc, ...)\nend)\nend\nlocal build_sandbox_remove = function(realpath, error, type, find, gsub, savepath, gamepath)\nreturn stead.hook(os.remove, function(f, path, ...)\n  if type(path) ~= 'string' then\n  return f(path, ...)\n  end\n  if not check_path(realpath, type, find, gsub, savepath, gamepath, path) then\n  error (\"Access denied (remove): \".. path, 3);\n  return false\n  end\n  return f(path, ...)\nend)\nend\nlocal build_sandbox_rename = function(realpath, error, type, find, gsub, savepath, gamepath)\nreturn stead.hook(os.rename, function(f, oldname, newname, ...)\n  if not check_path(realpath, type, find, gsub, savepath, gamepath, oldname) or\n  not check_path(realpath, type, find, gsub, savepath, gamepath, newname) then\n  error (\"Access denied (rename): \".. oldname .. ', '.. newname, 3);\n  return false\n  end\n  return f(oldname, newname, ...)\nend)\nend\nlocal build_sandbox_output = function(realpath, error, type, find, gsub, savepath, gamepath)\nreturn stead.hook(io.output, function(f, path, ...)\n  if type(path) == 'string' and not check_path(realpath, type, find, gsub, savepath, gamepath, path) then\n  error (\"Access denied (output): \".. path, 3);\n  return false\n  end\n  return f(path, ...)\nend)\nend\nio.open = build_sandbox_open(instead_realpath, error, type, string.find, string.gsub,\n     instead.savepath(), instead.gamepath());\nos.remove = build_sandbox_remove(instead_realpath, error, type, string.find, string.gsub,\n instead.savepath(), instead.gamepath());\nos.rename = build_sandbox_rename(instead_realpath, error, type, string.find, string.gsub,\n instead.savepath(), instead.gamepath());\nio.output = build_sandbox_output(instead_realpath, error, type, string.find, string.gsub,\n instead.savepath(), instead.gamepath());\nos.execute = function(s)\nprint (\"Warning: trying to do os.execute: \"..s);\nend\nio.popen = function(s)\nprint (\"Warning: trying to do io.popen: \"..s);\nend\nos.tmpname = function(_)\nprint (\"Warning: trying to do os.tmpname\");\nend\nif not stead.rawget(_G, 'DEBUG') then\ndebug = nil\nend\npackage.cpath = \"\"\npackage.preload = {}\npackage = nil\nend\nsandbox()\n","ext/sound.lua":"-- raw interface to sound\nlocal std = stead\nlocal instead = std.ref '@instead'\n-- luacheck: globals instead_sound_load\n-- luacheck: globals instead_sound_free\n-- luacheck: globals instead_sounds_free\n-- luacheck: globals instead_sound_channel\n-- luacheck: globals instead_sound_volume\n-- luacheck: globals instead_sound_panning\n-- luacheck: globals instead_sound_load_mem\n-- luacheck: globals instead_music_callback\n-- luacheck: globals instead_sound\ninstead.sound_load = instead_sound_load\ninstead.sound_free = instead_sound_free\ninstead.sounds_free = instead_sounds_free\ninstead.sound_channel = instead_sound_channel\ninstead.sound_volume = instead_sound_volume\ninstead.sound_panning = instead_sound_panning\ninstead.sound_load_mem = instead_sound_load_mem\ninstead.music_callback = instead_music_callback\ninstead.is_sound = instead_sound\nfunction instead.get_music()\nreturn instead.__music, instead.__music_loop\nend\nfunction instead.set_music(mus, loop)\ninstead.__music = mus or nil\ninstead.__music_loop = loop or 0\nend\nfunction instead.get_music_fading()\nreturn instead.__music_fadeout, instead.__music_fadein\nend\nfunction instead.set_music_fading(o, i)\nif not i then i = o end\nif o == 0 or not o then o = -1 end\nif i == 0 or not i then i = -1 end\ninstead.__music_fadeout = o\ninstead.__music_fadein = i\nend\nfunction instead.finish_music()\nif (instead.__music_loop or 0) == 0 then\nreturn false\nend\ninstead.__music_loop = -1\nreturn true\nend\nfunction instead.get_sound()\nreturn instead.__sound, instead.__sound_channel, instead.__sound_loop\nend\nfunction instead.add_sound(s, chan, loop)\nif type(s) ~= 'string' then\nstd.err(\"Wrong parameter to instead.add_sound()\", 2)\nend\nif type(instead.__sound) ~= 'string' then\nreturn instead.set_sound(s, chan, loop)\nend\nif std.tonum(chan) then\ns = s..'@'..std.tostr(chan);\nend\nif std.tonum(loop) then\ns = s..','..std.tostr(loop)\nend\ninstead.set_sound(instead.__sound..';'..s, instead.__sound_channel, instead.__sound_loop);\nend\nfunction instead.set_sound(sound, chan, loop)\ninstead.__sound = sound\ninstead.__sound_loop = loop or 1\ninstead.__sound_channel = chan or -1\nend\nfunction instead.stop_sound(chan, fo)\nlocal str = '@-1'\nif (chan and type(chan) ~= 'number') or (fo and type(fo) ~= 'number') then\nstd.err(\"Wrong parameter to instead.stop_sound\", 2)\nend\nif chan then\nstr = '@'..std.tostr(chan)\nend\nif fo then\nstr = str .. ',' .. std.tostr(fo)\nend\nreturn instead.add_sound(str);\nend\nfunction instead.stop_music()\ninstead.set_music(nil, -1);\nend\nstd.mod_done(function(_)\ninstead.music_callback() -- halt music mixer\ninstead.stop_music()\ninstead.stop_sound() -- halt all\n--instead.sounds_free();\nend)\nlocal sounds = {}\nstd.mod_cmd(function(_)\nif std 'game':time() > 0 then\nsounds = {}\ninstead.set_sound(); -- empty sound\nend\nend)\n-- aliases\nlocal snd = {\n__gc = function(s)\ninstead.sound_free(s.snd)\nend;\n__tostring = function(s)\nreturn s.snd\nend\n}\nsnd.__index = snd;\nfunction snd:play(...)\nif self.snd then\ninstead.add_sound(self.snd, ...)\nend\nend\nfunction snd:new(a, b, t)\nlocal o = {\n__save = function() end;\n}\nif type(a) == 'string' then\no.snd = instead.sound_load(a);\nelseif type(t) == 'table' then\no.snd = instead.sound_load_mem(a, b, t) -- hz, channel, t\nend\n--if not o.snd then\n--return\n--end\nstd.setmt(o, self)\nreturn std.proxy(o)\nend\nlocal sound = std.obj {\nnam = '@snd';\n}\nsound.set = instead.set_sound\nsound.play = instead.add_sound\nsound.stop = instead.stop_sound\nsound.music = function(mus, loop)\nif mus == nil and loop == nil then\nreturn instead.get_music()\nend\nreturn instead.set_music(mus, loop)\nend\nsound.stop_music = instead.stop_music\nsound.music_fading = function(o, i)\nif o == nil and i == nil then\nreturn instead.get_music_fading()\nend\nreturn instead.set_music_fading(o, i)\nend\nfunction sound.new(...)\nlocal s = snd:new(...)\nstd.table.insert(sounds, s) -- avoid __gc in this step\nreturn s\nend\nfunction sound.music_callback(...)\nreturn instead.music_callback(...)\nend\nfunction sound.free(key)\nreturn instead.sound_free(key);\nend\nfunction sound.music_playing()\nreturn instead.__music ~= nil and instead.__music_loop ~= -1\nend\nfunction sound.playing(s,...)\nif type(s) ~= 'number' then\nreturn instead.is_sound()\nend\nreturn instead.sound_channel(s,...)\nend\nfunction sound.pan(c, l, r, ...)\nreturn instead.sound_panning(c, l, r, ...)\nend\nfunction sound.vol(v, ...)\nreturn instead.sound_volume(v, ...)\nend\n","ext/sprites.lua":"local std = stead\nlocal type = std.type\nlocal instead = std.ref '@instead'\n-- luacheck: read globals instead_theme_var\n-- luacheck: read globals instead_theme_name\n-- luacheck: read globals instead_ticks\n-- luacheck: read globals instead_font_load\n-- luacheck: read globals instead_font_free\n-- luacheck: read globals instead_font_scaled_size\n-- luacheck: read globals instead_sprite_alpha\n-- luacheck: read globals instead_sprite_dup\n-- luacheck: read globals instead_sprite_scale\n-- luacheck: read globals instead_sprite_rotate\n-- luacheck: read globals instead_sprite_text\n-- luacheck: read globals instead_sprite_text_size\n-- luacheck: read globals instead_sprite_draw\n-- luacheck: read globals instead_sprite_copy\n-- luacheck: read globals instead_sprite_compose\n-- luacheck: read globals instead_sprite_fill\n-- luacheck: read globals instead_sprite_pixel\n-- luacheck: read globals instead_sprite_load\n-- luacheck: read globals instead_sprite_free\n-- luacheck: read globals instead_sprite_size\n-- luacheck: read globals instead_sprites_free\n-- luacheck: read globals instead_sprite_colorkey\n-- luacheck: read globals instead_sprite_pixels\n-- luacheck: read globals instead_mouse_pos\n-- luacheck: read globals instead_mouse_show\n-- luacheck: read globals instead_mouse_filter\n-- luacheck: read globals instead_finger_pos\n-- luacheck: read globals instead_noise1\n-- luacheck: read globals instead_noise2\n-- luacheck: read globals instead_noise3\n-- luacheck: read globals instead_noise4\n-- luacheck: read globals instead_render_callback\n-- luacheck: read globals instead_direct\n-- luacheck: read globals instead_busy\n-- luacheck: read globals instead_sprite_pixels\n-- theme\ninstead.theme_var = instead_theme_var\ninstead.theme_name = instead_theme_name\ninstead.screen_size = instead_screen_size\nlocal theme = std.obj {\nnam = '@theme';\nvars = {};\nreset_vars = {};\n{\nwin = { gfx = {}};\ninv = { gfx = {}};\nmenu = { gfx = {}};\ngfx = {};\nsnd = {};\nscr = {};\n};\n}\nfunction theme.restore(name)\nif type(name) ~= 'string' then\nstd.err(\"Wrong parameter to theme.restore\", 2)\nend\nlocal v = theme.vars[name]\nif not v then\nreturn\nend\ninstead.theme_var(name, v);\nend\nfunction theme.set(name, val)\nif type(name) ~= 'string' or val == nil then\nstd.err(\"Wrong parameter to theme.set\", 2)\nend\nif not theme.reset_vars[name] then\ntheme.reset_vars[name] = instead.theme_var(name)\nend\ninstead.theme_var(name, std.tostr(val));\ntheme.vars[name] = std.tostr(val);\nend\nfunction theme.reset(name)\nif type(name) ~= 'string' then\nstd.err(\"Wrong parameter to theme.reset\", 2)\nend\nlocal v = theme.reset_vars[name]\nif not v then\nreturn\nend\ninstead.theme_var(name, v);\ntheme.vars[name] = nil\ntheme.reset_vars[name] = nil\nend\nfunction theme.name(...)\nreturn instead.theme_name(...);\nend\nfunction theme.get(...)\nreturn instead.theme_var(...);\nend\nfunction theme.scr.w()\nreturn tonumber(theme.get 'scr.w')\nend\nfunction theme.scr.h()\nreturn tonumber(theme.get 'scr.h')\nend\nfunction theme.win.reset()\nstd.for_all(theme.reset, \"win.x\", \"win.y\", \"win.w\", \"win.h\",\n    \"win.col.fg\", \"win.col.link\", \"win.col.alink\",\n    \"win.fnt.name\", \"win.fnt.size\", \"win.fnt.height\");\nend\nfunction theme.win.geom(x, y, w, h)\ntheme.set(\"win.x\", x);\ntheme.set(\"win.y\", y);\ntheme.set(\"win.w\", w);\ntheme.set(\"win.h\", h);\nend\nfunction theme.win.color(fg, link, alink)\ntheme.set(\"win.col.fg\", fg);\ntheme.set(\"win.col.link\", link);\ntheme.set(\"win.col.alink\", alink);\nend\nfunction theme.win.font(name, size, height)\ntheme.set(\"win.fnt.name\", name);\ntheme.set(\"win.fnt.size\", size);\ntheme.set(\"win.fnt.height\", height);\nend\nfunction theme.win.gfx.reset()\nstd.for_all(theme.reset, \"win.gfx.up\", \"win.up.x\", \"win.up.y\");\nstd.for_all(theme.reset, \"win.gfx.down\", \"win.down.x\", \"win.down.y\");\nend\nfunction theme.win.gfx.up(pic, x, y)\ntheme.set(\"win.gfx.up\", pic);\ntheme.set(\"win.up.x\", x);\ntheme.set(\"win.up.y\", y);\nend\nfunction theme.win.gfx.down(pic, x, y)\ntheme.set(\"win.gfx.down\", pic);\ntheme.set(\"win.down.x\", x);\ntheme.set(\"win.down.y\", y);\nend\nfunction theme.inv.reset()\nstd.for_all(theme.reset, \"inv.x\", \"inv.y\", \"inv.w\", \"inv.h\",\n    \"inv.col.fg\", \"inv.col.link\", \"inv.col.alink\",\n    \"inv.fnt.name\", \"inv.fnt.size\", \"inv.fnt.height\",\n    \"inv.mode\");\nend\nfunction theme.inv.geom(x, y, w, h)\ntheme.set(\"inv.x\", x);\ntheme.set(\"inv.y\", y);\ntheme.set(\"inv.w\", w);\ntheme.set(\"inv.h\", h);\nend\nfunction theme.inv.color(fg, link, alink)\ntheme.set(\"inv.col.fg\", fg);\ntheme.set(\"inv.col.link\", link);\ntheme.set(\"inv.col.alink\", alink);\nend\nfunction theme.inv.font(name, size, height)\ntheme.set(\"inv.fnt.name\", name);\ntheme.set(\"inv.fnt.size\", size);\ntheme.set(\"inv.fnt.height\", height);\nend\nfunction theme.inv.mode(mode)\ntheme.set(\"inv.mode\", mode);\nend\nfunction theme.inv.gfx.reset()\nstd.for_all(theme.reset, \"inv.gfx.up\", \"inv.up.x\", \"inv.up.y\");\nstd.for_all(theme.reset, \"inv.gfx.down\", \"inv.down.x\", \"inv.down.y\");\nend\nfunction theme.inv.gfx.up(pic, x, y)\ntheme.set(\"inv.gfx.up\", pic);\ntheme.set(\"inv.up.x\", x);\ntheme.set(\"inv.up.y\", y);\nend\nfunction theme.inv.gfx.down(pic, x, y)\ntheme.set(\"inv.gfx.down\", pic);\ntheme.set(\"inv.down.x\", x);\ntheme.set(\"inv.down.y\", y);\nend\nfunction theme.menu.reset()\nstd.for_all(theme.reset, \"menu.bw\",\n    \"menu.col.fg\", \"menu.col.bg\", \"menu.col.alpha\",\n    \"menu.col.link\", \"menu.col.alink\",\n    \"menu.fnt.name\", \"menu.fnt.size\", \"menu.fnt.height\");\nend\nfunction theme.menu.bw(w)\ntheme.set(\"menu.bw\", w)\nend\nfunction theme.menu.color(fg, bg, alpha, link, alink)\ntheme.set(\"menu.col.fg\", fg);\ntheme.set(\"menu.col.bg\", bg);\ntheme.set(\"menu.col.alpha\", alpha);\ntheme.set(\"menu.col.link\", link);\ntheme.set(\"menu.col.alink\", alink);\nend\nfunction theme.menu.font(name, size, height)\ntheme.set(\"menu.fnt.name\", name);\ntheme.set(\"menu.fnt.size\", size);\ntheme.set(\"menu.fnt.height\", height);\nend\nfunction theme.menu.gfx.reset()\nstd.for_all(theme.reset, \"menu.gfx.button\", \"menu.button.x\", \"menu.button.y\");\nend\nfunction theme.menu.gfx.button(b, x, y)\ntheme.set(\"menu.gfx.button\", b);\ntheme.set(\"menu.button.x\", x);\ntheme.set(\"menu.button.y\", y);\nend;\nfunction theme.gfx.reset()\nstd.for_all(theme.reset, \"scr.gfx.cursor.normal\", \"scr.gfx.cursor.use\",\n    \"scr.gfx.cursor.x\", \"scr.gfx.cursor.y\",\n    \"scr.gfx.mode\", \"scr.gfx.pad\",\n    \"scr.gfx.bg\");\nend\nfunction theme.gfx.cursor(norm, use, x, y)\ntheme.set(\"scr.gfx.cursor.normal\", norm);\ntheme.set(\"scr.gfx.cursor.use\", use);\ntheme.set(\"scr.gfx.cursor.x\", x);\ntheme.set(\"scr.gfx.cursor.y\", y);\nend\nfunction theme.gfx.mode(mode)\ntheme.set(\"scr.gfx.mode\", mode);\nend\nfunction theme.gfx.pad(pad)\ntheme.set(\"scr.gfx.pad\", pad);\nend\nfunction theme.gfx.bg(bg)\ntheme.set(\"scr.gfx.bg\", bg);\nend\nfunction theme.snd.reset()\ntheme.reset(\"snd.click\");\nend\nfunction theme.snd.click(w)\ntheme.set(\"snd.click\", w);\nend\n-- sprites\ninstead.ticks = instead_ticks\ninstead.font_load = instead_font_load\ninstead.font_free = instead_font_free\ninstead.font_scaled_size = instead_font_scaled_size\ninstead.sprite_alpha = instead_sprite_alpha\ninstead.sprite_dup = instead_sprite_dup\ninstead.sprite_scale = instead_sprite_scale\ninstead.sprite_rotate = instead_sprite_rotate\ninstead.sprite_text = instead_sprite_text\ninstead.sprite_text_size = instead_sprite_text_size\ninstead.sprite_draw = instead_sprite_draw\ninstead.sprite_copy = instead_sprite_copy\ninstead.sprite_compose = instead_sprite_compose\ninstead.sprite_fill = instead_sprite_fill\ninstead.sprite_pixel = instead_sprite_pixel\ninstead.sprite_load = instead_sprite_load\ninstead.sprite_free = instead_sprite_free\ninstead.sprite_size = instead_sprite_size\ninstead.sprites_free = instead_sprites_free\ninstead.sprite_colorkey = instead_sprite_colorkey\ninstead.sprite_pixels = instead_sprite_pixels\ninstead.mouse_pos = instead_mouse_pos\ninstead.mouse_show = instead_mouse_show\ninstead.mouse_filter = instead_mouse_filter\ninstead.finger_pos = instead_finger_pos\ninstead.noise1 = instead_noise1\ninstead.noise2 = instead_noise2\ninstead.noise3 = instead_noise3\ninstead.noise4 = instead_noise4\ninstead.render_callback = instead_render_callback\ninstead.direct = instead_direct\nstd.busy = instead_busy\nlocal spr = {\n__gc = function(s)\ninstead.sprite_free(s.spr)\nend;\n__tostring = function(s)\nreturn s.spr\nend;\n}\nspr.__index = spr\nlocal fnt = {\n__gc = function(s)\ninstead.font_free(s.fnt)\nend;\n__tostring = function(s)\nreturn s.fnt\nend;\n}\nfnt.__index = fnt\nlocal spr_get = function(s)\nif type(s) == 'string' then\nreturn s\nend\nreturn std.tostr(s)\nend\nfunction fnt:new(nam)\nif type(nam) ~= 'string' then\nstd.err(\"Wrong argument to fnt:new(): \"..std.tostr(nam), 2)\nend\nlocal o = {\nfnt = nam;\n__save = function() end;\n}\nstd.setmt(o, self)\nreturn std.proxy(o)\nend\nfunction fnt:text(text, col, style, ...)\nreturn spr:new(instead.sprite_text(self.fnt, text, col, style, ...))\nend\nfunction fnt:size(...)\nreturn instead.sprite_text_size(self.fnt, ...);\nend\nfunction fnt:height(...)\nlocal _, h = self:size(...)\nreturn h\nend\nfunction spr:new(nam)\nif type(nam) ~= 'string' then\nstd.err(\"Wrong argument to spr:new(): \"..std.tostr(nam), 2)\nend\nlocal o = {\nspr = nam;\n__save = function() end;\n}\nstd.setmt(o, self)\nreturn std.proxy(o)\nend;\nfunction spr:alpha(alpha, ...)\nreturn spr:new(instead.sprite_alpha(self.spr, alpha, ...));\nend\nfunction spr:colorkey(color, ...)\ninstead.sprite_colorkey(self.spr, color, ...);\nreturn self\nend\nfunction spr:dup(...)\nreturn spr:new(instead.sprite_dup(self.spr, ...));\nend\nfunction spr:scale(xs, ys, smooth, ...)\nif smooth == nil then\nsmooth = true -- default is on\nend\nreturn spr:new(instead.sprite_scale(self.spr, xs, ys, smooth,...));\nend\nfunction spr:rotate(angle, smooth, ...)\nif smooth == nil then\nsmooth = true -- default is on\nend\nreturn spr:new(instead.sprite_rotate(self.spr, angle, smooth, ...));\nend\nfunction spr:size()\nreturn instead.sprite_size(self.spr);\nend\nfunction spr:draw(fx, fy, fw, fh, d, x, y, alpha)\nif d == nil and x == nil and y == nil then\nd, x, y, alpha = fx, fy, fw, fh\nfx, fy, fw, fh = 0, 0, -1, -1\nend\ninstead.sprite_draw(self.spr, fx, fy, fw, fh, spr_get(d), x, y, alpha);\nreturn d\nend\nfunction spr:copy(fx, fy, fw, fh, d, x, y)\nif d == nil and x == nil and y == nil then\nd, x, y = fx, fy, fw\nfx, fy, fw, fh = 0, 0, -1, -1\nend\ninstead.sprite_copy(self.spr, fx, fy, fw, fh, spr_get(d), x, y);\nreturn d\nend\nfunction spr:compose(fx, fy, fw, fh, d, x, y)\nif d == nil and x == nil and y == nil then\nd, x, y = fx, fy, fw\nfx, fy, fw, fh = 0, 0, -1, -1\nend\ninstead.sprite_compose(self.spr, fx, fy, fw, fh, spr_get(d), x, y);\nreturn d\nend\nfunction spr:fill(x, y, w, h, col)\nif h == nil and col == nil then\ninstead.sprite_fill(self.spr, 0, 0, -1, -1, x);\nreturn self\nend\ninstead.sprite_fill(self.spr, x, y, w, h, col);\nreturn self\nend\nfunction spr:pixel(x, y, col, alpha)\nif not col then\nreturn instead.sprite_pixel(self.spr, x, y, col, alpha)\nend\ninstead.sprite_pixel(self.spr, x, y, col, alpha)\nreturn self\nend\nlocal screen = spr:new 'screen'\nlocal sprite = {\nnam = '@sprite';\n}\nfunction sprite.new(w, h, ...)\nif std.tonum(w) and std.tonum(h) then\nlocal t = 'blank:'..std.tostr(std.math.floor(w))..'x'..std.tostr(std.math.floor(h))\nreturn spr:new(instead.sprite_load(t))\nend\nlocal sp = instead.sprite_load(w, h, ...)\nif not sp then\nstd.err(\"Can not load sprite: \"..std.tostr(w), 2);\nend\nreturn spr:new(sp)\nend\nfunction sprite.fnt(name, sz, ...)\nif not std.tonum(sz) then\nstd.err(\"No font size specified in sprite:fnt().\", 2)\nend\nlocal fn = instead.font_load(name, sz, ...)\nif not fn then\nstd.err(\"Can not load font: \"..std.tostr(name), 2);\nend\nreturn fnt:new(fn)\nend\nfunction sprite.scr()\nreturn screen\nend\nfunction sprite.direct(v)\nreturn instead.direct(v)\nend\nfunction sprite.font_scaled_size(size)\nreturn instead.font_scaled_size(size);\nend\nlocal render_cb = nil\nfunction sprite.render_callback(fn)\nlocal old = render_cb\nrender_cb = fn\ninstead.render_callback(render_cb)\nreturn old\nend\nstd.obj(sprite)\ninstead.sprite_pixels = instead_sprite_pixels\nlocal pfnt = {\n}\npfnt.__index = pfnt\nstd.setmt(pfnt, fnt)\nlocal pxl = {\n}\npxl.__index = pxl\nfunction pxl:dup()\nlocal w, h, s = self:size()\nlocal p = instead.sprite_pixels(w, h, s)\nif p then\nself:copy(p)\nend\nreturn self:new(p)\nend\nfunction pxl:sprite()\nreturn sprite.new(self)\nend\nfunction pxl:draw_spr(fx, fy, fw, fh, d, x, y, alpha)\nif d == nil and x == nil and y == nil then\ninstead.sprite_draw(self, 0, 0, -1, -1, spr_get(fx), fy, fw, fh);\nreturn fx\nend\ninstead.sprite_draw(self, fx, fy, fw, fh, spr_get(d), x, y, alpha);\nreturn d\nend\nfunction pxl:copy_spr(fx, fy, fw, fh, d, x, y, alpha)\nif d == nil and x == nil and y == nil then\ninstead.sprite_copy(self, 0, 0, -1, -1, spr_get(fx), fy, fw, fh);\nreturn fx\nend\ninstead.sprite_copy(self, fx, fy, fw, fh, spr_get(d), x, y, alpha);\nreturn d\nend\nfunction pxl:compose_spr(fx, fy, fw, fh, d, x, y, alpha)\nif d == nil and x == nil and y == nil then\ninstead.sprite_compose(self, 0, 0, -1, -1, spr_get(fx), fy, fw, fh);\nreturn fx\nend\ninstead.sprite_compose(self, fx, fy, fw, fh, spr_get(d), x, y, alpha);\nreturn d\nend\nfunction pxl:scale(...)\nreturn pxl:new(self:new_scaled(...))\nend\nfunction pxl:rotate(...)\nreturn pxl:new(self:new_rotated(...))\nend\nlocal function poly(self, fn, t, ...)\nif type(t) ~= 'table' then\nstd.err(\"Wrong argument to :poly()\", 3)\nend\nif #t < 4 then\nreturn\nend\nlocal n = #t\nfor i = 1, n, 2 do\nif i == n - 1 then\nfn(self, t[i], t[i+1], t[1], t[2], ...);\nelse\nfn(self, t[i], t[i+1], t[i+2], t[i+3], ...);\nend\nend\nend\nfunction pxl:poly(t, ...)\npoly(self, self.line, t, ...)\nend\nfunction pxl:polyAA(t, ...)\npoly(self, self.lineAA, t, ...)\nend\nfunction pxl:new(p)\nif type(p) ~= 'userdata' then\nreturn\nend\nlocal t = getmetatable(p).__index\nsetmetatable(t, self)\nreturn p\nend\nfunction pfnt:new(nam)\nreturn fnt.new(self, nam)\nend\nfunction pfnt:text(text, col, style, ...)\nlocal s = self\nreturn pxl:new(instead.sprite_pixels(instead.sprite_text(s.fnt, text, col, style, ...)))\nend\nlocal pixels = {\nnam = '@pixels';\n}\nfunction pixels.fnt(name, sz, ...)\nif not std.tonum(sz) then\nstd.err(\"No font size specified.\", 2)\nend\nreturn pfnt:new(instead.font_load(name, -sz, ...))\nend\nfunction pixels.new(...)\nreturn pxl:new(instead.sprite_pixels(...))\nend\nstd.obj (pixels)\nlocal rnd_seed = 1980 + 1978\nstead.mod_init(function()\nrnd_seed = (std.os.time(stead.os.date(\"*t\")) + rnd_seed + instead.ticks())\nstd.rnd_seed(rnd_seed)\nend)\nstead.mod_done(function()\nsprite.render_callback() -- stop render\n--instead.sprites_free();\nend)\n","ext/timer.lua":"-- raw iface to timer\n-- luacheck: read globals instead_timer\nlocal std = stead\nlocal type = std.type\nlocal instead = std.ref '@instead'\ninstead.timer = instead_timer\nlocal timer = std.obj {\nnam = '@timer';\nini = function(s)\nif s.__timer then\ns:set(s.__timer)\nend\nend;\nget = function(s)\nreturn s.__timer or 0;\nend;\nstop = function(s)\nreturn s:set(0)\nend;\nset = function(s, v)\nif type(v) ~= 'number' then\nstd.err(\"Wrong argument to timer:set(): \"..std.tostr(v), 2)\nend\ns.__timer = v\ninstead.timer(s.__timer)\nreturn true\nend;\ncallback = function(_)\nreturn '@timer'\nend\n}\nstd.timer = function() -- sdl part call this one\nif std.type(timer.callback) == 'function' then\nreturn timer:callback();\nend\nreturn\nend\nstd.mod_done(function(_)\ntimer:stop()\nend)\nstd.mod_cmd(function(cmd)\nif cmd[1] ~= '@timer' then\nreturn\nend\nlocal r, v = std.call(stead.here(), 'timer');\nif not r and not v then\nr, v = stead.call(std.game, 'timer');\nend\nif not r and not v then -- nothing todo\nreturn nil, false\nend\nreturn r, v\nend)\n","finger.lua":"-- luacheck: globals finger\nlocal std = stead\nlocal input = std.ref '@input'\nlocal table = table\nlocal instead = std.ref '@instead'\nfinger = std.obj {\nnam = '@finger';\n{\nfingers_list = { };\n};\n-- luacheck: no unused args\nfilter = function(s, press, fid, x, y, px, py) -- by default, all finger events\n-- luacheck: unused args\nreturn true\nend\n}\nfunction finger:event(press, fid, x, y, px, py)\nlocal s = self\nif press then\nlocal v = s:lookup(fid)\nif v then\nv.x, v.y, v.px, v.py = x, y, px, py\nelse\ntable.insert(s.fingers_list,\n{ id = fid, x = x, y = y, px = px, py = py })\nend\nreturn\nend\nlocal _, k = s:lookup(fid)\nif k then\ntable.remove(s.fingers_list, k)\nend\nend\nfunction finger:list()\nlocal s = self\nlocal new = {}\nfor _, v in std.ipairs(s.fingers_list) do\nlocal x, y, pressure = instead.finger_pos(v.id)\nif x then\nv.x, v.y, v.pressure = x, y, pressure\ntable.insert(new, v)\nend\nend\ns.fingers_list = new\nreturn new\nend\nfunction finger:get(fid)\nlocal s = self\nlocal _, k\nlocal x, y, pressure = instead.finger_pos(fid)\nif not x then\n_, k = s:lookup(fid)\nif k then\ntable.remove(s.fingers_list, k)\nend\nreturn\nend\nreturn x, y, pressure\nend\nfunction finger:lookup(fid)\nlocal s = self\nfor k, v in std.ipairs(s.fingers_list) do\nif v.id == fid then\nreturn v, k\nend\nend\nend\nfunction input:finger(press, fid, x, y, px, py, ...)\nlocal a\nfinger:event(press, fid, x, y, px, py, ...)\nif not finger:filter(press, fid, x, y, px, py, ...) then\nreturn\nend\nfor _, v in std.ipairs {press, fid, x, y, px, py, ...} do\na = (a and (a..', ') or ' ') .. std.dump(v)\nend\nreturn '@finger'.. (a or '')\nend\nstd.mod_cmd(function(cmd)\nif cmd[1] ~= '@finger' then\nreturn\nend\nlocal r, v\nr, v = std.call(std.here(), 'onfinger', cmd[2], cmd[3], cmd[4], cmd[5], cmd[6], cmd[7])\nif not r and not v then\nr, v = std.call(std.game, 'onfinger', cmd[2], cmd[3], cmd[4], cmd[5], cmd[6], cmd[7])\nend\nif not r and not v then -- nothing todo\nreturn nil, false\nend\nreturn r, v\nend)\n","fmt.lua":"local std = stead\nlocal type = std.type\nlocal iface = std.ref '@iface'\n-- luacheck: globals fmt\nfmt = std.obj {\nnam = '@format';\npara = false;\nnopara = '_';\npara_space = '    ';\nquotes = true;\ndash = true;\nfilter = nil;\n}\nstd.obj {\nnam = '$fmt';\nact = function(_, w, ...)\nif type(w) ~= 'string' or not fmt[w] then\nreturn w\nend\nreturn fmt[w](...)\nend\n}\nstd.format = function(r, state)\nlocal utf8 = (std.ref 'game'.codepage == 'UTF-8' or std.ref 'game'.codepage == 'utf-8')\nif type(r) ~= 'string' then\nreturn r\nend\nif type(fmt.filter) == 'function' then\nr = fmt.filter(r, state)\nend\nif utf8 then\nif fmt.dash then\nr = r:gsub(\"%-%-%-*\", { ['--'] = '—' })\nr = r:gsub(\"[ \\t]+—\", iface:nb('')..\"—\"); -- do not break dash\nr = r:gsub(\"^([^ \\t]*)—[ \\t]+\", \"%1— \");\nr = r:gsub(\"(\\n[^ \\t]*)—[ \\t]+\", \"%1— \");\nend\nif fmt.quotes then\nr = r:gsub('_\"','«'):gsub('\"_',\"»\");\nr = r:gsub('\"([^\"]*)\"','«%1»');\nr = r:gsub(',,','„'):gsub(\"''\",'”');\nend\nend\nif not state then\nreturn r\nend\nif fmt.para then\nr = r:gsub('\\n([^\\n])', '\\001%1'):gsub('\\001[ \\t]*'..fmt.nopara,'\\n'):gsub('\\001[ \\t]*', '\\n'..iface:nb(fmt.para_space));\nr = r:gsub('^[ \\t]*', '\\001'):gsub('\\001[ \\t]*'..fmt.nopara,''):gsub('\\001[ \\t]*', iface:nb(fmt.para_space));\nend\nreturn r\nend\nfunction fmt.em(str)\nreturn iface:em(str)\nend\nfunction fmt.c(str)\nreturn iface:center(str)\nend\nfunction fmt.j(str)\nreturn iface:just(str)\nend\nfunction fmt.l(str)\nreturn iface:left(str)\nend\nfunction fmt.r(str)\nreturn iface:right(str)\nend\nfunction fmt.b(str)\nreturn iface:bold(str)\nend\nfunction fmt.top(str)\nreturn iface:top(str)\nend\nfunction fmt.bottom(str)\nreturn iface:bottom(str)\nend\nfunction fmt.middle(str)\nreturn iface:middle(str)\nend\nfunction fmt.nb(str)\nreturn iface:nb(str)\nend\nfunction fmt.anchor(str)\nreturn iface:anchor(str)\nend\nfunction fmt.img(str)\nreturn iface:img(str)\nend\nfunction fmt.imgl(str)\nreturn iface:imgl(str)\nend\nfunction fmt.imgr(str)\nreturn iface:imgr(str)\nend\nfunction fmt.u(str)\nreturn iface:under(str)\nend\nfunction fmt.st(str)\nreturn iface:st(str)\nend\nfunction fmt.tab(str, al)\nreturn iface:tab(str, al)\nend\nfunction fmt.y(str, al)\nreturn iface:y(str, al)\nend\n","keys.lua":"local std = stead\nlocal input = std.ref '@input'\n-- luacheck: globals keys\nkeys = std.obj {\nnam = '@keys';\n{\n__alt = false;\n__ctrl = false;\n__shift = false;\n__state = {};\n};\nstate = function(s, key)\nreturn s.__state[key] or false\nend;\nevent = function(s, press, key)\nif key:find 'alt' then\nkey = 'alt'\nelseif key:find 'ctrl' then\nkey = 'ctrl'\nelseif key:find 'shift' then\nkey = 'shift'\nend\ns.__state[key] = press\nend;\n-- luacheck: no unused args\nfilter = function(s, press, key)\n-- luacheck: unused args\nreturn false\nend\n}\nfunction input:key(press, key)\nlocal a\nkeys:event(press, key)\nif not keys:filter(press, key) then\nreturn\nend\nfor _, v in std.ipairs {press, key} do\na = (a and (a..', ') or ' ') .. std.dump(v)\nend\nreturn '@key'.. (a or '')\nend\nstd.mod_cmd(function(cmd)\nif cmd[1] ~= '@key' then\nreturn\nend\nlocal r, v\nr, v = std.call(std.here(), 'onkey', cmd[2], cmd[3])\nif not r and not v then\nr, v = std.call(std.game, 'onkey', cmd[2], cmd[3])\nend\nif not r and not v then -- nothing todo\nreturn nil, false\nend\nreturn r, v\nend)\n","noinv.lua":"local std = stead\nstd.mod_step(function(state)\nif not state then\nreturn\nend\nif std.here().noinv and not std.me().__inv_disabled then\nstd.me():close()\nstd.me().__inv_disabled = true\nelseif std.me().__inv_disabled and not std.here().noinv then\nstd.me():open()\nstd.me().__inv_disabled = nil\nend\nend)\nstd.mod_done(function()\nif std.me().__inv_disabled then\nstd.me():open()\nstd.me().__inv_disabled = nil\nend\nend)\n","nolife.lua":"local std = stead\nstd.mod_step(function(state)\nif not state then\nreturn\nend\nif std.here().nolife and std.game:live() then\nstd.game:lifeoff()\nelseif not std.game:live() and not std.here().nolife then\nstd.game:lifeon()\nend\nend)\nstd.mod_done(function()\nif not std.game:live() then\nstd.game:lifeon()\nend\nend)\n","prefs.lua":"-- luacheck: globals prefs\nlocal std = stead\nlocal preferences = std.obj {\nnam = '@prefs',\nload = function(_)\nlocal name = std.savepath() .. '/prefs';\nlocal f, err = std.loadfile(name);\nif not f then\nreturn false, err\nend\nlocal strict = std.nostrict; std.nostrict = true\nf();\nstd.nostrict = strict\nreturn true\nend,\nstore = function(s)\nreturn s:save()\nend,\nsave = function(s) -- save prefs on every save\nlocal name = std.savepath() .. '/prefs';\nlocal name_tmp = name..'.tmp'\nlocal fp, _ = std.io.open(name_tmp, \"wb\");\nif not fp then\nreturn false\nend\nstd.obj.save(s, fp, 'std \"@prefs\"')\nfp:flush();\nfp:close();\nstd.os.remove(name)\nreturn std.os.rename(name_tmp, name);\nend,\npurge = function(_)\nlocal name = std.savepath() .. '/prefs';\nreturn std.os.remove(name);\nend\n};\nlocal loaded\nstd.mod_start(function()\nloaded = prefs:load()\nend)\nstd.mod_done(function()\nif loaded then\nprefs:store()\nloaded = false\nend\nend)\nprefs = preferences\n","snapshots.lua":"-- luacheck: globals snapshots\nlocal std = stead\nlocal SNAPSHOT = false\nlocal INWRITE = false\nlocal snap = std.obj {\nnam = '@snapshots';\ndata = {};\nsave = function(s, ...)\nif INWRITE then return end\nreturn std.obj.save(s, ...)\nend;\nwrite = function(s, name)\nname = name or 'default'\nlocal fp = { -- fake file object\ndata = '';\nwrite = function(self, str)\nself.data = self.data .. str\nend;\n}\nINWRITE = true std:save(fp) INWRITE = false\ns.data[name] = fp.data\nend;\nmake = function(_, name)\nSNAPSHOT = name or 'default'\nend;\nexists = function(s, name)\nname = name or 'default'\nreturn s.data[name]\nend;\nremove = function(s, name)\nname = name or 'default'\ns.data[name] = nil\nend;\nrestore = function(s, name) -- like std:load()\nname = name or 'default'\nif not s:exists(name) then\nreturn false\nend\nstd:reset()\nstd.ref 'game':__ini()\nlocal f, err = std.eval(s.data[name])\nif not f then\nstd.err(err, 2)\nend\nf();\nstd.ref 'game':__ini()\nstd.ref 'game':__start(true)\nreturn std.nop()\nend;\n}\nsnapshots = snap\nstd.mod_cmd(function()\nif SNAPSHOT then\nsnap:write(SNAPSHOT)\nSNAPSHOT = nil\nend\nend)\n-- std.mod_done(function()\n-- end)\n","snd.lua":"-- luacheck: globals snd\nsnd = stead.ref '@snd'","sprite.lua":"-- luacheck: globals sprite pixels\nsprite = stead.ref '@sprite'\npixels = stead.ref '@pixels'\n","stdlib.lua":"-- luacheck: read globals declare\nlocal std = stead\nlocal type = std.type\n-- luacheck: read globals game\nstd.rawset(_G, 'std', stead)\n-- luacheck: globals include\ninclude = std.include\n-- luacheck: globals loadmod\nloadmod = std.loadmod\n-- luacheck: globals rnd\nrnd = std.rnd\n-- luacheck: globals rnd_seed\nrnd_seed = std.rnd_seed\n-- luacheck: globals p\np = std.p\n-- luacheck: globals pr\npr = std.pr\n-- luacheck: globals pn\npn = std.pn\n-- luacheck: globals pf\npf = std.pf\n-- luacheck: globals obj\nobj = std.obj\n-- luacheck: globals stat\nstat = std.stat\n-- luacheck: globals room\nroom = std.room\n-- luacheck: globals menu\nmenu = std.menu\n-- luacheck: globals dlg\ndlg = std.dlg\n-- luacheck: globals me\nme = std.me\n-- luacheck: globals here\nhere = std.here\n-- luacheck: globals from\nfrom = std.from\n-- luacheck: globals new\nnew = std.new\n-- luacheck: globals delete\ndelete = std.delete\n-- nameof = std.nameof\n-- dispof = std.dispof\n-- titleof = std.titleof\n-- luacheck: globals gamefile\ngamefile = std.gamefile\n-- luacheck: globals player\nplayer = std.player\n-- luacheck: globals dprint\ndprint = std.dprint\nlocal function _pfn(f1, f2, ...)\nlocal a = {...}\nif type(f2) == 'string' then\nreturn function()\nf1()\nstd.p(f2, std.unpack(a))\nend\nend\nif type(f2) ~= 'function' then\nreturn f1()\nend\nreturn function(f3, ...)\nreturn _pfn(function()\nf1()\nf2(std.unpack(a))\nend, f3, ...)\nend\nend\n-- luacheck: globals pfn\nfunction pfn(f, ...)\nlocal a = {...}\nif type(f) == 'function' then\nreturn _pfn(function() end, f, ...)\nend\nreturn function()\nstd.p(f, std.unpack(a))\nend\nend\n-- luacheck: globals from\nfunction from(ww)\nlocal wh\nww = ww or std.here()\nwh = std.ref(ww)\nif not std.is_obj(wh, 'room') then\nstd.err(\"Wrong argument to from(): \"..std.tostr(wh), 2)\nend\nreturn wh:from()\nend;\nlocal function walkroom(w)\nif std.is_tag(w) then\nlocal ww = std.here().way:lookup(w)\nif not ww then\nstd.err(\"Can not found tag: \"..std.tostr(w), 3)\nend\nreturn ww\nend\nreturn w\nend\n-- luacheck: globals visits\nfunction visits(w)\nif not w then return std.here():visits() end\nreturn std.object(walkroom(w)):visits()\nend\n-- luacheck: globals visited\nfunction visited(w)\nif not w then return std.here():visited() end\nreturn std.object(walkroom(w)):visited()\nend\n-- luacheck: globals walk\nfunction walk(w, ...)\nlocal r, v = std.me():walk(walkroom(w), ...)\nif std.cctx() and type(r) == 'string' then\nstd.p(r)\nend\nreturn r, v\nend\n-- luacheck: globals life_walk\nfunction life_walk(w, ...)\ngame:reaction(false)\ngame:events(false, false)\nreturn walk(w, ...)\nend\n-- luacheck: globals walkin\nfunction walkin(w, ...)\nlocal r, v = std.me():walkin(walkroom(w), ...)\nif std.cctx() and type(r) == 'string' then\nstd.p(r)\nend\nreturn r, v\nend\n-- luacheck: globals walkout\nfunction walkout(w, ...)\nlocal r, v = std.me():walkout(walkroom(w), ...)\nif std.cctx() and type(r) == 'string' then\nstd.p(r)\nend\nreturn r, v\nend\n-- luacheck: globals walkback\nfunction walkback(w, ...)\nreturn walkout(w, false, ...)\nend\nstd.walkout = walkout\nstd.walkin = walkin\nstd.walk = walk\nlocal function object(w)\nlocal o\nif std.is_tag(w) then\no = std.here():lookup(w)\nif not o then\no = std.me():lookup(w)\nend\nif not o then\nstd.err(\"Wrong tag: \"..w, 3)\nend\nreturn o\nend\no = std.ref(w)\nif not o then\nstd.err(\"Wrong object: \"..std.tostr(w), 3)\nend\nreturn o\nend\nstd.object = object\n-- luacheck: globals _\n_ = std.object\n-- luacheck: globals for_all\nfor_all = std.for_all\n-- luacheck: globals seen\nfunction seen(w, ww)\nlocal wh\nww = ww or std.here()\nif not std.is_obj(ww, 'list') then\nwh = std.ref(ww)\nelse\nreturn ww:srch(w)\nend\nif not std.is_obj(wh) then\nstd.err(\"Wrong 2-nd argument to seen(): \"..std.tostr(ww), 2)\nend\nreturn wh:srch(w)\nend\n-- luacheck: globals lookup\nfunction lookup(w, ww)\nlocal wh\nww = ww or std.here()\nif not std.is_obj(ww, 'list') then\nwh = std.ref(ww)\nelse\nreturn ww:lookup(w)\nend\nif not std.is_obj(wh) and not std.is_obj(wh, 'list') then\nstd.err(\"Wrong 2-nd argument to lookup(): \"..std.tostr(ww), 2)\nend\nreturn wh:lookup(w)\nend\n-- luacheck: globals ways\nfunction ways(ww)\nlocal wh\nww = ww or std.here()\nwh = std.ref(ww)\nif not std.is_obj(wh, 'room') then\nstd.err(\"Wrong 2-nd argument to ways(): \"..std.tostr(ww), 2)\nend\nreturn wh.way\nend\nstd.ways = ways\n-- luacheck: globals objs\nfunction objs(ww)\nlocal wh\nww = ww or std.here()\nwh = std.ref(ww)\nif not std.is_obj(wh) then\nstd.err(\"Wrong 2-nd argument to objs(): \"..std.tostr(ww), 2)\nend\nreturn wh.obj\nend\n-- luacheck: globals inspect\nfunction inspect(w, ...)\nreturn std.me():inspect(std.object(w), ...)\nend\n-- luacheck: globals have\nfunction have(w, ...)\nreturn std.me():have(std.object(w), ...)\nend\n-- luacheck: globals inroom\nfunction inroom(w, ...)\nreturn std.object(w):inroom(...)\nend\n-- luacheck: globals where\nfunction where(w, ...)\nreturn std.object(w):where(...)\nend\n-- luacheck: globals closed\nfunction closed(w)\nreturn std.object(w):closed()\nend\n-- luacheck: globals disabled\nfunction disabled(w)\nreturn std.object(w):disabled()\nend\n-- luacheck: globals enable\nfunction enable(w)\nreturn std.object(w):enable()\nend\n-- luacheck: globals disable\nfunction disable(w)\nreturn std.object(w):disable()\nend\n-- luacheck: globals open\nfunction open(w)\nreturn std.object(w):open()\nend\n-- luacheck: globals close\nfunction close(w)\nreturn std.object(w):close()\nend\n-- luacheck: globals actions\nfunction actions(w, t, v)\nreturn std.object(w):actions(t, v)\nend\n-- luacheck: globals pop\nfunction pop(w, ww)\nlocal wh = ww or std.here()\nif not std.is_obj(wh, 'dlg') then\nstd.err(\"Call pop() in non-dialog object: \"..std.tostr(wh), 2)\nend\nlocal r, v = wh:pop(w)\nif std.cctx() and type(r) == 'string' then\nstd.p(r)\nend\nreturn r, v\nend\n-- luacheck: globals push\nfunction push(w, ww)\nlocal wh = ww or std.here()\nif not std.is_obj(wh, 'dlg') then\nstd.err(\"Call push() in non-dialog object: \"..std.tostr(wh), 2)\nend\nlocal r, v = wh:push(w)\nif std.cctx() and type(r) == 'string' then\nstd.p(r)\nend\nreturn r, v\nend\n-- luacheck: globals empty\nfunction empty(w, ...)\nif not w then\nreturn std.here():empty()\nend\nreturn std.object(w):empty(...)\nend\n-- luacheck: globals lifeon\nfunction lifeon(w, ...)\nreturn std 'game':lifeon(w and std.object(w), ...)\nend\n-- luacheck: globals lifeoff\nfunction lifeoff(w, ...)\nreturn std 'game':lifeoff(w and std.object(w), ...)\nend\n-- luacheck: globals live\nfunction live(...)\nreturn std 'game':live(...)\nend\n-- luacheck: globals change_pl\nfunction change_pl(w, ...)\nreturn std 'game':set_pl(w and std.object(w), ...)\nend\n-- luacheck: globals player_moved\nfunction player_moved(pl)\npl = pl or std.me()\npl = std.ref(pl)\nif not std.is_obj(pl, 'player') then\nstd.err(\"Wrong argument to player_moved(): \"..std.tostr(pl))\nend\nreturn std.me():moved()\nend\n-- luacheck: globals inv\nfunction inv(pl)\npl = pl or std.me()\npl = std.ref(pl)\nif not std.is_obj(pl, 'player') then\nstd.err(\"Wrong argument to inv(): \"..std.tostr(pl))\nend\nreturn pl:inventory()\nend\n-- luacheck: globals remove\nfunction remove(w, wh)\nlocal o = std.object(w)\nif not w then\nstd.err(\"Wrong argument to remove(): \"..std.tostr(w), 2)\nend\nwh = wh and std.object(wh)\nreturn o:remove(wh)\nend\n-- luacheck: globals purge\nfunction purge(w)\nlocal o = std.object(w)\nif not w then\nstd.err(\"Wrong argument to purge(): \"..std.tostr(w), 2)\nend\nreturn o:purge()\nend\nlocal function __place(w, wh, remove)\nlocal o = std.object(w)\nif not o then\nstd.err(\"Wrong argument to place(): \"..std.tostr(w), 3)\nend\nif remove then\no:remove() -- remove object from everywhere\nend\nwh = wh or std.here()\nif type(wh) ~= 'table' then\nwh = std.object(wh)\nend\nif o:type 'player' then\nif not std.is_obj(wh) then\nstd.err(\"Wrong 2-nd argument to place(): \"..std.tostr(wh), 3)\nend\no:walk(wh, false, false)\nreturn o\nend\nif std.is_obj(wh) then\nwh.obj:add(o)\nelseif std.is_obj(wh, 'list') then\nwh:add(o)\nelse\nstd.err(\"Wrong 2-nd argument to place(): \"..std.tostr(wh), 3)\nend\nreturn o\nend\n-- luacheck: globals replace\nfunction replace(w, ww, wh)\nlocal o = std.object(w)\nif not o then\nstd.err(\"Wrong argument to replace(): \"..std.tostr(w), 2)\nend\nlocal oo = std.object(ww)\nif not oo then\nstd.err(\"Wrong argument to replace(): \"..std.tostr(ww), 2)\nend\nif not wh then -- replace all\nlocal l = {}\no:where(l)\nfor _, v in std.ipairs(l) do\nv.obj:replace(o, oo)\nif std.is_obj(v, 'room') then\nv.way:replace(o, oo)\nend\nend\nreturn oo\nend\nif type(wh) ~= 'table' then\nwh = std.object(wh)\nend\nif std.is_obj(wh) then\nlocal _, l = wh:lookup(o)\nif l then\nl:replace(o, oo)\nreturn oo\nend\nelseif std.is_obj(wh, 'list') then\nwh:replace(o, oo)\nreturn oo\nelse\nstd.err(\"Wrong 3-rd argument to replace(): \"..std.tostr(wh), 3)\nend\nend\n-- luacheck: globals place\nfunction place(w, wh)\nreturn __place(w, wh, true)\nend\n-- luacheck: globals put\nfunction put(w, wh)\nreturn __place(w, wh, false)\nend\n-- luacheck: globals take\nfunction take(w)\nlocal o = std.object(w)\nif o then\no:actions('take', 1 + o:actions 'take')\nend\nreturn place(w, std.me():inventory())\nend\n-- luacheck: globals drop\nfunction drop(w, wh)\nlocal o = std.object(w)\nif o then\no:actions('drop', 1 + o:actions 'drop')\nend\nreturn place(w, wh)\nend\n-- luacheck: globals path\npath = std.class({\n__path_type = true;\nnew = function(_, t)\nif type(t) ~= 'table' then\nstd.err(\"Wrong path argument. Use {} as path argument.\", 2)\nend\nlocal n, s, w = t[1], t[2], t[3]\nif not w then\ns, w = n, s\nn = nil\nend\nlocal new = {\nbefore = s;\nwalk = w;\n}\nfor k, v in std.pairs(t) do\nif type(k) == 'string' then\nnew[k] = v\nend\nend\nnew.nam = n or new.nam\nreturn std.room(new)\nend;\ndisp = function(s)\nlocal w = s.walk\nif type(w) == 'function' then\nw = w()\nend\nif disabled(w) or closed(w) then\nreturn false\nend\nif s.after ~= nil and visited(w) then\nreturn std.call(s, 'after')\nend\nreturn std.call(s, 'before')\nend;\nonwalk = function(s, _)\nlocal w = s.walk\nif type(w) == 'function' then\nw = w()\nend\nif not disabled(w) and not closed(w) then\nwalk(w)\nend\nreturn false\nend;\n}, std.room)\n-- luacheck: globals time\nfunction time(...)\nreturn std.ref 'game':time(...)\nend\nlocal xact = std.obj {\nnam = '@';\n{\nmethods = {}\n};\nact = function(s, w, ...)\nif type(s.methods[w]) ~= 'function' then\nstd.err (\"Wrong method to xact\", 2)\nend\nreturn s.methods[w](...)\nend\n}\nstd.rawset(_G, 'xact', xact.methods)\nstd.mod_init(function()\ndeclare {\ngame = std.ref 'game',\npl = std.ref 'player',\n}\nend)\n","stead.lua":"-- STEAD3 API\n-- luacheck: globals iface init start stead\n-- luacheck: read globals DEBUG doencfile instead_readdir instead_random table_get_maxn instead_srandom\nstead = {\nspace_delim = ' ',\nscene_delim = '^^',\ndelim = '|',\ncall_top = 0,\ncall_ctx = { txt = nil, self = nil },\nobjects = {};\ntags = {};\nnext_dynamic = -1;\nmax_dynamic = 32767;\ntables = {};\nfunctions = {};\nmodules = {};\nincludes = {};\ntostr = tostring;\ntonum = tonumber;\ntype = type;\nsetmt = setmetatable;\ngetmt = getmetatable;\ntable = table;\nmath = math;\nnewproxy = newproxy;\npairs = pairs;\nipairs = ipairs;\nrawset = rawset;\nrawget = rawget;\nrawequal = rawequal;\npcall = pcall;\nio = io;\nos = os;\nreaddir = instead_readdir,\nstring = string;\nnext = next;\nloadfile = loadfile;\ndofile = dofile;\ndoencfile = doencfile;\ngetinfo = debug.getinfo;\n__mod_hooks = {};\nfiles = {};\nbusy = function() end;\ndebug_xref = true;\ndebug_save = false;\nrandom = instead_random;\nrandomseed = instead_srandom;\n}\nlocal std = stead\nstd.strip_call = true\nlocal error = error\nfunction std.err(msg, lev)\nif std.noerror then\nstd.dprint(msg)\nelse\nerror(msg, lev)\nend\nend\nfunction std.dprint(...)\nlocal a = { ... }\nfor i = 1, #a do\nif i ~= 1 then\nstd.io.stderr:write(' ')\nend\nstd.io.stderr:write(std.tostr(a[i]))\nend\nstd.io.stderr:write('\\n')\nstd.io.stderr:flush()\nend\nstd.rnd = function(...)\nif std.random then\nreturn std.random(...)\nend\nreturn std.math.random(...);\nend\nstd.rnd_seed = function(...)\nstd.math.randomseed(...)\nif std.randomseed then\nreturn std.randomseed(...)\nend\nend\nfunction stead:abort()\nself.abort_cmd = true\nend\nfunction stead.savepath()\nreturn \"./\"\nend\nlocal table = std.table\nlocal pairs = std.pairs\nlocal ipairs = std.ipairs\nlocal string = std.string\nlocal rawset = std.rawset\nlocal rawget = std.rawget\nlocal type = std.type\nlocal io = std.io;\nif _VERSION == \"Lua 5.1\" then\nstd.eval = loadstring\nstd.unpack = unpack\nstd.proxy = function(o)\nlocal oo = std.newproxy(true)\nlocal t = std.getmt(oo)\nt.__index = o\nt.__newindex = o\nt.__gc = function(_)\no:__gc()\nend\nt.__tostring = function(_)\nreturn o:__tostring()\nend\no.__proxy_type = true\nreturn oo\nend\nelse\nstd.proxy = function(o)\no.__proxy_type = true\nreturn o\nend\nstd.eval = load\nstd.unpack = table.unpack\ntable.maxn = table_get_maxn\nstring.gfind = string.gmatch\n-- luacheck: push ignore math\nmath.mod = math.fmod\nmath.log10 = function(a)\nreturn std.math.log(a, 10)\nend\nend\nmath.pow = function(num, n)\nreturn num ^ n\nend\nmath.round = function(num, n)\nlocal m = 10 ^ (n or 0)\nreturn std.math.floor(num * m + 0.5) / m\nend\n-- luacheck: pop\nlocal function __mod_callback_reg(f, hook, prio)\nif type(f) ~= 'function' then\nstd.err (\"Wrong parameter to mod_\"..hook..\".\", 3);\nend\nif prio and type(prio) ~= 'number' then\nstd.err (\"Wrong prio parameter to mod_\"..hook..\".\", 3);\nend\nif not std.__mod_hooks[hook] then\nstd.__mod_hooks[hook] = {}\nend\nlocal i = { fn = f, prio = prio, unload = std.__in_include }\ntable.insert(std.__mod_hooks[hook], i);\nstd.sort(std.__mod_hooks[hook], function (a, b)\na = a.prio or 0\nb = b.prio or 0\nif a == b then\nreturn nil\nend\nreturn a < b\nend)\n--f();\nend\nfunction std.mod_unload()\nlocal new = {}\nfor k, v in pairs(std.__mod_hooks) do\nlocal list = {}\nfor _, vv in ipairs(v) do\nif not vv.unload then\ntable.insert(list, vv)\nend\nend\nnew[k] = list\nend\nstd.__mod_hooks = new\nend\nfunction std.mod_call(hook, ...)\nif not std.__mod_hooks[hook] then\nreturn\nend\nfor _, v in ipairs(std.__mod_hooks[hook]) do\nlocal a, b = v.fn(...)\nif a ~= nil or b ~= nil then\nreturn a, b\nend\nend\nend\nfunction std.mod_call_rev(hook, ...)\nif not std.__mod_hooks[hook] then\nreturn\nend\nfor i = #std.__mod_hooks[hook], 1, -1 do\nlocal v = std.__mod_hooks[hook][i]\nlocal a, b = v.fn(...)\nif a ~= nil or b ~= nil then\nreturn a, b\nend\nend\nend\nfunction std.mod_init(f, ...)\n__mod_callback_reg(f, 'init', ...)\nif std.initialized then -- require from game\nf(...)\nend\nend\nfunction std.mod_done(f, ...)\n__mod_callback_reg(f, 'done', ...)\nend\nfunction std.mod_start(f, ...)\n__mod_callback_reg(f, 'start', ...)\nend\nfunction std.mod_cmd(f, ...)\n__mod_callback_reg(f, 'cmd', ...)\nend\nfunction std.mod_step(f, ...)\n__mod_callback_reg(f, 'step', ...)\nend\nfunction std.mod_save(f, ...)\n__mod_callback_reg(f, 'save', ...)\nend\nfunction std.hook(o, f)\nlocal ff\nif type(o) ~= 'function' then\nff = function()\nreturn o\nend\nelse\nff = o\nend\nreturn function(...)\nreturn f(ff, ...)\nend\nend\nlocal substs\nlocal function xref_prep(str)\nlocal oo, self\nlocal a = {}\nlocal s = str\nlocal i = s:find('\\001', 1, true)\nif not i then\nreturn str\nend\noo = std.strip(s:sub(1, i - 1))\ns = s:sub(i + 1)\nif oo:find('@', 1, true) == 1 or oo:find('$', 1, true) then -- call '@' obj (aka xact) or '$' aka subst\nlocal o = std.split(oo)[1]\nlocal ii = oo:find(\"[ \\t]\")\nif ii then\na = std.strip(oo:sub(ii))\na = std.cmd_parse(a)\nend\nself = std.ref(o)\nelse\nif oo:find(\"^# [0-9-]+\") then\nself = std.ref(std.tonum(oo:sub(3)))\nelseif std.is_tag(oo) then -- #tag?\nself = std.here():lookup(oo)\nelse\nself = std.ref(oo)\nend\nend\nif not std.is_obj(self) then\nif std.debug_xref then\nstd.err(\"Wrong object in xref: \"..std.tostr(oo), 2)\nelse\nstd.dprint(\"Wrong xref: \"..std.tostr(oo))\nreturn s\nend\nend\nif type(self.nam) == 'string' and self.nam:find('$', 1, true) == 1 then -- subst\ntable.insert(a, s)\nsubsts = true\nlocal r, v = std.method(self, 'act', std.unpack(a))\nif not v then\nreturn s\nend\nreturn std.tostr(r)\nend\nreturn iface:xref(s, self, std.unpack(a));\nend\nlocal fmt_refs\nlocal function fmt_prep(str)\nlocal s = str:gsub(\"^{\", \"\"):gsub(\"}$\", \"\")\ns = s:gsub('\\\\?['..std.delim..']', { [std.delim] = '\\001' });\nlocal l = s:find('\\001', 1, true)\nif l == 1 then\nreturn str\nend\nif not l then\ns = s .. '\\001'\nend\nl = s:find('\\001', 1, true)\ntable.insert(fmt_refs, s:sub(1, l - 1))\nlocal n = string.format(\"%d%s\", #fmt_refs, std.delim)\nreturn \"{\"..n..s:sub(l + 1)..\"}\"\nend\nlocal function fmt_post(str)\nlocal s = str:gsub(\"^{\", \"\"):gsub(\"}$\", \"\"):gsub('\\\\?['..std.delim..']',\n{ [std.delim] = '\\001' } );\nlocal l = s:find('\\001')\nif not l or l == 1 then\nreturn str\nend\nlocal n = std.tonum(s:sub(1, l - 1)) or 0\nif not fmt_refs[n] then\nreturn str\nend\ns = fmt_refs[n]..s:sub(l)\nreturn xref_prep(std.unesc(s))\nend\nfunction std.for_each_xref_outer(s, fn)\nlocal orig = s\ns = string.gsub(s, '\\\\?[\\\\{}]',\n{ ['{'] = '\\001', ['}'] = '\\002', [ '\\\\{' ] = '\\\\{', [ '\\\\}' ] = '\\\\}' });\nlocal start\nwhile true do\nstart = s:find('\\001')\nif not start then break end\nlocal idx = 1\nlocal n = start\nwhile idx > 0 do\nn = s:find('[\\001\\002]', n + 1)\nif not n then\nbreak\nend\nif s:sub(n, n) == '\\001' then\nidx = idx + 1\nelse\nidx = idx - 1\nend\nend\nif idx == 0 then\nlocal new = fn(s:sub(start, n):gsub('[\\001\\002]', {['\\001'] = '{', ['\\002'] = '}'}))\nif start == 1 then\ns = new..s:sub(n + 1)\nelse\ns = s:sub(1, start - 1)..new..s:sub(n + 1)\nend\nelse\nstd.err(\"Unpaired '{' in:\"..std.tostr(orig), 2)\nbreak\nend\nend\ns = s:gsub('[\\001\\002]', { ['\\001'] = '{', ['\\002'] = '}' });\nreturn s\nend\nfunction std.for_each_xref(s, fn)\ns = string.gsub(s, '\\\\?[\\\\{}]',\n{ ['{'] = '\\001', ['}'] = '\\002', [ '\\\\{' ] = '\\\\{', [ '\\\\}' ] = '\\\\}' });\nlocal function prep(str)\nstr = str:gsub(\"[\\001\\002]\", \"\")\nstr = fn('{'..str..'}')\nreturn str\nend\ns = string.gsub(s, '(\\001[^\\001\\002]+\\002)', prep)\ns = s:gsub('[\\001\\002]', { ['\\001'] = '{', ['\\002'] = '}' });\nreturn s\nend\nstd.fmt = function(str, fmt, state)\nif type(str) ~= 'string' then\nreturn\nend\nlocal s = str\ns = string.gsub(s, '[\\t \\n]+', std.space_delim);\ns = string.gsub(s, '\\\\?[\\\\^]', { ['^'] = '\\n', ['\\\\^'] = '^'} ):gsub(\"\\n[ \\t]+\", \"\\n\")\nlocal first = true\nwhile true do\nfmt_refs = {}\nsubsts = false\ns = std.for_each_xref(s, fmt_prep) -- rename all {}\nif first and type(fmt) == 'function' then\ns = fmt(s, state)\nend\ns = std.for_each_xref(s, fmt_post) -- rename and xref\nif not substs then\nbreak\nend\nfirst = false\nend\ns = s:gsub('\\\\?'..'[{}]', { ['\\\\{'] = '{', ['\\\\}'] = '}' })\nif state then\ns = s:gsub('\\\\?'..std.delim, { ['\\\\'..std.delim] = std.delim })\nend\nreturn s\nend\nlocal lua_keywords = {\n[\"and\"] = true,\n[\"break\"] = true,\n[\"do\"] = true,\n[\"else\"] = true,\n[\"elseif\"] = true,\n[\"end\"] = true,\n[\"false\"] = true,\n[\"for\"] = true,\n[\"function\"] = true,\n[\"goto\"] = true,\n[\"if\"] = true,\n[\"in\"] = true,\n[\"local\"] = true,\n[\"nil\"] = true,\n[\"not\"] = true,\n[\"or\"] = true,\n[\"repeat\"] = true,\n[\"return\"] = true,\n[\"then\"] = true,\n[\"true\"] = true,\n[\"until\"] = true,\n[\"while\"] = true,\n}\nstd.setmt(stead, {\n__call = function(_, k)\nreturn std.ref(k)\nend;\n})\nfunction std.is_system(v)\nif not std.is_obj(v) then\nreturn false\nend\nlocal n = v.nam\nif type(n) == 'string' then\nif n:byte(1) == 0x40 or n:byte(1) == 0x24 then\nreturn true\nend\nend\nreturn false\nend\nfunction std.is_obj(v, t)\nif type(v) ~= 'table' then\nreturn false\nend\nreturn v['__'..(t or 'obj')..'_type']\nend\nfunction std.class(self, inh)\n--self.__parent = function(s)\n--return inh\n--end;\nself.nam = '*class*';\nself.__call = function(v, n, ...)\nif std.is_obj(v) and type(n) == 'string' then\n-- variable access\nreturn function(val)\nif std.game then\nrawset(v.__var, n, true)\nrawset(v.__ro, n, nil)\nreturn rawset(v, n, val or false)\nend\nreturn rawset(v.__ro, n, val or false)\nend\nend\nn = v:new(n, ...)\nstd.setmt(n, v)\nreturn n\nend;\nself.__tostring = function(s)\nif not std.is_obj(s) then\nlocal os = self.__tostring\nself.__tostring = nil\nlocal t = std.tostr(s)\nself.__tostring = os\nreturn t\nend\nreturn std.dispof(s)\nend;\nself.__pow = function(s, b)\nif type(b) == 'string' or type(b) == 'number' then\nif std.is_tag(b) then\nreturn std.rawequal(s.tag, b)\nelse\nreturn std.rawequal(s.nam, b)\nend\nend\nreturn std.rawequal(s, b)\nend;\nself.__dirty = function(s, v)\nlocal o = rawget(s, '__dirty_flag')\nif v ~= nil then\nif std.game then\nrawset(s, '__dirty_flag', v)\nend\nreturn s\nend\nreturn o\nend;\nself.__index = function(t, k)\nlocal ro = type(rawget(t, '__ro')) == 'table' and t.__ro\nlocal v\nif ro then\nv = rawget(ro, k)\nend\nif v == nil then\nreturn self[k]\nend\nif ro and std.game and type(v) == 'table' then\n-- make rw if simple table\nif type(v.__dirty) ~= 'function' then\nt.__var[k] = true\nrawset(t, k, v)\nro[k] = nil\nend\nend\nreturn v\nend;\nself.__newindex = function(t, k, v)\nlocal ro = std.is_obj(t) and t.__ro\nif ro and not std.game then\nrawset(ro, k, v)\nreturn\nend\nt:__dirty(true)\nif ro then\nif (type(v) == 'function' and not std.functions[v]) then\nstd.err(\"Wrong variable operation: \"..std.tostr(k).. \" at \"..std.tostr(t), 2)\nend\nif std.nostrict or (type(k) == 'string' and k:find('^__')) or t.__var[k] or ro[k] ~= nil then\nt.__var[k] = true\nelse\nstd.err(\"Set unitialized variable: \"..std.tostr(k)..\" at \"..std.tostr(t), 2)\nend\nro[k] = nil\nend\nif std.is_obj(v, 'list') and std.is_obj(t) then\nv:attach(t)\nend\nrawset(t, k, v)\nend\nstd.setmt(self, inh or { __call = self.__call })\nreturn self\nend\nfunction std.is_tag(n)\nreturn type(n) == 'string' and n:byte(1) == 0x23\nend\nfunction std.sort(t, fn)\nlocal prio = {}\nlocal v\nfor i = 1, #t do\nv = t[i]\nprio[i] = { v = v, i = i }\nend\ntable.sort(prio, function(a, b)\nlocal r = fn(a.v, b.v)\nif type(r) == 'boolean' then\nreturn r\nend\nreturn a.i < b.i\nend)\nfor i = 1, #prio do\nt[i] = prio[i].v\nend\nend\nstd.list = std.class {\n__list_type = true;\nnew = function(_, v)\nif type(v) ~= 'table' then\nstd.err (\"Wrong argument to std.list:\"..std.tostr(v), 2)\nend\nif std.is_obj(v, 'list') then -- already list\nreturn v\nend\nv.__list = {} -- where is attached\n-- std.setmt(v, s)\nreturn v\nend;\n__ini = function(s, o)\nfor i = 1, #s do\nlocal k = s[i]\ns[i] = std.ref(k)\nif not std.is_obj(s[i]) then\nif not o then\nstd.err(\"Wrong item in list: \"..std.tostr(k), 2)\nelse\nstd.err(\"Wrong item in list: \"..std.tostr(k)..\" in \"..std.dispof(o), 2)\nend\nend\ns:__attach(s[i])\nend\nif o then\ns:attach(o)\nend\ns:sort()\nend;\nsort = function(s)\nstd.sort(s, function(a, b)\nlocal p1 = std.tonum(a.pri) or 0\nlocal p2 = std.tonum(b.pri) or 0\nif p1 == p2 then return nil end\nreturn p1 < p2\nend)\nend;\ndisplay = function(s)\nlocal r\nfor i = 1, #s do\nif r then\nr = r .. std.space_delim\nend\nlocal o = s[i]\nif o:visible() then\nlocal disp = o:display()\nlocal d = o:__xref(disp)\nif type(d) == 'string' then\nr = (r or '').. d\nend\nif not o:closed() then\nd = o.obj:display()\nif type(d) == 'string' then\nr = (r and (r .. std.space_delim) or '') .. d\nend\nend\nend\nend\nreturn r\nend;\ndisable = function(s)\nfor i = 1, #s do\ns[i]:disable()\nend\nend;\nenable = function(s)\nfor i = 1, #s do\ns[i]:enable()\nend\nend;\nclose = function(s)\nfor i = 1, #s do\ns[i]:close()\nend\nend;\nopen = function(s)\nfor i = 1, #s do\ns[i]:open()\nend\nend;\nattach = function(s, o) -- attach to object\ns:detach(o)\ntable.insert(s.__list, o)\nend;\ndetach = function(s, o) -- detach from object\nfor i = 1, #s.__list do\nif s.__list[i] == o then\ntable.remove(s.__list, i)\nbreak\nend\nend\nend;\n__attach = function(s, o) -- attach object to list\ns:__detach(o)\ntable.insert(o.__list, s)\nend;\n__detach = function(s, o) -- detach object from list\nfor i = 1, #o.__list do\nif o.__list[i] == s then\ntable.remove(o.__list, i)\nbreak\nend\nend\nend;\nadd = function(s, n, pos)\nlocal o = s:lookup(n)\nif o then\nreturn o -- already here\nend\nif not pos then\no = std.ref(n)\nif not o then\nstd.err(\"Wrong argument to list:add(): \"..std.tostr(n), 2)\nend\ns:__dirty(true)\ns:__attach(o)\ntable.insert(s, o)\ns:sort()\nreturn o\nend\nif type(pos) ~= 'number' then\nstd.err(\"Wrong parameter to list.add:\"..std.tostr(pos), 2)\nend\nif pos > #s then\npos = #s\nelseif pos < 0 then\npos = #s + pos + 1\nend\nif pos <= 0 then\npos = 1\nend\no = std.ref(n)\ns:__dirty(true)\ns:__attach(o)\nif pos then\ntable.insert(s, pos, o)\nelse\ntable.insert(s, o)\nend\ns:sort()\nreturn o\nend;\nfor_each = function(s, fn, ...)\nif type(fn) ~= 'function' then\nstd.err(\"Wrong parameter to list:for_each: \"..std.tostr(fn), 2)\nend\nfor i = 1, #s do\nlocal r, v = fn(s[i], ...)\nif r ~= nil or v ~= nil then\nreturn r, v\nend\nend\nend;\nlookup = function(s, n)\nlocal o, tag\nif std.is_tag(n) then\ntag = n\nelse\no = std.ref(n)\nend\nfor i = 1, #s do\nif s[i] == o or (tag and s[i].tag == tag) then\nreturn s[i], i\nend\nend\nend;\nsrch = function(s, n)\nlocal o, i = s:lookup(n)\nif not o or not o:visible() then\nreturn\nend\nreturn o, i\nend;\nempty = function(s)\nreturn (#s == 0)\nend;\ncat = function(s, from, pos)\nif not std.is_obj(from, 'list') then\nstd.err(\"Wrong argument to list:cat(): \"..std.tostr(from), 2)\nend\nif not pos then pos = #s + 1 end\nfor _, v in ipairs(from) do\ns:add(v, pos)\npos = pos + 1\nend\nreturn s\nend;\nzap = function(s) -- delete all objects\nlocal l = {}\nfor i = 1, #s do\ntable.insert(l, s[i])\nend\nfor i = 1, #l do\ns:del(l[i])\nend\nreturn s\nend;\ndel = function(s, n)\nlocal o, i = s:lookup(n)\nif i then\ns:__dirty(true)\ns:__detach(o)\ntable.remove(s, i)\ns:sort()\nreturn o, i\nend\nend;\nreplace = function(s, n, w)\nlocal o, i = s:del(n)\nif o then\nreturn s:add(w, i)\nend\nend;\n__dump = function(s, recurse)\nlocal rc\nfor i = 1, #s do\nlocal v = s[i]\nif std.is_obj(v) and v:visible() then\nlocal vv, n\nif type(v.nam) == 'number' then\nn = '# '..std.tostr(v.nam)\nelse\nn = v.nam\nend\nlocal disp = std.dispof(v)\nif disp then\nif rc then\nrc = rc .. std.delim\nelse\nrc = ''\nend\nvv = '{'..std.esc(n)..std.delim..std.esc(disp)..'}'\nrc = rc .. vv\nend\nif recurse and not v:closed() then\nvv = v:__dump(recurse)\nif vv then\nif rc then rc = rc .. std.delim else rc = '' end\nrc = rc .. vv\nend\nend\nend\nend\nreturn rc\nend;\n__save = function(s, fp, n)\nif not s:__dirty() then\nreturn\nend\nfp:write(string.format(\"%s = std.list { \", n))\nfor i = 1, #s do\nlocal vv = std.deref(s[i])\nif not vv then\nstd.err (\"Can not do deref on: \"..std.tostr(s[i]), 2)\nend\nif i ~= 1 then\nfp:write(string.format(\", \"))\nend\nif type(vv) == 'number' then\nfp:write(string.format(\"%d\", vv))\nelse\nfp:write(string.format(\"%q\", vv))\nend\nend\nfp:write(\" }:__dirty(true)\\n\")\nend;\n}\nstd.save_var = function(vv, fp, n)\nif type(vv) == 'boolean' or type(vv) == 'number' then\nfp:write(string.format(\"%s = \", n))\nfp:write(std.tostr(vv)..'\\n')\nelseif type(vv) == 'string' then\nfp:write(string.format(\"%s = \", n))\nfp:write(string.format(\"%q\\n\", vv))\nelseif type(vv) == 'function' then\nif std.functions[vv] and std.functions[vv] ~= n then\nlocal k = std.functions[vv]\nfp:write(string.format(\"%s = %s\\n\", n, k))\nelse\nstd.err(\"Can not save variable (function): \"..n, 2)\nend\nelseif type(vv) == 'table' then\nif std.tables[vv] and std.tables[vv] ~= n then\nlocal k = std.tables[vv]\nfp:write(string.format(\"%s = %s\\n\", n, k))\nelseif std.is_obj(vv) then\nlocal d = std.deref(vv)\nif not d then\nstd.err(\"Can not deref object:\"..std.tostr(vv), 2)\nend\nfp:write(string.format(\"%s = \", n))\nif type(d) == 'string' then\nfp:write(string.format(\"std %q\\n\", d))\nelse\nfp:write(string.format(\"std(%d)\\n\", d))\nend\nelseif type(vv.__save) == 'function' then\nvv:__save(fp, n)\nelse\nfp:write(string.format(\"%s = %s\\n\", n,  std.dump(vv, true)))\n--std.save_table(vv, fp, n)\nend\nelseif vv == nil then\nfp:write(string.format(\"%s = nil\\n\", n))\nelseif type(vv) == 'userdata' and type(vv.__save) == 'function' then\nvv:__save(fp, n)\nelse\nstd.err(\"Can not save var: \"..n, 2)\nend\nend\nstd.save_members = function(vv, fp, n)\nlocal l\nfor k, v in pairs(vv) do\nif type(k) == 'number' then\nl = string.format(\"%s%s\", n, std.varname(k))\nstd.save_var(v, fp, l)\nelseif type(k) == 'string' then\nl = string.format(\"%s%s\", n, std.varname(k))\nstd.save_var(v, fp, l)\nend\nend\nend\nstd.save_table = function(vv, fp, n)\nfp:write(string.format(\"%s = {}\\n\", n))\nstd.save_members(vv, fp, n)\nend\nfunction std:reset(fn) -- reset state\nlocal reset\nif std.ref 'game'.__started or fn then\nself:done()\nself:init()\nreset = true\nend\nif fn ~= 'main3.lua' then\nstd.startfile = fn -- another start file\nend\nif reset then\nstd.dofile(fn or 'main3.lua')\nend\nend\nfunction std:load(fname) -- load save\nself:reset()\nstd.ref 'game':__ini()\nlocal f, err = std.loadfile(fname) -- load all diffs\nif not f then\nstd.err(err, 2)\nend\nlocal strict = std.nostrict; std.nostrict = true;\nif DEBUG then\nstd.noerror = true\nlocal st, r = std.pcall(f)\nif not st then\nstd.dprint(r)\nend\nstd.noerror = false\nelse\nf();\nend\nstd.nostrict = strict\nstd.ref 'game':__ini(true)\nstd.ref 'game':__start(true)\nreturn self.game:lastdisp()\nend\nlocal function in_section(name, fn)\nname = \"__in_\"..name\nlocal old = std[name]\nstd[name] = true\nlocal r, v = fn()\nstd[name] = old or false\nreturn r, v\nend\nfunction std.gamefile(fn, reset) -- load game file\nif type(fn) ~= 'string' then\nstd.err(\"Wrong paramter to stead:file: \"..std.tostr(fn), 2)\nend\nif not fn:find(\"%.lua$\") then\nfn = fn .. '.lua'\nend\nif reset then\nstd:reset(fn)\nstd.ref 'game':__ini()\nlocal r, v = std.ref 'game':__start()\nif type(r) == 'string' and std.cctx() then\nstd.pr(r)\nend\nreturn r, v\nend\nstd.game = nil\nin_section ('gamefile', function() std.dofile(fn) end)\nstd.ref 'game':__ini()\ntable.insert(std.files, fn) -- remember it\nend\n-- luacheck: no self\nfunction std:save(fp)\nlocal close\nif type(fp) == 'string' then\nfp = io.open(fp, \"wb\");\nif not fp then\nreturn nil, false -- can create file\nend\nclose = true\nend\nlocal n\nif std.type(std.savename) == 'function' then\nn = std.savename()\nend\nif std.type(n) == 'string' then\nfp:write(\"-- $Name: \"..n:gsub(\"\\n\",\"\\\\n\")..\"$\\n\");\nend\nfp:write(\"local std = stead\\n\");\n-- reset\nif std.startfile then\nfp:write(string.format(\"std:reset(%q)\\n\", std.startfile))\nfp:write(string.format(\"std 'game':ini()\\n\"))\nend\n-- files\nfor i = 1, #std.files do\nfp:write(string.format(\"std.gamefile(%q)\\n\", std.files[i]))\nend\nstd.busy(true)\nstd.for_each_obj(function(v)\nif v.__dynamic then\nstd.busy(true)\nv:save(fp, string.format(\"std(%s)\", std.deref_str(v)))\nend\nend)\nstd.mod_call('save', fp)\nstd.for_each_obj(function(v)\nif not v.__dynamic then\nstd.busy(true)\nv:save(fp, string.format(\"std(%s)\", std.deref_str(v)))\nend\nend)\nif close then\nfp:flush();\nfp:close();\nend\nstd.busy(false)\nreturn std.game:lastdisp() -- same scene\nend\nlocal rnd_seed = 1980 + 1978\nfunction std:init()\nstd.rawset(_G, 'iface', std.ref '@iface') -- force iface override\nstd.world { nam = 'game', player = 'player', codepage = 'UTF-8', dsc = [[STEAD3, 2018 by Peter Kosyh^https://instead-hub.github.io^^]] };\nstd.room { nam = 'main' }\nstd.player { nam = 'player', room = 'main' }\nrnd_seed = (std.os.time(stead.os.date(\"*t\")) + rnd_seed)\nstd.rnd_seed(rnd_seed)\nstd.mod_call('init') -- init modules\nstd.initialized = true\nend\nfunction std:done()\nstd.mod_call_rev('done')\nstd.mod_unload() -- unload hooks from includes\nlocal objects = {}\nstd.for_each_obj(function(v)\nlocal k = std.deref(v)\nif std.is_system(v) then\nobjects[k] = v\nelse\nprint(\"Deleting \"..k)\nend\nend)\nstd.objects = objects\nstd.tags = {}\nstd.next_dynamic = -1\nstd.files = {}\nstd.startfile = false\n--std.modules = {}\nstd.includes = {}\nstd.initialized = false\nstd.game = nil\nstd.rawset(_G, 'init', nil)\nstd.rawset(_G, 'start', nil)\nend\n-- luacheck: self\nfunction std.for_all(fn, ...)\nif type(fn) ~= 'function' then\nstd.err(\"Wrong 1-st argument to for_all(): \"..std.tostr(fn), 2)\nend\nlocal a = {...}\nfor i = 1, #a do\nfn(a[i])\nend\nend\nfunction std.for_each_obj(fn, ...)\nlocal oo = std.objects\nfor _, v in pairs(oo) do\nif std.is_obj(v) then\nlocal a, b = fn(v, ...)\nif a ~= nil and b ~= nil then\nreturn a, b\nend\nend\nend\nend\nfunction std.dirty(o)\nif type(o) ~= 'table' or type(o.__dirty) ~= 'function' then\nreturn false\nend\nreturn o:__dirty()\nend\nfunction std.deref_str(o)\nlocal k = std.deref(o)\nif type(k) == 'number' then\nreturn std.tostr(k)\nelseif type(k) == 'string' then\nreturn std.string.format(\"%q\", k)\nend\nreturn\nend\nfunction std.varname(k)\nif type(k) == 'number' then\nreturn string.format(\"[%d]\", k)\nelseif type(k) == 'string' then\nif not lua_keywords[k] then\nreturn string.format(\".%s\", k)\nelse\nreturn string.format(\"[%q]\", k)\nend\nend\nend\nlocal function next_dynamic(n)\nif n then\nstd.next_dynamic = n\nend\nstd.next_dynamic = std.next_dynamic - 1\nif std.next_dynamic < -std.max_dynamic then\nstd.next_dynamic = - 1\nend\nreturn std.next_dynamic\nend\nlocal function dyn_name()\nlocal oo = std.objects\nif not oo[std.next_dynamic] then\nlocal n = std.next_dynamic\nnext_dynamic()\nreturn n\nend\nlocal on = std.next_dynamic\nlocal n = next_dynamic()\nwhile oo[n] and n ~= on do\nn = n - 1\nif n < -std.max_dynamic then\nn = -1\nend\nend\nif oo[n] then\nstd.err(\"No free ids for dynamic objects\", 2)\nend\nnext_dynamic(n)\nreturn n\nend\nlocal function tag_name(t)\nlocal oo = std.objects\nlocal tt = std.tags[t] or {}\nlocal n = t:sub(2) .. '#'..std.tonum(#tt)\nif oo[n] then return #oo + 1 end -- collision\ntable.insert(tt, n)\nstd.tags[t] = tt\nreturn n\nend\nstd.obj = std.class {\n__obj_type = true;\ntype = function(self, t)\nreturn std.is_obj(self, t)\nend;\nwith = function(self, ...)\nlocal a = {...}\nfor i = 1, #a do\nif type(a[i]) == 'table' then\nfor k = 1, #a[i] do\ntable.insert(self.obj, a[i][k])\nend\nelse\ntable.insert(self.obj, a[i])\nend\nend\nreturn self\nend;\nnew = function(self, v)\nif std.game and not std.__in_new and not std.__in_gamefile then\nstd.err (\"Use std.new() to create dynamic objects:\"..std.tostr(v), 2)\nend\nlocal oo = std.objects\nif type(v) ~= 'table' then\nstd.err (\"Wrong argument to std.obj:\"..std.tostr(v), 2)\nend\nif std.is_tag(v.nam) then\nrawset(v, 'tag', v.nam)\nrawset(v, 'nam', nil)\nend\nif v.nam == nil then\nif std.__in_new then\nrawset(v, 'nam', dyn_name())\nelseif std.is_tag(v.tag) then\nrawset(v, 'nam', tag_name(v.tag))\nelse\nrawset(v, 'nam', #oo + 1)\nend\nrawset(v, '__autoname', true)\nelseif type(v.nam) ~= 'string' and type(v.nam) ~= 'number' then\nstd.err (\"Wrong .nam in object.\", 2)\n--elseif type(v.nam) == 'string' and v.nam:find('#[0-9]+$') then\n--std.err (\"You can not use #<number> in object name: \"..v.nam, 2)\nend\nif oo[v.nam] and not std.is_system(oo[v.nam]) then\nif v.nam ~= 'main' and v.nam ~= 'player' and v.nam ~= 'game' then\nstd.err (\"Duplicated object: \"..v.nam, 2)\nend\nend\nlocal ro = {}\nlocal vars = {}\nlocal raw = {}\nfor i = 1, #v do\nif type(v[i]) ~= 'table' then\nstd.err(\"Wrong declaration: \"..std.tostr(v[i]), 2)\nend\nlocal var = (v[i].__var_type == true) -- raw or var mode\nfor key, val in pairs(v[i]) do\nif type(key) ~= 'string' then\nstd.err(\"Wrong var name: \"..std.tostr(key), 2)\nend\nraw[key] = not var\nrawset(v, key, val)\nend\nend\nfor _ = 1, #v do\ntable.remove(v, 1)\nend\nif not v.obj then\nrawset(v, 'obj', {})\nend\nif type(v.obj) ~= 'table' then\nstd.err (\"Wrong .obj attr in object:\" .. v.nam, 2)\nend\nv.obj = std.list(v.obj)\n--v.obj:attach(v)\nfor key, val in pairs(v) do\nif not std.nostrict_new and type(self[key]) == 'function' and type(val) ~= 'function' then\nstd.err(\"Overwrited object method: '\"..std.tostr(key).. \"' in: \"..std.tostr(v.nam), 2)\nend\nif not raw[key] then\nro[key] = val\nrawset(v, key, nil)\nend\nend\nrawset(v, '__ro', ro)\nrawset(v, '__var', vars)\nrawset(v, '__list', {}) -- in what list(s)\noo[ro.nam] = v\n-- std.setmt(v, self)\nif std.__in_init then\ntable.insert(std.__in_init, v)\nend\nreturn v\nend;\nactions = function(s, t, v)\nt = t or 'act'\nif type(t) ~= 'string' then\nstd.err(\"Wrong argument to obj:actions(): \"..std.tostr(t), 2)\nend\nlocal ov = s['__nr_'..t] or 0\nif type(v) == 'number' or v == false then\ns['__nr_'..t] = v or nil\nend\nreturn ov\nend;\n__renam = function(s, new)\nlocal oo = std.objects\nif new == s.nam then\nreturn\nend\nif oo[new] then\nstd.err (\"Duplicated obj name: \"..std.tostr(new), 2)\nend\noo[s.nam] = nil\noo[new] = s\nrawset(s, 'nam', new)\nreturn s\nend;\n__ini = function(s, ...)\nfor _, v in pairs(s) do\nif std.is_obj(v, 'list') then\nv:__ini(s)\nend\nend\nfor _, v in pairs(s.__ro) do\nif std.is_obj(v, 'list') then\nv:__ini(s)\nend\nend\nreturn std.call(s, 'ini', ...)\nend;\ninroom = function(s, r)\nlocal rooms = r or {}\nlocal ww = {}\nlocal o\nif type(rooms) ~= 'table' then\nstd.err(\"Wrong argument to room: \"..std.tostr(r), 2)\nend\ns:where(ww)\nwhile #ww > 0 do\nlocal nww = {}\nfor _, v in ipairs(ww) do\nif std.is_obj(v, 'room') then\nif not o then\no = v\nend\ntable.insert(rooms, v)\nelse\nv:where(nww)\nend\nend\nww = nww\nend\nreturn o\nend;\n__where = function(s) -- lists\nlocal list = s.__list\nlocal r = { }\nfor i = 1, #list do\ntable.insert(r, list[i])\nend\nreturn r\nend;\nwhere = function(s, w)\nlocal list = s.__list\nlocal r = w or { }\nlocal o\nif type(r) ~= 'table' then\nstd.err(\"Wrong argument to obj:where: \"..std.tostr(w), 2)\nend\nfor i = 1, #list do\nlocal l = list[i]\nlocal ll = l.__list\nfor k = 1, #ll do\nlocal oo = ll[k]\nif std.is_obj(oo) and oo:lookup(s) then\no = o or oo\nif o and not w then\nbreak\nend\ntable.insert(r, oo)\nend\nend\nend\nreturn o\nend;\npurge = function(s)\nlocal list = s:__where()\nfor i = 1, #list do\nlist[i]:del(s)\nend\nreturn s\nend;\nremove = function(s, w)\nif w then\nw = std.ref(w)\nif not w then\nstd.err (\"Wrong where in obj:remove()\", 2)\nend\nlocal o, l = w:lookup(s)\nif not o then\nreturn o\nend\nl:del(o)\nreturn o, { w }\nend\nlocal where = {}\ns:where(where)\nfor i = 1, #where do\nlocal o = where[i]\nlocal _, l = o:lookup(s)\nif l then\nl:del(s)\nend\nend\nreturn s, where\nend;\nclose = function(s)\ns.__closed = true\nreturn s\nend;\nopen = function(s)\ns.__closed = nil\nreturn s\nend;\nclosed = function(s)\nreturn s.__closed or false\nend;\ndisable = function(s)\ns.__disabled = true\nreturn s\nend;\nenable = function(s)\ns.__disabled = nil\nreturn s\nend;\ndisabled = function(s)\nreturn s.__disabled or false\nend;\nempty = function(s)\nfor i = 1, #s.obj do\nlocal o = s.obj[i]\nif not o:disabled() then\nreturn false\nend\nend\nreturn true\nend;\nsave = function(s, fp, n)\nif std.debug_save then\nstd.dprint(\"Saving: \"..std.nameof(s))\nend\nif s.__dynamic then -- create\nlocal nn = std.functions[s.__dynamic.fn]\nif not nn then\nstd.err(\"Error while saving dynamic object: \"..std.tostr(s), 2)\nend\nlocal arg = s.__dynamic.arg\nlocal l = ''\nfor i = 1, #arg do\nif arg[i] == s then\nstd.err(\"Error while saving dynamic object: \"..std.tostr(s)..\" Argument is self-obj.\", 2)\nend\nl = l .. ', '..std.dump(arg[i], true, true) -- strict, nested\nend\nif type(s.nam) == 'number' then\nl = string.format(\"std.new(%s%s):__renam(%d)\\n\", nn, l, s.nam)\nelse\nl = string.format(\"std.new(%s%s)\\n\", nn, l, s.nam)\nend\nfp:write(l)\nend\nfor k, _ in pairs(s.__ro) do\nlocal o = s.__ro[k]\nif std.dirty(o) then\nlocal l = string.format(\"%s%s\", n, std.varname(k))\nstd.save_var(s[k], fp, l)\nend\nend\nfor k, _ in pairs(s.__var) do\nlocal l = string.format(\"%s%s\", n, std.varname(k))\nstd.save_var(s[k], fp, l)\nend\nend;\ndisplay = function(self)\nlocal d = std.call(self, 'dsc')\nreturn d\nend;\n__xref = function(self, text, force)\nif type(text) ~= 'string' then\nreturn\nend\nlocal nam = self.nam\nif type(nam) == 'number' then\nnam = '# '..std.tostr(nam)\nend\nlocal rep = false\nlocal s = std.for_each_xref_outer(text, function(str)\nrep = true\nlocal s = str:gsub(\"^{\", \"\"):gsub(\"}$\", \"\")\nlocal test = string.gsub(s, '\\\\?[\\\\{}'..std.delim..']',\n{ ['{'] = '\\001', ['}'] = '\\003',\n  [std.delim] = '\\002' });\nwhile true do\nlocal sub = test:gsub(\"\\001[^\\001\\003]+\\003\", \"\")\nif sub == test then\nbreak\nend\ntest = sub\nend\nlocal a = test:find('\\002', 1, true)\nif not a or test:byte(a) == 1 then -- need to be |\nreturn '{'..(std.esc(nam)..std.delim..s)..'}'\nend\nreturn str\nend)\nif not rep and force then -- nothing todo?\nreturn '{'..(std.esc(nam)..std.delim..s)..'}'\nend\nreturn s;\nend;\nvisible = function(s)\nreturn not s:disabled()\nend;\nsrch = function(s, w)\nlocal o, l, idx\nif not s:visible() or s:closed() then\nreturn\nend\nl = s.obj\no, idx = l:srch(w)\nif o then\nreturn o, l, idx\nend\nfor i = 1, #s.obj do\nlocal v = s.obj[i]\no, l, i = v:srch(w)\nif o then\nreturn o, l, i\nend\nend\nend;\nlookup = function(s, w)\nlocal l = s.obj\nlocal o, idx = l:lookup(w)\nif o then\nreturn o, l, idx\nend\nfor i = 1, #s.obj do\nlocal v = s.obj[i]\no, l, i = v:lookup(w)\nif o then\nreturn o, l, i\nend\nend\nend;\nfor_each = function(s, fn, ...)\nlocal r, v\nfor i = 1, #s.obj do\nr, v = fn(s.obj[i], ...)\nif r ~= nil then\nreturn r, v\nend\nif v ~= false then -- recurse\nr, v = s.obj[i]:for_each(fn, ...)\nend\nif r ~= nil then\nreturn r, v\nend\nend\nend;\n__dump = function(s)\nif not s:visible() or s:closed() then\nreturn\nend\nreturn s.obj:__dump(true)\nend;\nlifeon = function(s)\nlocal game = std.ref 'game'\ngame:lifeon(s)\nreturn s\nend;\nlifeoff = function(s)\nlocal game = std.ref 'game'\ngame:lifeoff(s)\nreturn s\nend;\nlive = function(s)\nlocal game = std.ref 'game'\nreturn game:live(s)\nend;\n};\nfunction std.var(v)\nif type(v) ~= 'table' then\nstd.err(\"Wrong std.var() argument\", 2)\nend\nv.__var_type = true\nreturn v\nend\nstd.room = std.class({\n__room_type = true;\nfrom  = function(s)\nreturn s.__from or s\nend;\nnew = function(_, v)\nif type(v) ~= 'table' then\nstd.err (\"Wrong argument to std.room:\"..std.tostr(v), 2)\nend\nif not v.way then\nrawset(v, 'way',  {})\nend\nif type(v.way) ~= 'table' then\nstd.err (\"Wrong .way attr in object:\" .. v.nam, 2)\nend\nv.way = std.list(v.way)\n--v.way:attach(v)\nv = std.obj(v)\n-- std.setmt(v, self)\nreturn v\nend;\nvisited = function(s)\nreturn s.__visits\nend;\nvisits = function(s)\nreturn s.__visits or 0\nend;\nsrch = function(self, w)\nlocal r, v, i = std.obj.srch(self, w)\nif std.is_obj(r) then\nreturn r, v, i\nend\nr, v = self.way:lookup(w)\nif not std.is_obj(r) or r:disabled() or r:closed() then\nreturn\nend\nreturn r, self.way, v\nend;\nlookup = function(self, w)\nlocal r, v, i = std.obj.lookup(self, w)\nif std.is_obj(r) then\nreturn r, v, i\nend\nr, v = self.way:lookup(w)\nif std.is_obj(r) then\nreturn r, self.way, v\nend\nreturn\nend;\nscene = function(s)\nlocal title, dsc\ntitle = iface:title(std.titleof(s))\ndsc = std.call(s, 'dsc')\nreturn std.par(std.scene_delim, title or false, dsc)\nend;\ndisplay = function(s)\nlocal deco = std.call(s, 'decor'); -- static decorations\nreturn std.par(std.scene_delim, deco or false, s.obj:display())\nend;\nvisible = function(s)\nreturn not s:disabled() and not s:closed()\nend;\n__dump = function(s)\nreturn s.way:__dump()\nend;\n}, std.obj);\nstd.world = std.class({\n__game_type = true;\nnew = function(_, v)\nif type(v) ~= 'table' then\nstd.err (\"Wrong argument to std.pl:\"..std.tostr(v), 2)\nend\nif not v.player then\nv.player = 'player'\nend\nif v.lifes == nil then\nrawset(v, 'lifes', {})\nend\nv.lifes = std.list(v.lifes)\nv = std.obj(v)\n-- std.setmt(v, self)\nreturn v\nend;\ntime = function(s, t)\nlocal ov = s.__time or 0\nif t ~= nil then\nif type(t) ~= 'number' then\nstd.err (\"Wrong parameter to game:time: \"..stead.tostr(t), 2)\nend\ns.__time = t\nend\nreturn ov\nend;\n__ini =  function(s, load)\nreturn s:ini(load)\nend;\n__start = function(s, load)\nstd.mod_call('start', load)\nif type(std.rawget(_G, 'start')) == 'function' then\nstart(load) -- start after load\nend\ns.__started = true\nif load ~= true then\nif std.game.player.room.__from then -- already entered\nreturn nil, true\nend\nlocal r, v = std.game.player:walk(std.game.player.room, false)\nreturn r, v\nend\nend;\nini = function(s, load)\nif s.__in_ini then\nreturn -- break recursion\nend\ns.__in_ini = true std.obj.__ini(s, load) s.__in_ini = false\ns.player = std.ref(s.player) -- init game\nif not s.player then\nstd.err (\"Wrong player\", 2)\nend\nstd.for_each_obj(function(v)\nrawset(v, '__list', {}) -- reset all links\nend)\nstd.for_each_obj(function(v) -- call ini of all objects\nif v ~= s then\nv:__ini(load)\nend\nend)\nif not std.game then\nif type(std.rawget(_G, 'init')) == 'function' then\nstd.__in_init = {}\ninit()\nfor _, v in ipairs(std.__in_init) do\nv:__ini(load)\nend\nstd.__in_init = false\nend\nstd.game = s\nend\nlocal d = std.method(s, 'dsc')\nreturn std.fmt(d)\nend;\nlifeon = function(s, w, ...)\nif not w then\ns.__lifeoff = nil\nreturn\nend\nreturn s.lifes:add(w, ...)\nend;\nlifeoff = function(s, w)\nif not w then\ns.__lifeoff = true\nreturn\nend\nreturn s.lifes:del(w)\nend;\nlive = function(s, w)\nif not w then\nreturn not s.__lifeoff\nend\nreturn s.lifes:lookup(w)\nend;\nset_pl = function(s, w)\nif not std.is_obj(w, 'player') then\nstd.err(\"Wrong parameter to game:set_pl(): \"..std.tostr(w), 2)\nend\ns.player = w\nw:need_scene(true)\nend;\nlife = function(s)\nlocal av, vv\ns:events(false, false)\nif s.__lifeoff then\nreturn\nend\nlocal ll = {}\nfor i = 1, #s.lifes do\ntable.insert(ll, s.lifes[i])\nend\nfor i = 1, #ll do\nlocal v, pre, st\nlocal o = ll[i]\nif not o:disabled() then\nv, st, pre = std.call(o, 'life');\nav, vv = s:events()\nif pre then -- hi-pri msg\nav = std.par(std.space_delim, av or false, v)\nelse\nvv = std.par(std.space_delim, vv or false, v)\nend\ns:events(av or false, vv or false)\nif st == false then -- break cycle\nbreak\nend\nend\nend\nend;\nstep = function(s)\ns:life()\ns.__time = s:time() + 1\nend;\nlastdisp = function(s, str)\nlocal ov = s.__lastdisp\nif str ~= nil then\ns.__lastdisp = str\nend\nreturn ov\nend;\ndisplay = function(s, state)\nlocal l, av, pv\nlocal reaction = s:reaction() or nil\nif state then\nreaction = iface:em(reaction)\nav, pv = s:events()\nav = iface:em(av)\npv = iface:em(pv)\nl = s.player:look() -- objects [and scene]\nend\nl = std.par(std.scene_delim, reaction or false,\n    av or false, l or false,\n    pv or false) or ''\nreturn l\nend;\nlastreact = function(s, t)\nlocal o = s.__lreaction\nif t == nil then\nreturn o\nend\ns.__lreaction = t or nil\nreturn o\nend;\nreaction = function(s, t)\nlocal o = s.__reaction\nif t == nil then\nreturn o\nend\ns.__reaction = t or nil\nreturn o\nend;\nevents = function(s, av, pv)\nlocal oa = s.__aevents\nlocal op = s.__pevents\nif av ~= nil then\ns.__aevents = av or nil\nend\nif pv ~= nil then\ns.__pevents = pv or nil\nend\nreturn oa, op\nend;\ncmd = function(s, cmd)\nlocal r, v\nif not std.is_obj(s.player) then\nstd.err(\"Wrong player object.\", 2)\nend\ns.player:moved(false)\ns.player:need_scene(false)\nstd.abort_cmd = false\nr, v = std.mod_call('cmd', cmd)\n-- luacheck: push ignore\nif r ~= nil or v ~= nil then\n-- luacheck: pop\nelseif cmd[1] == nil or cmd[1] == 'look' then\nif not s.__started then\nr, v = s:__start()\nelse\ns.player:need_scene(true)\nv = true\nend\n--r, v = s.player:look()\nelseif cmd[1] == 'act' then\nif #cmd < 2 then\nreturn nil, false\nend\nlocal o = std.ref(cmd[2]) -- on what?\nif std.is_system(o) then\nlocal a = {}\nfor i = 3, #cmd do\ntable.insert(a, cmd[i])\nend\nr, v = std.call(o, 'act', std.unpack(a))\nelse\no = s.player:inspect(o)\nif not o then\nreturn nil, false -- wrong input\nend\nr, v = s.player:take(o)\nif not r and not v then\nr, v = s.player:action(o)\nend\nend\n-- if s.player:search(o)\nelseif cmd[1] == 'use' then\nif #cmd < 2 then\nreturn nil, false\nend\nlocal o1 = std.ref(cmd[2])\nlocal o2 = std.ref(cmd[3])\no1 = s.player:srch(o1)\nif not o1 then\nreturn nil, false -- wrong input\nend\nif o1 == o2 or not o2 then -- inv?\nif not o1 then\nreturn nil, false -- wrong input\nend\nr, v = s.player:useit(o1)\nelse\nr, v = s.player:useon(o1, o2)\nend\nelseif cmd[1] == 'go' then\nif #cmd < 2 then\nreturn nil, false\nend\nlocal o = std.ref(cmd[2])\nif not o then\nreturn nil, false -- wrong input\nend\nr, v = s.player:go(o)\nelseif cmd[1] == 'inv' then -- show inv\nr = s.player:__dump() -- just info\nv = nil\nelseif cmd[1] == 'way' then -- show ways\nr = s.player:where():__dump()\nv = nil\nelseif cmd[1] == 'save' then -- todo\nif #cmd < 2 then\nreturn nil, false\nend\nr = std:save(cmd[2])\nv = true\nstd.abort()\nelseif cmd[1] == 'load' then -- todo\nif #cmd < 2 then\nreturn nil, false\nend\nr = std:load(cmd[2])\nv = true\nstd.abort()\nend\nif r == nil and v == nil then\nv = false -- no reaction\nend\nif v == false or std.abort_cmd then\nif cmd[1] == 'save' then\nstd.mod_call('step', nil)\nelse\nstd.mod_call('step', v)\nend\nreturn r, v\nend\n-- v is true or nil\ns = std.game -- after reset game is recreated\ns:reaction(r or false)\nif v then\ns:step()\nend\nstd.mod_call('step', v)\nr = s:display(v)\nif v then\ns:lastreact(s:reaction() or false)\ns:lastdisp(r)\nend\nreturn r, v\nend;\naftertak = function(s, w) -- standard take action\nw = std.ref(w)\nlocal o = w:remove()\ns.player:inventory():add(o)\nend;\n}, std.obj);\nstd.player = std.class ({\n__player_type = true;\nnew = function(_, v)\nif type(v) ~= 'table' then\nstd.err (\"Wrong argument to std.pl:\"..std.tostr(v), 2)\nend\nif not v.room then\nv.room = 'main'\nend\nv = std.obj(v)\n-- std.setmt(v, self)\nreturn v\nend;\n__ini = function(s, ...)\ns.room = std.ref(s.room)\nif not s.room then\nstd.err (\"Wrong player location: \"..std.tostr(s), 2)\nend\nstd.obj.__ini(s, ...)\nend;\nmoved = function(s, v)\nlocal ov = s.__moved or false\nif v == nil then\nreturn ov\nend\nif type(v) ~= 'boolean' then\nstd.err(\"Wrong parameter to player:moved: \"..std.tostr(v), 2)\nend\nif v == false then v = nil end\ns.__moved = v\nreturn ov\nend;\nneed_scene = function(s, v)\nlocal ov = s.__need_scene or false\nif v == nil then\nreturn ov\nend\nif type(v) ~= 'boolean' then\nstd.err(\"Wrong parameter to player:need_scene: \"..std.tostr(v), 2)\nend\nif v == false then v = nil end\ns.__need_scene = v\nreturn ov\nend;\nlook = function(s)\nlocal scene\nlocal r = s:where()\nif s:need_scene() then\nscene = r:scene()\nend\nreturn std.par(std.scene_delim, scene or false, r:display())\nend;\ninspect = function(s, w)\nlocal r, v, i\nr, v, i = s:where():srch(w)\nif r ~= nil then\nreturn r, v, i\nend\nr, v, i = s:srch(w)\nif r ~= nil then\nreturn r, v, i\nend\nreturn\nend;\nlookup = function(self, w)\nlocal r, v, i = std.obj.lookup(self, w)\nif std.is_obj(r) then\nreturn r, v, i\nend\nr, v = self:inventory():lookup(w)\nif std.is_obj(r) then\nreturn r, self:inventory(), v\nend\nreturn\nend;\nhave = function(s, w)\nlocal o, i = s:inventory():lookup(w)\nif not o then\nreturn o, i\nend\nif o:disabled() then\nreturn\nend\nreturn o, i\nend;\nuseit = function(s, w, ...)\nreturn s:call('inv', w, ...)\nend;\nuseon = function(s, w1, w2)\nw1 = std.ref(w1)\nw2 = std.ref(w2)\nif w2 and w1 ~= w2 then\nreturn s:call('use', w1, w2)\nend\n-- inv mode?\nreturn s:call('inv', w1, w2)\nend;\ncall = function(_, m, w1, w2, ...)\nlocal w\nif type(m) ~= 'string' then\nstd.err (\"Wrong method in player.call: \"..std.tostr(m), 2)\nend\nw = std.ref(w1)\nif not std.is_obj(w) then\nstd.err (\"Wrong parameter to player.call: \"..std.tostr(w1), 2)\nend\nlocal r, v, t, _\nr, v = std.call(std.ref 'game', 'on'..m, w, w2, ...)\nt = std.par(std.scene_delim, false, r)\nif v == false then\nreturn t or r, true, false\nend\nif m == 'use' and w2 then\nr, v = std.call(w2, 'used', w, ...)\nt = std.par(std.scene_delim, t or false, r)\nif v == true then -- false from used --> pass to use\nw2['__nr_used'] = (w2['__nr_used'] or 0) + 1\nr, _ = std.call(std.ref 'game', 'afteruse', w, w2, ...)\nt = std.par(std.scene_delim, t or false, r)\nreturn t or r, true -- stop chain\nend\nend\nr, v = std.call(w, m, w2, ...)\nt = std.par(std.scene_delim, t or false, r)\nif v == true then\nw['__nr_'..m] = (w['__nr_'..m] or 0) + 1\nr, _ = std.call(std.ref 'game', 'after'..m, w, w2, ...)\nt = std.par(std.scene_delim, t or false, r)\nreturn t or r, true\nend\nif r == true and v == false then\nreturn r, v -- menu hack\nend\nif not v and not r then -- no reaction\nr, v = std.call(std.ref 'game', m, w, w2, ...)\nt = std.par(std.scene_delim, t or false, r)\nif not v then\nreturn\nend\nend\nreturn t or r, true\nend;\naction = function(s, w, ...)\nreturn s:call('act', w, ...)\nend;\ninventory = function(s)\nreturn s.obj\nend;\ntake = function(s, w, ...)\nreturn s:call('tak', w, ...)\nend;\nwalkin = function(s, w, ...)\nreturn s:walk(w, false, true, ...)\nend;\nwalkout = function(s, w, ...)\nif w == nil then\nw = s:where():from()\nend\nreturn s:walk(w, true, false, ...)\nend;\nwalk = function(s, w, doexit, doenter, dofrom)\nlocal noexit = (doexit == false)\nlocal noenter = (doenter == false)\nlocal nofrom = (dofrom == false)\nlocal moved = s:moved()\nif moved then\ns:moved(false)\nend\nlocal ww = w\nw = std.ref(w)\nif not w then\nstd.err(\"Wrong parameter to walk: \"..std.tostr(ww))\nend\n--if w == std.here() then -- nothing todo\n--return\n--end\nlocal inwalk = w\nlocal r, v, t, _\nlocal f = s:where()\nr, v = std.call(std.ref 'game', 'onwalk', f, inwalk)\nt = std.par(std.scene_delim, false, r)\nif v == false or s:moved() then -- stop walk\nif not s:moved() then s:moved(moved) end\nreturn t, true\nend\nr, v = std.call(inwalk, 'onwalk', f)\nt = std.par(std.scene_delim, t or false, r)\nif v == false or s:moved() then -- stop walk\nif not s:moved() then s:moved(moved) end\nreturn t, true\nend\nif not noexit and not s.__in_onexit then\ns.__in_onexit = true\nr, v = std.call(s:where(), 'onexit', inwalk)\ns.__in_onexit = false\nt = std.par(std.scene_delim, t or false, r)\nif v == false or s:moved() then\nif not s:moved() then s:moved(moved) end\nreturn t, true\nend\nend\nif not noenter then\nr, v = std.call(inwalk, 'onenter', s:where())\nt = std.par(std.scene_delim, t or false, r)\nif v == false or s:moved() then\nif not s:moved() then s:moved(moved) end\nreturn t, true\nend\nend\nif not noexit and not s.__in_exit then\ns.__in_exit = true\nr, _ = std.call(s:where(), 'exit', inwalk)\ns.__in_exit = false\nt = std.par(std.scene_delim, t or false, r)\nif s:moved() then\nreturn t, true\nend\nend\n-- enter is done\ns.room = inwalk\nif not nofrom and (f ~= inwalk or not s.room.__from) then -- brake self-recursion\ns.room.__from = f\nend\nif not noenter then\nr, _ = std.call(inwalk, 'enter', f)\nt = std.par(std.scene_delim, t or false, r)\nif s:moved() then\nreturn t, true\nend\nend\ns:where().__visits = (s:where().__visits or 0) + 1\ns:need_scene(true)\ns:moved(true)\nif not s.__in_afterwalk then\ns.__in_afterwalk = true\nr, _ = std.call(std.ref 'game', 'afterwalk', f, inwalk)\ns.__in_afterwalk = false\nt = std.par(std.scene_delim, t or false, r)\nend\nreturn t, true\nend;\ngo = function(s, w)\nlocal r\nr = s:where():srch(w)\nif not std.is_obj(r, 'room') then\nreturn nil, false\nend\nreturn s:walk(w)\nend;\nwhere = function(s, where)\nif type(where) == 'table' then\ntable.insert(where, std.ref(s.room))\nend\nreturn std.ref(s.room)\nend;\n}, std.obj);\n-- merge strings with \"space\" as separator\nstd.par = function(space, ...)\nlocal res\nlocal a = { ... };\nfor i = 1, #a do\nif type(a[i]) == 'string' then\nif res == nil then\nres = \"\"\nelse\nres = res .. space;\nend\nres = res .. a[i];\nend\nend\nreturn res;\nend\n-- add to not nill string any string\nstd.cat = function(v,...)\nif not v then\nreturn nil\nend\nif type(v) ~= 'string' then\nstd.err(\"Wrong parameter to std.cat: \"..std.tostr(v), 2);\nend\nlocal a = { ... }\nfor i = 1, #a do\nif type(a[i]) == 'string' then\nv = v .. a[i];\nend\nend\nreturn v;\nend\nstd.cctx = function()\nreturn std.call_ctx[std.call_top];\nend\nstd.callpush = function(v)\nstd.call_top = std.call_top + 1;\nstd.call_ctx[std.call_top] = { txt = nil, self = v };\nend\nstd.callpop = function()\nstd.call_ctx[std.call_top] = nil;\nstd.call_top = std.call_top - 1;\nif std.call_top < 0 then\nstd.err (\"callpush/callpop mismatch\")\nend\nend\nstd.pclr = function()\nstd.cctx().txt = nil\nend\nstd.pget = function()\nreturn std.cctx().txt;\nend\nstd.pr = function(...)\nlocal a = {...}\nif std.cctx() == nil then\nerror (\"Call from global context.\", 2);\nend\nfor i = 1, #a do\nstd.cctx().txt = std.par('', std.cctx().txt or false, std.tostr(a[i]));\nend\n--std.cctx().txt = std.cat(std.cctx().txt, std.space_delim);\nend\nstd.p = function(...)\nstd.pr(...)\nstd.cctx().txt = std.cat(std.cctx().txt, std.space_delim);\nend\nstd.pn = function(...)\nstd.pr(...)\nstd.cctx().txt = std.cat(std.cctx().txt, '^');\nend\nstd.pf = function(fmt, ...)\nif type(fmt) ~= 'string' then\nstd.err(\"Wrong argument to std.pf: \"..std.tostr(fmt))\nend\nstd.pr(string.format(fmt, ...))\nend\nfunction std.strip(s)\nif type(s) ~= 'string' and type(s) ~= 'number' then\nreturn\nend\ns = tostring(s)\ns = s:gsub(\"^[ \\t]*\", \"\"):gsub(\"[ \\t]*$\", \"\")\nreturn s\nend\nfunction std.join(a, sep)\nsep = sep or ' '\nlocal rc\nfor i = 1, #a do\nif type(a[1]) == 'string' then\nrc = (rc and rc .. sep or '') .. a[i]\nend\nend\nreturn rc\nend\nfunction std.split(s, separator)\nlocal sep, fields = separator or \" \", {}\nlocal pattern = string.format(\"([^%s]+)\", sep)\nif type(s) ~= 'string' and type(s) ~= 'number' then\nreturn fields\nend\ns = tostring(s)\ns:gsub(pattern, function(c) fields[#fields+1] = std.strip(c) end)\nreturn fields\nend\nfunction std.esc(s, sym)\nsym = sym or std.delim\nif type(s) ~= 'string' then return s end\ns = s:gsub(\"\\\\?[\"..sym..\"]\", { [sym] = '\\\\'..sym, ['\\\\'..sym] = '\\\\\\\\'..sym})\nreturn s\nend\nfunction std.unesc(s, sym)\nsym = sym or std.delim\ns = s:gsub(\"\\\\?[\\\\\"..sym..\"]\", { ['\\\\'..sym] = sym, ['\\\\\\\\'] = '\\\\' })\nreturn s\nend\nfunction std.is_proxy(t)\nreturn (type(t) == 'userdata') or (type(t) == 'table' and t.__proxy_type)\nend\nlocal function __dump(t, strict, nested)\nlocal rc = '';\nif type(t) == 'string' then\nrc = string.format(\"%q\", t):gsub(\"\\\\\\n\", \"\\\\n\")\nelseif type(t) == 'number' then\nrc = std.tostr(t)\nelseif type(t) == 'boolean' then\nrc = std.tostr(t)\nelseif type(t) == 'function' then\nif std.functions[t] then\nlocal k = std.functions[t]\nreturn string.format(\"%s\", k)\nelseif strict then\nstd.err(\"Can not save undeclared function\", 2)\nend\nelseif type(t) == 'table' and not t.__visited then\nif std.tables[t] and nested then\nlocal k = std.tables[t]\nreturn string.format(\"%s\", k)\nelseif std.is_obj(t) then\nlocal d = std.deref(t)\nif type(d) == 'number' then\nrc = string.format(\"std(%d)\", d)\nelseif type(d) == 'string' then\nrc = string.format(\"std %q\", d)\nend\nreturn rc\nend\nif strict and std.getmt(t) then\nstd.err(\"Can not save classes\", 2)\nend\nt.__visited = true\nlocal nkeys = {}\nlocal keys = {}\nfor k, v in pairs(t) do\nif strict and type(k) ~= 'number' and type(k) ~= 'string' then\nstd.err(\"Wrong key type in table: \"..type(k), 2)\nend\nif type(k) ~= 'string' or k:find(\"__\", 1, true) ~= 1 then\nif (type(v) ~= 'function' or std.functions[v]) and not std.is_proxy(v) then\nif type(k) == 'number' then\ntable.insert(nkeys, { key = k, val = v })\nelseif type(k) == 'string' then\ntable.insert(keys, { key = k, val = v })\nend\nelseif strict then\nstd.err(\"Can not save table item (\"..std.tostr(k)..\") with type: \"..type(v), 2)\nend\nend\nend\ntable.sort(nkeys, function(a, b) return a.key < b.key end)\nrc = \"{ \"\nlocal n, v\nfor k = 1, #nkeys do\nv = nkeys[k]\nif v.key == k then\nrc = rc .. __dump(v.val, strict, true)..\", \"\nelse\nn = k\nbreak\nend\nend\nif n then\nfor k = n, #nkeys do\nv = nkeys[k]\nrc = rc .. \"[\"..std.tostr(v.key)..\"] = \"..__dump(v.val, strict, true)..\", \"\nend\nend\nfor k = 1, #keys do\nv = keys[k]\nif type(v.key) == 'string' then\nif v.key:find(\"^[a-zA-Z_]+[a-zA-Z0-9_]*$\") and not lua_keywords[v.key] then\nrc = rc .. v.key .. \" = \"..__dump(v.val, strict, true)..\", \"\nelse\nrc = rc .. \"[\" .. string.format(\"%q\", v.key) .. \"] = \"..__dump(v.val, strict, true)..\", \"\nend\nelse\nrc = rc .. std.tostr(v.key) .. \" = \"..__dump(v.val, strict, true)..\", \"\nend\nend\nrc = rc:gsub(\",[ \\t]*$\", \"\") .. \" }\"\nelseif type(t) == 'table' then -- visited!\nstd.err(\"Can not save table with cross-references.\", 2)\nend\nreturn rc\nend\nlocal function cleardump(t)\nif type(t) ~= 'table' or not t.__visited then\nreturn\nend\nt.__visited = nil\nfor _, v in pairs(t) do\ncleardump(v)\nend\nend\nfunction std.dump(t, strict, nested)\nlocal rc = __dump(t, strict, nested)\ncleardump(t)\nreturn rc\nend\nlocal function clone(src)\nif type(src) ~= 'table' then return src end\nif std.is_obj(src) then return src end\nif src.__visited then\nstd.err(\"Recursive tables not supported by std.clone\")\nend\nsrc.__visited = true\nlocal dst = {}\nfor k, _ in pairs(src) do\nif k ~= '__visited' then\ndst[std.clone(k)] = clone(src[k])\nend\nend\nreturn dst\nend\nfunction std.clone(src)\ncleardump(src)\nlocal t = clone(src)\ncleardump(src)\nreturn t\nend\nfunction std.new(fn, ...)\nif not std.game then\nstd.err (\"You can not use new() from global context.\", 2)\nend\nif type(fn) ~= 'function' then\nstd.err (\"Wrong parameter to std.new\", 2)\nend\nif not std.functions[fn] then\nstd.err (\"Function is not declared in 1-st argument of std.new\", 2)\nend\nlocal arg = std.clone({...})\nlocal o = in_section ('new', function() return fn(std.unpack(arg)) end)\nif type(o) ~= 'table' then\nstd.err (\"Constructor did not return object:\"..std.functions[fn], 2)\nend\nrawset(o, '__dynamic', { fn = fn, arg = {...} })\nif std.game then\no:__ini() -- do initialization\nend\nreturn o\nend\nfunction std.delete(s)\ns = std.ref(s)\nif std.is_obj(s) then\nif type(s.nam) == 'number' and not s.__dynamic then -- static objects\nstd.objects[s.nam] = false\nelse\nstd.objects[s.nam] = nil\nend\nelse\nstd.err(\"Delete non object table\", 2)\nend\nend\nfunction std.nameof(o)\no = std.ref(o)\nif not std.is_obj(o) then\nstd.err(\"Wrong parameter to std.nameof: \"..std.tostr(o), 2)\nreturn\nend\nreturn o.nam\nend\nfunction std.dispof(o)\no = std.ref(o)\nif not std.is_obj(o) then\nstd.err(\"Wrong parameter to std.dispof\", 2)\nreturn\nend\nif o.disp ~= nil then\nlocal d = std.call(o, 'disp')\nreturn d\nend\nif o.__autoname then\nif std.is_tag(o.tag) then\no = o.tag:sub(2)\nreturn o\nend\nif type(o.nam) == 'number' then\nreturn std.tostr(o.nam)\nend\nstd.err(\"No nam nor disp are specified for obj: \"..std.tostr(o.nam), 2)\nend\nreturn o.nam\nend\nfunction std.titleof(o)\no = std.ref(o)\nif not std.is_obj(o) then\nstd.err(\"Wrong parameter to std.titleof\", 2)\nreturn\nend\nif o.title ~= nil then\nreturn std.call(o, 'title')\nend\nreturn std.dispof(o)\nend\nfunction std.ref(o)\nif type(o) == 'table' then\nif not std.is_obj(o) then\nstd.err(\"Reference to wrong object: \"..std.tostr(o), 2)\nend\nreturn o\nend\nlocal oo = std.objects\nif oo[o] then\nreturn oo[o]\nend\nif std.noerror then\nstd.dprint(\"Reference to non-existing object: \", std.tostr(o))\nreturn {} -- give fake object\nend\nend\nfunction std.deref(o)\nif std.is_obj(o) then\nreturn o.nam\nelseif std.ref(o) then\nreturn o\nend\nend\nstd.method = function(v, n, ...)\nif type(v) ~= 'table' then\nstd.err (\"Call on non table object:\"..std.tostr(n), 2);\nend\nif v[n] == nil then\nreturn\nend\nif type(v[n]) == 'string' then\nreturn v[n], true;\nend\nif type(v[n]) == 'function' then\nstd.callpush(v, ...)\nlocal c\nlocal a, b = v[n](v, ...);\nc = b\nif b == nil and (type(a) == 'boolean' or a == nil) then\na, b = std.pget(), a\nc = b\nend\nif b == nil then\nb = true -- the fact of call\nend\nstd.callpop()\nreturn a, b, c\nend\nif type(v[n]) == 'boolean' or type(v[n]) == 'table' then\nreturn v[n], true\nend\nstd.err (\"Method not string nor function:\"..std.tostr(n), 2);\nend\nstd.call = function(o, n, ...)\nif type(o) ~= 'table' then\nstd.err(\"Call on non table object: \"..std.tostr(n), 2)\nend\nlocal r, v, c = std.method(o, n, ...)\nif std.strip_call and type(r) == 'string' then\nr = r:gsub(\"^[%^\\n\\r\\t ]+\", \"\") -- extra heading ^ and spaces\nr = r:gsub(\"[%^\\n\\r\\t ]+$\", \"\") -- extra trailing ^ and spaces\nreturn r, v, c\nend\nreturn r or nil, v, c\nend\nlocal function get_token(inp)\nlocal q, k\nlocal rc = ''\nk = 1\nif inp:sub(1, 1) == '\"' then\nq = true\nk = k + 1\nend\nwhile true do\nlocal c = inp:sub(k, k)\nif c == '' then\nif q then\nreturn nil -- error\nend\nbreak\n--return rc, k\nend\nif c == '\"' and q then\nk = k + 1\nbreak\nend\nif not q and (c == ' ' or c == ',' or c == '\\t') then\nbreak\nend\nif q and c == '\\\\' then\nk = k + 1\nc = inp:sub(k, k)\nrc = rc .. c\nelse\nrc = rc .. c\nend\nk = k + 1\nend\nif not q then\nif std.tonum(rc) then\nrc = std.tonum(rc)\nelseif rc == 'true' then\nrc = true\nelseif rc == 'false' then\nrc = false\nend\nend\nreturn rc, k\nend\nlocal function cmd_parse(inp)\nlocal cmd = {}\nif type(inp) ~= 'string' then\nreturn false\nend\nif inp:find(\"^save[ \\t]+\") then\ncmd[1] = 'save'\ncmd[2] = inp:gsub(\"^save[ \\t]+\", \"\")\nreturn cmd\nelseif inp:find(\"^load[ \\t]+\") then\ncmd[1] = 'load'\ncmd[2] = inp:gsub(\"^load[ \\t]+\", \"\")\nreturn cmd\nend\ninp = inp:gsub(\"[ \\t]*$\", \"\")\nwhile true do\ninp = inp:gsub(\"^[ ,\\t]*\",\"\")\nlocal v, i = get_token(inp)\nif v == nil or v == '' then\nbreak\nend\ninp = inp:sub(i)\ntable.insert(cmd, v)\nend\nreturn cmd\nend\nstd.cmd_parse = cmd_parse\nfunction std.me()\nreturn std.ref(std.ref 'game'.player)\nend\nfunction std.here()\nreturn std.ref(std.me().room)\nend\nfunction std.cacheable(n, f)\nreturn function(...)\nlocal s = std.cache[n]\nif s ~= nil then\nif s == -1 then s = nil end\nreturn s\nend\nstd.cache[n] = -1\ns = f(...)\nif s ~= nil then\nstd.cache[n] = s\nend\nreturn s\nend\nend\nlocal iface = std.obj {\nnam = '@iface';\ncmd = function(_, inp)\nlocal cmd = std.cmd_parse(inp)\nif std.debug_input then\nstd.dprint(\"* input: \", inp)\nend\nif not cmd then\nreturn \"Error in cmd arguments\", false\nend\nstd.cmd = cmd\nstd.cache = {}\nlocal r, v = std.ref 'game':cmd(cmd)\nif r == true and v == false then\nreturn nil, true -- hack for menu mode\nend\nr = iface:fmt(r, v) -- to force fmt\nif std.debug_output then\nstd.dprint(\"* output: \", r, v)\nend\nreturn r, v\nend;\nxref = function(_, str, obj)\nobj = std.ref(obj)\nif not obj then\nreturn str;\nend\nreturn std.cat(str, \"(\"..std.deref(obj)..\")\");\nend;\ntitle = function(_, str)\nreturn \"[ \"..std.tostr(str)..\" ]\"\nend;\nraw_mode = function(s, v)\nlocal ov = s.__raw\nif v ~= nil then\ns.__raw = v or nil\nend\nreturn ov\nend;\nfmt = function(self, str, state)\nif self:raw_mode() or type(str) ~= 'string' then\nreturn str\nend\nstr = std.fmt(str, std.format, state)\nreturn std.cat(str, '\\n')\nend;\nem = function(_, str)\nreturn str\nend;\n};\nlocal function fmt_stub(_, str)\nreturn str\nend\niface.em = fmt_stub\niface.center = fmt_stub\niface.just = fmt_stub\niface.left = fmt_stub\niface.right = fmt_stub\niface.bold = fmt_stub\niface.top = fmt_stub\niface.bottom = fmt_stub\niface.middle = fmt_stub\niface.nb = fmt_stub\niface.anchor = fmt_stub\niface.img = fmt_stub\niface.imgl = fmt_stub\niface.imgr = fmt_stub\niface.under = fmt_stub\niface.st = fmt_stub\niface.tab = fmt_stub\niface.y = fmt_stub\nfunction std.loadmod(f)\nif std.game and not std.__in_gamefile then\nstd.err(\"Use loadmod() only in global context\", 2)\nend\nif type(f) ~= 'string' then\nstd.err(\"Wrong argument to loadmod(): \"..std.tostr(f), 2)\nend\nif not f:find(\"%.lua$\") then\nf = f .. '.lua'\nend\nif not std.modules[f] then\nstd.modules[f] = true\nstd.dofile(f)\nend\nend\nfunction std.include(f)\nif std.game and not std.__in_gamefile then\nstd.err(\"Use include() only in global context\", 2)\nend\nif type(f) ~= 'string' then\nstd.err(\"Wrong argument to include(): \"..std.tostr(f), 2)\nend\nif not f:find(\"%.lua$\") then\nf = f .. '.lua'\nend\nif not std.includes[f] then\nstd.includes[f] = true\nin_section('include', function()\nstd.dofile(f)\nend)\nend\nend\nfunction std.abort()\nstd.abort_cmd = true\nend\nfunction std.nop()\nstd.abort()\nif std.cctx() then\nstd.pr(std.game:lastdisp())\nend\nreturn std.game:lastdisp(), true\nend\n-- require \"ext/gui\"\nrequire \"declare\"\nrequire \"dlg\"\nrequire \"stdlib\"\n","theme.lua":"-- luacheck: globals theme\ntheme = stead.ref '@theme'\n","timer.lua":"-- luacheck: globals timer\ntimer = stead.ref '@timer'\n"}