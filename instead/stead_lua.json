{"click.lua":"require \"theme\"\n\nclick = {\n\tnam = 'click';\n\tobject_type = true;\n\tsystem_type = true;\n\tbg = false;\n\tpress = false;\n\tbutton = false;\n\tsave = function(self, name, h, need)\n\t\tlocal s = stead.tostring(self.bg)\n\t\th:write(stead.string.format(\"click[%q] = %s;\\n\", 'bg', s))\n\t\ts = stead.tostring(self.press)\n\t\th:write(stead.string.format(\"click[%q] = %s;\\n\", 'press', s))\n\t\ts = stead.tostring(self.button)\n\t\th:write(stead.string.format(\"click[%q] = %s;\\n\", 'button', s))\n\tend;\n}\n\nstead.module_init(function()\n\tinput.click = stead.hook(input.click, \n\tfunction(f, s, press, mb, x, y, px, py, ...)\n\t\tlocal cmd = 'click '\n\t\tlocal act = false\n\t\tif ( press or click.press ) and ( mb == 1 or click.button ) then\n\t\t\tcmd = cmd..stead.tostr(press)..','..stead.tostr(mb);\n\n\t\t\tif click.bg or theme.get 'scr.gfx.mode' == 'direct' then\n\t\t\t\tact = true\n\t\t\t\tcmd = cmd .. ',' .. x .. ','.. y\n\t\t\tend\n\n\t\t\tif px then\n\t\t\t\tact = true\n\t\t\t\tcmd = cmd .. ',' .. px .. ',' .. py\n\t\t\tend\n\n\t\t\tif act then\n\t\t\t\treturn cmd\n\t\t\tend\n\t\tend\n\t\treturn f(s, press, mb, x, y, px, py, ...)\n\tend)\nend)\n\ngame.action = stead.hook(game.action, \nfunction(f, s, cmd, press, mb, x, y, px, py, ...)\n\tif cmd == 'click' then\n\t\tlocal r,v\n\t\tlocal x2 = px\n\t\tlocal y2 = py\n\n\t\tif stead.tonum(mb) then\n\t\t\tmb = stead.tonum(mb)\n\t\tend\n\n\t\tif stead.tonum(px) then\n\t\t\tx2 = stead.tonum(px)\n\t\tend\n\n\t\tif stead.tonum(py) then\n\t\t\ty2 = stead.tonum(py)\n\t\tend\n\n\t\tif stead.here().click then\n\t\t\ts = stead.here()\n\t\tend\n\n\t\tif press == 'true' then\n\t\t\tpress = true\n\t\telse\n\t\t\tpress = false\n\t\tend\n\n\t\tif s.click then\n\t\t\tif click.press then\n\t\t\t\tif click.button then\n\t\t\t\t\tr,v = stead.call(s, 'click', press, mb, stead.tonum(x), stead.tonum(y), x2, y2, ...);\n\t\t\t\telse\n\t\t\t\t\tr,v = stead.call(s, 'click', press, stead.tonum(x), stead.tonum(y), x2, y2, ...);\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif click.button then\n\t\t\t\t\tr,v = stead.call(s, 'click', mb, stead.tonum(x), stead.tonum(y), x2, y2, ...);\n\t\t\t\telse\n\t\t\t\t\tr,v = stead.call(s, 'click', stead.tonum(x), stead.tonum(y), x2, y2, ...);\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif r == nil and v == nil and not stead.api_atleast(1, 3, 5) then\n\t\t\treturn nil, true\n\t\tend\n\t\treturn r,v\n\tend\n\treturn f(s, cmd, press, mb, x, y, px, py, ...)\nend)\n-- vim:ts=4\n","counters.lua":"if not stead.api_atleast(1, 6, 3) then\n\terror (\"Counters module can not run with api version < 1.6.3\", 3)\nend\n\nlocal function inc_nr(v, n)\n\tlocal name = '__'..n..'_nr'\n\tif not v[name] then\n\t\tv[name] = 0\n\tend\n\tv[name] = v[name] + 1\nend\n\nlocal function read_nr(v, n, set)\n\tlocal name = '__'..n..'_nr'\n\tv = stead.ref(v)\n\tif stead.type(v) ~= 'table' then\n\t\treturn v\n\tend\n\tif not v[name] then\n\t\tif stead.type(set) == 'number' then v[name] = set end\n\t\treturn 0\n\tend\n\tn = v[name]\n\tif stead.type(set) == 'number' then v[name] = set end\n\treturn n\nend\n\ngame.onact = stead.hook(game.onact, function(f, v, w, ...)\n\tinc_nr(v, 'act');\n\tinc_nr(w, 'act');\n\treturn f(v, w, ...)\nend)\n\ngame.onuse = stead.hook(game.onuse, \nfunction(f, v, w, ...)\n\tinc_nr(v, 'use');\n\tinc_nr(w, 'use');\n\treturn f(v, w, ...)\nend)\n\ngame.oninv = stead.hook(game.oninv, \nfunction(f, v, w, ...)\n\tinc_nr(v, 'inv');\n\tinc_nr(w, 'inv');\n\treturn f(v, w, ...)\nend)\n\ngame.onwalk = stead.hook(game.onwalk, \nfunction(f, v, w, ...)\n\tinc_nr(v, 'walk');\n\tinc_nr(w, 'walk');\n\treturn f(v, w, ...)\nend)\n\nfunction act_count(s, v)\n\tif not s and not v then\n\t\ts = game\n\t\tv = nil\n\telseif stead.tonum(s) then\n\t\tv = s\n\t\ts = game\n\tend\n\treturn read_nr(s, 'act', v)\nend\n\nfunction inv_count(s, v)\n\tif not s and not v then\n\t\ts = game\n\t\tv = nil\n\telseif stead.tonum(s) then\n\t\tv = s\n\t\ts = game\n\tend\n\treturn read_nr(s, 'inv', v)\nend\n\nfunction use_count(s, v)\n\tif not s and not v then\n\t\ts = game\n\t\tv = nil\n\telseif stead.tonum(s) then\n\t\tv = s\n\t\ts = game\n\tend\n\treturn read_nr(s, 'use', v)\nend\n\nfunction walk_count(s, v)\n\tif not s and not v then\n\t\ts = game\n\t\tv = nil\n\telseif stead.tonum(s) then\n\t\tv = s\n\t\ts = game\n\tend\n\treturn read_nr(s, 'walk', v)\nend\n","dash.lua":"require \"format\"\nformat.dash = true\n","dbg.lua":"-- add this: reuire \"dbg\"\n-- in your project\n-- for debug tools\nrequire \"input\"\n\nlocal function _xref_escape(n)\n\tlocal delim = ':'\n\tif stead.api_atleast(1, 2, 2) then\n\t\tdelim = stead.delim;\n\tend\n\tif xact then\n\t\tn = n:gsub(\"\\\\?[\\\\\"..delim..\"]\", { [delim] = \"\\\\\"..delim } )\n\tend\n\treturn n\nend\n\nlocal function ordered_n(t)\n\tlocal ordered = {};\n\tlocal i,v, max;\n\tmax = 0;\n\tfor i,v in stead.pairs(t) do\n\t\tlocal o = { k = i; v = v };\n\t\tstead.table.insert(ordered, o);\n\t\tmax = max + 1;\n\tend\n\tstead.table.sort(ordered, function(a, b)\n\t\tif isObject(a.v) and not isObject(b.v) then\n\t\t\treturn true\n\t\tend\n\t\tif not isObject(a.v) and isObject(b.v) then\n\t\t\treturn false\n\t\tend\n\t\tif isObject(a.v) and isObject(b.v) then\n\t\t\tlocal n = stead.call(a.v, 'nam');\n\t\t\tlocal m = stead.call(b.v, 'nam');\n\t\t\tif stead.type(n) ~= 'string' and stead.type(m) ~= 'string' then\n\t\t\t\treturn false\n\t\t\tend\n\t\t\tif stead.type(n) ~= 'string' then\n\t\t\t\treturn true\n\t\t\tend\n\t\t\tif stead.type(m) ~= 'string' then\n\t\t\t\treturn false\n\t\t\tend\n\t\t\tif n == m then\n\t\t\t\tlocal o1, o2\n\t\t\t\to1 = stead.deref(a.v)\n\t\t\t\to2 = stead.deref(b.v)\n\t\t\t\tif stead.type(o1) == 'string' and stead.type(o2) == 'string' then\n\t\t\t\t\treturn o1 < o2\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn n < m;\n\t\tend\n\t\treturn false\n\tend)\n\tordered.i = 1;\n\tordered.max = max;\n\treturn ordered;\nend\n\nlocal function snext(t, k)\n\tlocal v\n\tif not k then\n\t\tk = ordered_n(t);\n\tend\n\tif k.i > k.max then\n\t\treturn nil\n\tend\n\tv = k[k.i]\n\tk.i = k.i + 1\n\treturn k, v.v, v.k;\nend\n\nlocal function spairs(s, var)\n\treturn snext, s, nil;\nend\n\nfunction dbg_disp_obj()\n\tlocal v = obj {\n\t\tnam = 'disp',\n\t\tact = true,\n\t\tdsc = function(s)\n\t\t\tlocal r = s._txt\n\t\t\ts._txt = nil;\n\t\t\treturn r\n\t\tend;\n\t\tsave = function(self, name, h, need)\n\t\t\tif need then\n\t\t\t\th:write(stead.string.format(\"%s  = dbg_disp_obj();\\n\", name));\n\t\t\tend\n\t\t\tstead.savemembers(h, self, name, false);\n\t\tend\n\t}\n\treturn v;\nend\n\ndbg_dump_obj = function(w)\n\tw = stead.ref(w)\n\n\tif stead.type(w) ~= 'table' then\n\t\tseen('disp')._txt = '^^No such object.';\n\t\treturn true\n\tend\n\tlocal i,o,n\n\tlocal rc = ''\n\tfor i,o in stead.pairs(w) do\n\t\tlocal t = stead.tostring(o);\n\t\tif t == i then\n\t\t\tt = stead.tostr(o);\n\t\tend\n\t\tif t then\n\t\t\tif rc ~='' then rc = rc..'^' end\n\t\t\tlocal n = '';\n\t\t\tif isObject(o) then\n\t\t\t\tn = stead.call(o, 'nam');\n\t\t\t\tif stead.type(n) ~= 'string' then n = '' else n = ' : '..n; end\n\t\t\tend\n\t\t\trc = stead.cat(rc, stead.par(' ', stead.tostr(i)..' : '..t..n));\n\t\tend\n\tend\n\tseen('disp')._txt = stead.cat('^^', rc)\n\treturn true;\nend\n\ndbg_dump_globals = function()\n\tlocal i,o\n\tlocal rc=''\n\tif stead.type(variables) ~= 'table' then\n\t\treturn\n\tend\n\tfor i,o in stead.ipairs(variables) do\n\t\tlocal v = _G[o];\n\t\tlocal t = stead.tostring(v);\n\t\tif t then\n\t\t\tif rc ~='' then rc = rc..'^' end\n\t\t\trc = stead.cat(rc, stead.par(' ', stead.tostr(o)..' : '..t));\n\t\tend\n\tend\n\tseen('disp')._txt = stead.cat('^^', rc)\n\treturn true;\nend\n\ndbg_here = function()\n\treturn debug_tool._here\nend\n\ndbg_list_objects = function()\n\tlocal i,o\n\tlocal dis = function(o)\n\t\tif isDisabled(o) then\n\t\t\treturn \", disabled\"\n\t\tend\n\t\treturn ''\n\tend\n\tlocal rc = stead.par(' ', 'Room:'..stead.tostr(stead.deref(dbg_here())), \n\t\t\t'Nam:'..stead.tostr(stead.call(dbg_here(),'nam')));\n\tfor i,o in stead.opairs(objs(dbg_here())) do\n\t\trc = rc..'^';\n\t\to = stead.ref(o)\n\t\trc = stead.cat(rc, stead.par(' ', 'Id: '..stead.tostr(o.id)..', '..\n\t\t\tstead.tostr(stead.deref(o))..': '..stead.tostr(stead.call(o, 'nam'))..dis(o)));\n\tend\n--\tseen('disp')._txt = rc\n\treturn rc\nend\n\ndbg_list_inv = function()\n\tlocal i,o\n\tlocal rc=''\n\tlocal dis = function(o)\n\t\tif isDisabled(o) then\n\t\t\treturn \", disabled\"\n\t\tend\n\t\treturn ''\n\tend\n\n\tlocal tak = function(o)\n\t\tif taken(o) then\n\t\t\treturn \", taken\"\n\t\tend\n\t\treturn ''\n\tend\n\n\tfor i,o in stead.opairs(inv()) do\n\t\tif rc ~='' then rc = rc..'^' end\n\t\to = stead.ref(o)\n\t\trc = stead.cat(rc, stead.par(' ', 'Id: '..stead.tostr(o.id)..', '..\n\t\t\tstead.tostr(stead.deref(o))..': '..stead.tostr(stead.call(o, 'nam'))..dis(o)..tak(o)));\n\tend\n\tif rc == '' then return end\n--\tseen('disp')._txt = rc\n\treturn rc\nend\n\ndbg_execute_cmd = room {\n\tnam = \"Execute Lua code\",\n\tdebug = true,\n\tpic = true,\n\tsystem_type = true, \n\tforcedsc = true,\n\tdsc = \"Enter Lua code here to exec.\",\n\tinp_enter = function(s)\n\t\tif stead.type(s.obj[1]._txt) == 'string' then\n\t\t\tlocal f = stead.eval(s.obj[1]._txt);\n\t\t\tif f then\n\t\t\t\tseen('disp')._txt = stead.cat('^^', f());\n\t\t\t\treturn true\n\t\t\tend\n\t\t\tseen('disp')._txt = \"^^Error in exec.\";\n\t\t\treturn true\n\t\tend\n\t\treturn stead.back();\n\tend,\n\tobj = { inp('inp', '{Enter cmd}: ', 'return \"Hello World!\"'), \n\t\tobj { nam = 'Back', dsc = '^{Back}', act = code [[ stead.back() ]] },\n\t\tdbg_disp_obj(),\n\t},\n\texit = function(s)\n\t\ts.obj[1]:state(false)\n\tend;\n}\n\ndbg_dump_object = room {\n\tnam = \"Dump object\",\n\tdebug = true,\n\tpic = true,\n\tsystem_type = true, \n\tforcedsc = true,\n\tdsc = \"Enter object name here to dump.\",\n\tinp_enter = function(s)\n\t\tlocal w = s.obj[1]._txt\n\t\tif stead.type(w) == 'string' then\n\t\t\tif not stead.ref(w) then w = objs(dbg_here()):srch(w); end\n\t\t\treturn dbg_dump_obj(w);\n\t\tend\n\t\treturn stead.back();\n\tend,\n\tobj = { inp('inp', '{Enter object}: ', 'main'), \n\t\tobj{nam = 'Here', dsc = '^{Dump here}', act = code[[ return dbg_dump_obj(dbg_here())]]},\n\t\tobj{nam = 'Player',dsc =  '^{Dump player}', act = code[[ return dbg_dump_obj(stead.me())]]},\n\t\tobj{nam = 'Lifes', dsc = '^{Dump lifes}', act = code[[ return dbg_dump_obj(debug_tool.lifes)]]},\n\t\tobj{nam = 'Ways', dsc = '^{Dump ways}', act = code[[ return dbg_dump_obj(ways(dbg_here()))]]},\n\t\tobj{nam = 'Globals', dsc = '^{Dump globals}', act = code [[return dbg_dump_globals()]] },\n\t\tobj{nam = 'Back', dsc = '^{Back}', act = code [[ return stead.back() ]] },\n\t\tdbg_disp_obj() },\n\texit = function(s)\n\t\ts.obj[1]:state(false)\n\tend;\n}\n\ndbg_choose_location = dlg {\n\tdebug = true,\n\tpic = true,\n\tsystem_type = true, \n\tforcedsc = true,\n\tnam = 'Go to',\n\tdsc = 'Select location.',\n\tgen = function(s)\n\t\tlocal k,v,kk\n\t\tobjs(s):zap();\n\t\tfor k,v,kk in spairs(_G) do\n\t\t\tif isRoom(v) and not v.debug then\n\t\t\t\tlocal n = stead.tostr(stead.call(v, 'nam'));\n\t\t\t\tlocal o = kk;\n\t\t\t\tif stead.type(o) == 'string' then\n\t\t\t\t\tn = n..' : '..o;\n\t\t\t\t\tn = _xref_escape(n);\n\t\t\t\t\tput(phr(n, true, [[timer:set(debug_tool._timer); game.lifes:cat(debug_tool.lifes); return stead.walk(]]..o..[[)]]), s);\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tput (phr('Back',true, 'return stead.back()'), s)\n\tend\n}\n\ndbg_choose_object = dlg {\n\tdebug = true,\n\tpic = true,\n\tsystem_type = true, \n\tforcedsc = true,\n\tnam = 'Get object',\n\tdsc = 'Select object to get.',\n\tgen = function(s)\n\t\tlocal k,v,kk\n\t\tobjs(s):zap();\n\t\tfor k,v,kk in spairs(_G) do\n\t\t\tif isObject(v) and not isPhrase(v) and not isRoom(v) and not isPlayer(v) and not v.debug and not have(v) and not isStatus(v) then\n\t\t\t\tlocal n = stead.tostr(stead.call(v, 'nam'));\n\t\t\t\tlocal o = kk;\n\t\t\t\tif stead.type(o) == 'string' then\n\t\t\t\t\tn = n..' : '..o;\n\t\t\t\t\tn = _xref_escape(n);\n\t\t\t\t\tput(phr(n, true, o..':enable(); return take('..o..')'), s);\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tput (phr('Back',true, 'return stead.back()'), s)\n\tend\n}\n\ndbg_drop_object = dlg {\n\tdebug = true,\n\tpic = true,\n\tforcedsc = true,\n\tsystem_type = true, \n\tnam = 'Drop object',\n\tdsc = 'Select object to drop.',\n\tgen = function(s)\n\t\tlocal k,v\n\t\tobjs(s):zap();\n\t\tfor k,v in stead.ipairs(inv()) do\n\t\t\tv = stead.ref(v);\n\t\t\tif not v.debug then\n\t\t\t\tlocal n = stead.tostr(stead.call(v, 'nam'));\n\t\t\t\tlocal o = stead.deref(v);\n\t\t\t\tif stead.type(o) == 'string' then\n\t\t\t\t\tn = n..' : '..o;\n\t\t\t\t\tn = _xref_escape(n);\n\t\t\t\t\tput (phr(n, true, o..':enable(); drop('..o..','..stead.deref(dbg_here())..')'), s)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tput (phr('Back', true, 'return stead.back()'), s)\n\tend\n}\n\nfunction dbg_exit()\n\tlocal r\n\tif not stead.api_atleast(1, 2, 0) then\n\t\tr = stead.call(dbg_here(), 'dsc');\n\tend\n\tgame.lifes:cat(debug_tool.lifes);\n\ttimer:set(debug_tool._timer);\n\treturn stead.par ('^^', stead.back(), r);\nend\n\ndebug_dlg = dlg {\n\tdebug = true,\n\tpic = true,\n\tsystem_type = true, \n\tforcedsc = true,\n\tnam = 'Debug Tool',\n\tdsc = 'Select tool.',\n\tobj = {\n\t\tphr('Go to location...', true, [[pon(); dbg_choose_location:gen(); return stead.walk('dbg_choose_location')]]),\n\t\tphr('Get object...', true, [[pon(); dbg_choose_object:gen(); return stead.walk('dbg_choose_object')]]),\n\t\tphr('Put object...', true, [[pon(); dbg_drop_object:gen(); return stead.walk('dbg_drop_object')]]),\n\t\tphr('Current scene...', true, [[pon(); return dbg_list_objects();]]),\n\t\tphr('Inventory...', true, [[pon(); return dbg_list_inv();]]),\n\t\tphr('Dump object...', true, [[pon(); return stead.walk(dbg_dump_object);]]),\n\t\tphr('Exec Lua string...', true, [[pon(); return stead.walk('dbg_execute_cmd')]]),\n\t\tphr('Exit',true , [[pon(); return dbg_exit()]]),\n\t},\n};\n\ndebug_tool = menu {\n\tdebug = true,\n\tsystem_type = true,\n\tforcedsc = true,\n\tnam = txtb('debug'),\n\tlifes = list {},\n\tinv = function(s)\n\t\tif stead.here().debug then\n\t\t\treturn nil, true --nothing todo\n\t\tend\n\t\tdebug_dlg.__from__ = stead.here();\n\t\ts._timer = timer:get();\n\t\ttimer:stop();\n\t\ts.lifes:zap();\n\t\ts.lifes:cat(game.lifes);\n\t\tgame.lifes:zap();\n\t\ts._here = stead.here();\n\t\tstead.me().where = 'debug_dlg'; -- force to go\n\t\treturn stead.walk(self.where);\n\tend,\n};\n\ngame.action = stead.hook(game.action, \nfunction (f, s, cmd, ...)\n\tif cmd == 'use_debug' then\n\t\treturn debug_tool:inv()\n\telseif cmd == 'exit_debug' then\n\t\tstead.me().where = 'debug_dlg';\n\t\tdbg_execute_cmd.obj[1]:state(false)\n\t\tdbg_dump_object.obj[1]:state(false)\n\t\treturn dbg_exit()\n\tend\n\treturn f(s, cmd, ...)\nend)\n\nstead.module_init(function()\n\tinput.key = stead.hook(input.key,\n\tfunction(f, s, down, key, ...)\n\t\tif down and key == 'f7' then \n\t\t\tif stead.here().debug then\n\t\t\t\treturn 'exit_debug'\n\t\t\telse\n\t\t\t\treturn 'use_debug'\n\t\t\tend\n\t\tend\n\t\t\n\t\treturn f(s, down, key, ...)\n\tend)\n\tputf('debug_tool', stead.me());\nend)\n\n\n-- vim:ts=4\n","dlg.lua":"-- stead.phrase_prefix = '--'\nlocal function isValid(p)\n\treturn isPhrase(p) and p.dsc and (p.ans or p.code)\nend\n\nlocal function isDelimiter(p)\n\treturn isPhrase(p) and not isDisabled(p) and (p.dsc == nil and p.ans == nil and p.code == nil)\nend\n\nlocal tagpnext = function(a, k)\n\tif not k then\n\t\tif isPhrase(a.tag) then\n\t\t\treturn 1, a.tag\n\t\tend\n\t\tif stead.type(a.tag) == 'number' then\n\t\t\tlocal r = a.s:phrase(a.tag)\n\t\t\tif r then return 1, r end\n\t\t\treturn\n\t\tend\n\t\tk = {}\n\t\tlocal r,v \n\t\tfor r,v in stead.opairs(a.s.obj) do\n\t\t\tv = stead.ref(v)\n\t\t\tif isPhrase(v) and v.tag == a.tag then\n\t\t\t\tstead.table.insert(k, v)\n\t\t\tend\n\t\tend\n\t\tk.i = 0\n\t\tk.n = stead.table.maxn(k)\n\tend\n\tif k == 1 or k.i >= k.n then\n\t\treturn nil\n\tend\n\tk.i = k.i + 1\n\treturn k, k[k.i]\nend\n\nlocal function phrases(s, tag)\n\tlocal a = { s = s, tag = tag }\n\treturn tagpnext, a, nil;\nend\n\nstead.phrase_seen = function(s, enb, ...)\n\tlocal i, ph, k\n\tlocal a = {...}\n\tif stead.table.maxn(a) == 0 then\n\t\tstead.table.insert(a, stead.cctx().self);\n\tend\n\tfor i=1,stead.table.maxn(a) do\n\t\tlocal r\n\t\tfor k, ph in phrases(s, a[i]) do\n\t\t\tr = isPhrase(ph) and not isRemoved(ph) and not ph:disabled();\n\t\t\tif r then \n\t\t\t\tbreak \n\t\t\tend\n\t\tend\n\t\tif enb then r = not r end\n\t\tif r then return false end\n\tend\n\treturn true\nend\n\nlocal function ponoff(s, on, ...)\n\tlocal i, ph, k\n\tlocal a = {...}\n\tif stead.table.maxn(a) == 0 then\n\t\tstead.table.insert(a, stead.cctx().self)\n\tend\n\tfor i=1,stead.table.maxn(a) do\n\t\tfor k, ph in phrases(s, a[i]) do\n\t\t\tif isPhrase(ph) and not isRemoved(ph) then\n\t\t\t\tif on then\n\t\t\t\t\tph:enable();\n\t\t\t\telse \n\t\t\t\t\tph:disable();\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nstead.dialog_prem = function(s, ...)\n\tlocal i, ph, k\n\tlocal a = {...}\n\tif stead.table.maxn(a) == 0 then\n\t\tstead.table.insert(a, stead.cctx().self);\n\tend\n\tfor i=1,stead.table.maxn(a) do\n\t\tfor k, ph in phrases(s, a[i]) do\n\t\t\tif isPhrase(ph) then\n\t\t\t\tph:remove();\n\t\t\tend\n\t\tend\n\tend\nend\n\nstead.dialog_pon = function(self,...)\n\treturn ponoff(self, true, ...);\nend\n\nstead.dialog_poff = function(self,...)\n\treturn ponoff(self, false, ...);\nend\n\nlocal function phr_get(self)\n\tlocal n = #self.__phr_stack;\n\tif n == 0 then return 1 end\n\treturn self.__phr_stack[n];\nend\n\nlocal function phr_pop(self)\n\tlocal n = #self.__phr_stack;\n\tif n <= 1 then return false end\n\tstead.table.remove(stead.here().__phr_stack, n)\n\treturn true\nend\n\nlocal function call_empty(self)\n\tlocal ph = self:phrase(phr_get(self))\n\tlocal r \n\tif not isPhrase(ph) or isDisabled(ph) or not ph.empty then\n\t\tself:pret()\n\t\treturn\n\tend\n\tr = stead.call(ph, \"empty\")\n\tif stead.type(r) == 'string' then\n\t\tstead.p(r)\n\tend\n\treturn r\nend\n\nlocal function call_enter(ph)\n\tlocal r, n\n\tif not isPhrase(ph) or isDisabled(ph) then\n\t\treturn\n\tend\n\tif isValid(ph) then\n\t\treturn\n\tend\n\tr = stead.call(ph, 'dsc')\n\tif stead.type(r) == 'string' then\n\t\tstead.p(r)\n\tend\nend\n\nlocal function dialog_reset(self)\n\tlocal i,ph\n\tfor i,ph in stead.pairs(self.obj) do\n\t\tif isPhrase(ph) then\n\t\t\tph.nam = ''\n\t\tend\n\tend\nend\n\nstead.dialog_look = function(self)\n\tlocal i,n,v,ph,ii\n\tn = 1\n\tlocal start = phr_get(self)\n\tdialog_reset(self)\n\tfor i,ph,ii in stead.opairs(self.obj) do\n\t\tif ii >= start then\n\t\t\tif ii ~= start and isDelimiter(ph) then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tif isPhrase(ph) and not isDisabled(ph) and isValid(ph) then\n\t\t\t\tph.nam = stead.tostr(n)\n\t\t\t\tif stead.type(stead.phrase_prefix) == 'string' then\n\t\t\t\t\tv = stead.par('^', v, stead.cat(stead.phrase_prefix, ph:look()));\n\t\t\t\telse\n\t\t\t\t\tv = stead.par('^', v, txtnm(n, ph:look()))\n\t\t\t\tend\n\t\t\t\tn = n + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn v;\nend\n\nstead.dialog_rescan = function(self, naming, from)\n\tlocal i,k,ph,ii, start\n\tk = 0\n\tif stead.type(from) == 'number' then\n\t\tstart = from\n\telseif stead.type(from) == 'string' then\n\t\tph, start = self:phrase(from)\n\telse\n\t\tstart = phr_get(self)\n\tend\n\tfor i,ph,ii in stead.opairs(self.obj) do\n\t\tif ii >= start then\n\t\t\tif ii ~= start and isDelimiter(ph) then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tif isPhrase(ph) and not isDisabled(ph) and isValid(ph) then\n\t\t\t\tk = k + 1;\n\t\t\t\tif naming then\n\t\t\t\t\tph.nam = stead.tostr(k)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tif k == 0 then\n\t\treturn false\n\tend\n\treturn k\nend\n\nstead.dialog_enter = function(self)\n\tif self:empty(self) then\n\t\treturn nil, false\n\tend\n\treturn nil, true\nend\n\nstead.dialog_current = function(self, w, ...)\n\tlocal r = phr_get(self)\n\tif w then\n\t\tlocal ph, i = self:phrase(w)\n\t\tif ph then\n\t\t\tself.__phr_stack = { i }\n\t\tend\n\tend\n\treturn r\nend\n\nstead.dialog_curtag = function(self, w, ...)\n\tlocal p = self:phrase(phr_get(self))\n\tif w then\n\t\tself:current(w)\n\tend\n\tif not isPhrase(p) then\n\t\treturn\n\tend\n\treturn p.tag\nend\n\nstead.dialog_empty = function(self, from)\n\treturn (stead.dialog_rescan(self, false, from) == false)\nend\n\nstead.dialog_visible = function(self, from)\n\tlocal r = stead.dialog_rescan(self, false, from);\n\tif not r then r = 0 end\n\treturn r\nend\n\nstead.dialog_pjump = function(self, w)\n\tlocal ph, i = self:phrase(w)\n\tif not ph then\n\t\treturn\n\tend\n\tlocal n = #self.__phr_stack;\n\tif n == 0 then\n\t\tstead.table.insert(self.__phr_stack, i);\n\telse\n\t\tself.__phr_stack[n] = i\n\tend\n\tcall_enter(ph)\n\tstead.cctx().action = true\n\treturn\nend\n\nfunction pjump(w)\n\tif not isDialog(stead.here()) then\n\t\treturn false\n\tend\n\treturn stead.here():pjump(w)\nend\n\nstead.dialog_pstart = function(self, w)\n\tif not w then \n\t\tw = 1 \n\tend\n\tlocal ph, i = self:phrase(w)\n\tif not ph then\n\t\treturn\n\tend\n\tself.__phr_stack = { i }\n\tcall_enter(ph)\n\tstead.cctx().action = true\n\treturn\nend\n\nfunction pstart(w)\n\tif not isDialog(stead.here()) then\n\t\treturn\n\tend\n\tstead.here():pstart(w)\nend\n\nstead.dialog_psub = function(self, w)\n\tlocal ph, i = self:phrase(w)\n\tif not ph then\n\t\treturn\n\tend\n\tstead.table.insert(self.__phr_stack, i);\n\tcall_enter(ph)\n\tstead.cctx().action = true\n\treturn\nend\n\nfunction psub(w)\n\tif not isDialog(stead.here()) then\n\t\treturn false\n\tend\n\treturn stead.here():psub(w)\nend\n\nstead.dialog_pret = function(self)\n\tif not phr_pop(self) then\n\t\treturn\n\tend\n\tstead.cctx().action = true\n\tif not self:empty() then\n\t\treturn\n\tend\n\tcall_empty(self)\n\treturn\nend\n\nfunction pret()\n\tif not isDialog(stead.here()) then\n\t\treturn\n\tend\n\treturn stead.here():pret()\nend\n\nfunction phr(ask, answ, act)\n\tlocal i = 1\n\tlocal dis = false\n\t\n\tif stead.type(ask) ~= 'table' then -- old style\n\t\tlocal p = phrase ( { dsc = ask, ans = answ, code = act });\n\t\treturn p\n\tend\n\n\tlocal v = ask\n\n\tif stead.type(v[1]) == 'number' then -- just skip number\n\t\ti = i + 1\n\tend\n\n\tif stead.type(v[i]) == 'boolean' then\n\t\tdis = not v[i]\n\t\ti = i + 1\n\tend\n\n\tif v.dsc == nil then\n\t\tv.dsc = v[i];\n\t\ti = i + 1\n\tend\n\tif v.ans == nil then\n\t\tv.ans = v[i];\n\t\ti = i + 1\n\tend\n\tif v.code == nil and (stead.type(v[i]) == 'function' or stead.type(v[i]) == 'string') then\n\t\tv.code = v[i];\n\tend\n\tv = phrase(v)\n\tif dis then\n\t\tv = v:disable()\n\tend\n\treturn v;\nend\n\nfunction _phr(ask, answ, act) -- compat only?\n\tlocal p = phr(ask, answ, act);\n\tp:disable()\n\treturn p\nend\n\nstead.phr = phr\n\nstead.phrase_save = function(self, name, h, need)\n\tif need then\n\t\tlocal m = \" = phrase {\"\n\t\tlocal post = '}\\n'\n\t\tif isDisabled(self) then\n\t\t\tpost = \"}:disable()\\n\"\n\t\tend\n\t\tm = stead.string.format(\"%s%s\", name, m);\n\t\tif self.dsc then\n\t\t\tm = m..stead.string.format(\"dsc = %s, \", stead.tostring(self.dsc));\n\t\tend\n\n\t\tif self.ans then\n\t\t\tm = m..stead.string.format(\"ans = %s, \", stead.tostring(self.ans));\n\t\tend\n\n\t\tif self.code then\n\t\t\tm = m..stead.string.format(\"code = %s, \", stead.tostring(self.code));\n\t\tend\n\n\t\tif self.tag then\n\t\t\tm = m..stead.string.format(\"tag = %s, \", stead.tostring(self.tag));\n\t\tend\n\n\t\tif self.always then\n\t\t\tm = m..stead.string.format(\"always = %s, \", stead.tostring(self.always));\n\t\tend\n\n\t\tif self.empty then\n\t\t\tm = m..stead.string.format(\"empty = %s, \", stead.tostring(self.empty));\n\t\tend\n\n\t\th:write(m..post);\n\tend\n\tstead.savemembers(h, self, name, false);\nend\n\nlocal function dialog_phr2obj(self)\n\tlocal k, v, n\n\tlocal aliases = {}\n\tif stead.type(self.phr) ~= 'table' then\n\t\treturn\n\tend\n\tn = 0\n\tfor k, v in ipairs(self.phr) do\n\t\tif stead.type(v) == 'table' then\n\t\t\tif stead.type(v[1]) == 'number' then\n\t\t\t\tn = v[1]\n\t\t\telse\n\t\t\t\tn = n + 1\n\t\t\tend\n\t\t\tlocal p = stead.phr(v)\n\t\t\tif self.obj[n] then\n\t\t\t\terror (\"Error in phr structure (numbering).\", 4);\n\t\t\tend\n\t\t\tif v.alias then\n\t\t\t\tp.alias = v.alias\n\t\t\t\tstead.table.insert(aliases, n);\n\t\t\tend\n\t\t\tself.obj[n] = p\n\t\telse\n\t\t\terror (\"Error in phr structure (wrong item).\", 4);\n\t\tend\n\tend\n\tfor k, v in ipairs(aliases) do\n\t\tlocal ph = self:phrase(self.obj[v].alias)\n\t\tif not ph then\n\t\t\terror (\"Wrong alias in dlg.\", 3);\n\t\tend\n\t\tself.obj[v] = ph\n\tend\nend\n\nstead.dialog_phrase = function(self, num)\n\tif not num then\n\t\treturn\n\tend\n\tif isPhrase(num) then\n\t\treturn num\n\tend\n\tif stead.type(num) ~= 'number' then\n\t\tlocal k,v,i\n\t\tfor k,v,i in stead.opairs(self.obj) do\n\t\t\tv = stead.ref(v)\n\t\t\tif isPhrase(v) and v.tag == num then\n\t\t\t\treturn v, i\n\t\t\tend\n\t\tend\n\t\treturn nil\n\tend\n\treturn stead.ref(self.obj[num]), num;\nend\n\nstead.phrase_action = function(self)\n\tlocal ph = self;\n\tlocal r, ret;\n\tlocal empty\n\n\tif isDisabled(ph) then\n\t\treturn nil, false\n\tend\n-- here it is\n\tif not ph.always then\n\t\tph:disable(); -- /* disable it!!! */\n\tend\n\tlocal last = stead.call(ph, 'ans');\n\n\tif stead.type(ph.code) == 'string' then\n\t\tlocal f = stead.eval(ph.code);\n\t\tif f ~= nil then\n\t\t\tret = f();\n\t\telse\n\t\t\terror (\"Error while eval phrase action:\"..ph.code);\n\t\tend\n\telseif stead.type(ph.code) == 'function' then\n\t\tret = ph.code(self);\n\tend\n\n\tif ret == nil then ret = stead.pget(); end\n\n\tif last == true or ret == true then\n\t\tr = true;\n\tend\n\n\tif isDialog(stead.here()) and stead.here():empty() then\n\t\tempty = call_empty(stead.here());\n\tend\n\n\tlocal wh = stead.here();\n\n\twhile isDialog(wh) and wh:empty() and stead.from(wh) ~= wh do\n\t\twh = stead.from(wh)\n\tend\n\n\tif wh ~= stead.here() then\n\t\tret = stead.par(stead.scene_delim, ret, stead.back(wh));\n\tend\n\t\n\tret = stead.par(stead.space_delim, last, empty, ret);\n\n\tif ret == nil then\n\t\treturn r -- hack?\n\tend\n\treturn ret\nend\n\nfunction dlg(v) --constructor\n\tv.dialog_type = true;\n\tif v.ini == nil then\n\t\tv.ini = function(s)\n\t\t\tstead.dialog_rescan(s, true);\n\t\tend\n\tend\n\tif v.enter == nil then\n\t\tv.enter = stead.dialog_enter;\n\tend\n\tif v.look == nil then\n\t\tv.look = stead.dialog_look;\n\tend\n\tif v.scene == nil then\n\t\tv.scene = stead.dialog_scene;\n\tend\n\tif v.pon == nil then\n\t\tv.pon = stead.dialog_pon;\n\tend\n\tif v.poff == nil then\n\t\tv.poff = stead.dialog_poff;\n\tend\n\tif v.prem == nil then\n\t\tv.prem = stead.dialog_prem;\n\tend\n\tif v.pseen == nil then\n\t\tv.pseen = stead.dialog_pseen;\n\tend\n\tif v.punseen == nil then\n\t\tv.punseen = stead.dialog_punseen;\n\tend\n\tif v.empty == nil then\n\t\tv.empty = stead.dialog_empty;\n\tend\n\n\tif v.visible == nil then\n\t\tv.visible = stead.dialog_visible;\n\tend\n\n\tif v.current == nil then\n\t\tv.current = stead.dialog_current\n\tend\n\n\tif v.curtag == nil then\n\t\tv.curtag = stead.dialog_curtag\n\tend\n\n\tif v.pstart == nil then\n\t\tv.pstart = stead.dialog_pstart\n\tend\n\tif v.pjump == nil then\n\t\tv.pjump = stead.dialog_pjump\n\tend\n\tif v.pret == nil then\n\t\tv.pret = stead.dialog_pret\n\tend\n\tif v.psub == nil then\n\t\tv.psub = stead.dialog_psub\n\tend\n\tif v.phrase == nil then\n\t\tv.phrase = stead.dialog_phrase\n\tend\n\n\tif v.dsc == nil then\n\t\tv.dsc = function(s)\n\t\t\tif stead.player_moved() then\n\t\t\t\tstead.last_act(false)\n\t\t\telseif stead.type(ACTION_TEXT) ~= 'string' and stead.last_act() then\n\t\t\t\tstead.p(stead.last_act())\n\t\t\tend\n\t\tend\n\tend\n\n\tv = room(v);\n\n\tv.__phr_stack = { 1 }\n\tdialog_phr2obj(v);\n\n\treturn v;\nend\n","events.lua":"game.action = stead.hook(game.action, function(f, s, cmd, ...)\n\tif cmd == 'user_event' then\n\t\tlocal r,v;\n\t\tr, v = stead.call(stead, 'event', ... );\n\t\treturn r,v\n\tend\n\treturn f(s, cmd, ...);\nend)\n\nstead.module_init(function()\n\tinput.event = stead.hook(input.event, function(f, s, ev, ...)\n\t\tif type(stead.event) == 'function' then\n\t\t\treturn 'user_event,'..tostring(ev)\n\t\tend\n\t\treturn f(s, ev, ...)\n\tend)\nend)\n\n-- vim:ts=4\n","finger.lua":"require \"theme\"\n\nfinger = {\n\tnam = 'finger';\n\tobject_type = true;\n\tsystem_type = true;\n\tfingers_list = { };\n\tadd = function(s, press, fid, x, y, px, py)\n\t\tif press then\n\t\t\tlocal v = s:lookup(fid)\n\t\t\tif v then\n\t\t\t\tv.x, v.y, v.px, v.py = x, y, px, py\n\t\t\telse\n\t\t\t\tstead.table.insert(s.fingers_list, \n\t\t\t\t\t{ id = fid, x = x, y = y, px = px, py = py })\n\t\t\tend\n\t\t\treturn\n\t\tend\n\t\tlocal v, k\n\t\tv, k = s:lookup(fid)\n\t\tif k then\n\t\t\tstead.table.remove(s.fingers_list, k)\n\t\t\treturn\n\t\tend \n\tend;\n\tlist = function(s)\n\t\tlocal k,v\n\t\tlocal new = {}\n\t\tfor k,v in stead.ipairs(s.fingers_list) do\n\t\t\tlocal x, y, pressure\n\t\t\tx, y, pressure = stead.finger_pos(v.id)\n\t\t\tif x then\n\t\t\t\tv.x, v.y, v.pressure = x, y, pressure\n\t\t\t\tstead.table.insert(new, v)\n\t\t\tend\n\t\tend\n\t\ts.fingers_list = new\n\t\treturn new\n\tend;\n\tget = function(s, fid)\n\t\tlocal v,k\n\t\tlocal x, y, pressure\n\t\tx, y, pressure = stead.finger_pos(fid)\n\t\tif not x then\n\t\t\tv, k = s:lookup(fid)\n\t\t\tif k then\n\t\t\t\tstead.table.remove(s.fingers_list, k)\n\t\t\tend\n\t\t\treturn\n\t\tend\n\t\treturn x, y, pressure\n\tend;\n\tlookup = function(s, fid)\n\t\tlocal k,v\n\t\tfor k,v in stead.ipairs(s.fingers_list) do\n\t\t\tif v.id == fid then\n\t\t\t\treturn v, k\n\t\t\tend\n\t\tend\n\tend;\n}\n\nstead.module_init(function()\n\tinput.finger = function(s, press, fid, x, y, px, py, ...)\n\t\tfinger:add(press, fid, x, y, px, py, ...)\n\t\tlocal cmd = 'finger '\n\t\tcmd = cmd..stead.tostr(press)..','..stead.tostr(fid)..',' .. x .. ','.. y;\n\t\tif px then\n\t\t\tcmd = cmd .. ',' .. px .. ',' .. py\n\t\tend\n\t\treturn cmd\n\tend\nend)\n\ngame.action = stead.hook(game.action, \nfunction(f, s, cmd, press, fid, x, y, px, py, ...)\n\tif cmd == 'finger' then\n\t\tlocal r,v\n\t\tlocal x2 = px\n\t\tlocal y2 = py\n\n\t\tif stead.here().finger then\n\t\t\ts = stead.here()\n\t\tend\n\n\t\tif not s.finger then\n\t\t\treturn\n\t\tend\n\n\t\tif stead.tonum(px) then\n\t\t\tx2 = stead.tonum(px)\n\t\tend\n\n\t\tif stead.tonum(py) then\n\t\t\ty2 = stead.tonum(py)\n\t\tend\n\n\t\tif press == 'true' then\n\t\t\tpress = true\n\t\telse\n\t\t\tpress = false\n\t\tend\n\t\tr,v = stead.call(s, 'finger', press, fid, stead.tonum(x), stead.tonum(y), x2, y2, ...);\n\t\treturn r,v\n\tend\n\treturn f(s, cmd, press, fid, x, y, px, py, ...)\nend)\n-- vim:ts=4\n","format.lua":"format = {\n\tnam = 'format';\n\tobject_type = true;\n\tsystem_type = true;\n\tpara = false;\n\tpara_space = '    ';\n\tquotes = false;\n\tdash = false;\n\tfilter = nil;\n\tnopara = '_';\n\tsave = function(self, name, h, need)\n\t\tlocal k,v\n\t\tfor k,v in stead.pairs(self) do\n\t\t\tif k == 'para' or k == 'para_space' or k == 'quotes' or\n\t\t\t    k == 'dash' or k == 'nopara' then\n\t\t\t\tlocal s = stead.tostring(v)\n\t\t\t\th:write(stead.string.format(\"format[%q] = %s;\\n\", k, s))\n\t\t\tend\n\t\tend\n\tend;\n}\n\nstead.fmt = stead.hook(stead.fmt, function(f, ...)\n\tlocal utf8\n\tlocal r = f(...)\n\tif game.codepage == 'UTF-8' or game.codepage == 'utf-8' then\n\t\tutf8 = true\n\tend\n\tif stead.type(r) == 'string' and stead.state then\n\t\tif stead.type(format.filter) == 'function' and stead.state then\n\t\t\tr = format.filter(r);\n\t\tend\n\t\tif stead.call_bool(format, 'dash') and utf8 then\n\t\t\tr = r:gsub('([^-])%-%-([^-])', '%1—%2');\n\t\t\tr = r:gsub('^%-%-([^-])', '—%1');\n\t\tend\n\t\tif stead.call_bool(format, 'quotes') and utf8 then\n\t\t\tr = r:gsub('_\"','«'):gsub('\"_',\"»\");\n\t\t\tr = r:gsub('\"([^\"]*)\"','«%1»');\n\t\t\tr = r:gsub(',,','„'):gsub(\"''\",'”');\n\t\tend\n\t\tif stead.call_bool(format, 'para') then\n\t\t\tr = r:gsub('\\n([^\\n])', '<&para;>%1'):gsub('<&para;>[ \\t]*'..format.nopara,'\\n'):gsub('<&para;>[ \\t]*', '\\n'..txtnb(format.para_space));\n\t\t\tr = r:gsub('^[ \\t]*', '<&para;>'):gsub('<&para;>[ \\t]*'..format.nopara,''):gsub('<&para;>[ \\t]*', txtnb(format.para_space));\n\t\tend\n\tend\n\treturn r;\nend)\n\n-- vim:ts=4\n","gui.lua":"game.hinting = true;\ngame.showlast = true;\n\ngame.gui = { \n\tfading = 4; \n\tways_delim = ' | ';\n\tinv_delim = '\\n';\n\thinv_delim = ' | ';\n\thideways = false;\n\thideinv = false;\n\thidetitle = false;\n}\n\niface.xref = function(self, str, obj, ...)\n\tlocal o = stead.ref(obj);\n\tlocal cmd=''\n\n\tif not isObject(o) or isStatus(o) or (not o.id and not isXaction(o)) then\n\t\treturn str;\n\tend\n\n\tif stead.ref(ways():srch(obj)) then\n\t\tcmd = 'go ';\n\telseif isMenu(o) then\n\t\tcmd = 'act ';\n\telseif isSceneUse(o) then\n\t\tcmd = 'use ';\n\telseif isXaction(o) and not o.id then\n\t\tcmd = 'act ';\n\tend\n\tlocal a = ''\n\tlocal i\n\tlocal varg = {...}\n\tfor i = 1, stead.table.maxn(varg) do\n\t\ta = a..','..varg[i]\n\tend\n\tif isXaction(o) and not o.id then\n\t\treturn stead.cat('<a:'..cmd..stead.deref(obj)..a..'>',str,'</a>');\n\tend\n\treturn stead.cat('<a:'..cmd..'0'..stead.tostr(o.id)..a..'>',str,'</a>');\nend;\niface.anchor = function(self)\n\treturn '<a:#>'\nend\niface.enum = function(self, n, str)\n\tif str == nil or n == nil then return nil; end;\n\treturn n..self:nb(' - ')..str;\nend\n\niface.title = function(self, str)\n\treturn nil\nend;\n\niface.img = function(self, str)\n\tif str == nil then return nil; end;\n\treturn \"<g:\"..str..\">\";\nend;\n\niface.imgl = function(self, str)\n\tif str == nil then return nil; end;\n\treturn \"<g:\"..str..\"\\\\|left>\";\nend;\n\niface.imgr = function(self, str)\n\tif str == nil then return nil; end;\n\treturn \"<g:\"..str..\"\\\\|right>\";\nend;\n\niface.nb = function(self, str)\n\tif stead.type(str) ~= 'string' then return nil end\n\treturn \"<w:\"..str:gsub(\"\\\\\", \"\\\\\\\\\\\\\\\\\"):gsub(\">\",\"\\\\>\"):gsub(\"%^\",\"\\\\^\")..\">\";\nend;\n\niface.under = function(self, str)\n\tif str == nil then return nil; end; \n\treturn stead.cat('<u>',str,'</u>');\nend;\n\niface.em = function(self, str)\n\tif str == nil then return nil; end;\n\treturn stead.cat('<i>',str,'</i>');\nend;\n\niface.st = function(self, str)\n\tif str == nil then return nil; end;\n\treturn stead.cat('<s>',str,'</s>');\nend;\n\niface.right = function(self, str)\n\tif str == nil then return nil; end; \n\treturn stead.cat('<r>',str,'</r>');\nend;\n\niface.left = function(self, str)\n\tif str == nil then return nil; end;\n\treturn stead.cat('<l>',str,'</l>');\nend;\n\niface.center = function(self, str)\n\tif str == nil then return nil; end;\n\treturn stead.cat('<c>',str,'</c>');\nend;\n\niface.just = function(self, str)\n\tif str == nil then return nil; end;\n\treturn stead.cat('<j>',str,'</j>');\nend;\n\niface.tab = function(self, str, al)\n\tif stead.tonum(str) then\n\t\tstr = stead.tostr(str)\n\tend\n\tif stead.type(str) ~= 'string' then\n\t\treturn nil;\n\tend\n\tif al == 'right' then\n\t\tstr = str .. \",right\"\n\telseif al == 'center' then\n\t\tstr = str .. \",center\"\n\tend\n\treturn '<x:'..str..'>'\nend;\n\niface.y = function(self, str, al)\n\tif stead.tonum(str) then\n\t\tstr = stead.tostr(str)\n\tend\n\tif stead.type(str) ~= 'string' then\n\t\treturn nil;\n\tend\n\tif al == 'middle' then\n\t\tstr = str .. \",middle\"\n\telseif al == 'top' then\n\t\tstr = str .. \",top\"\n\tend\n\treturn '<y:'..str..'>'\nend;\n\niface.bold = function(self, str)\n\tif str == nil then return nil; end;\n\treturn stead.cat('<b>',str,'</b>');\nend;\n\niface.top = function(self, str)\n\tif str == nil then return nil; end;\n\treturn stead.cat('<t>',str,'</t>');\nend;\n\niface.bottom = function(self, str)\n\tif str == nil then return nil; end;\n\treturn stead.cat('<d>',str,'</d>');\nend;\n\niface.middle = function(self, str)\n\tif str == nil then return nil; end;\n\treturn stead.cat('<m>',str,'</m>');\nend;\n\niface.inv = function(self, str)\n\treturn str\nend;\n\niface.ways = function(self, str)\n\treturn str\nend;\n\ninstead.get_inv = function(horiz)\n\tlocal r = stead.call_value(game.gui, 'hideinv');\n\tif r then\n\t\treturn\n\tend\n\tlocal str = iface:cmd(\"inv\");\n\tif str then\n\t\tstr = stead.string.gsub(str, '\\n$','');\n\t\tif not horiz then\n\t\t\tstr = stead.string.gsub(str, '\\\\?['.. stead.delim ..']', \n\t\t\t\t{ [stead.delim] = game.gui.inv_delim, ['\\\\'..stead.delim] = stead.delim });\n\t\telse\n\t\t\tstr = stead.string.gsub(str, '\\\\?['.. stead.delim ..']', \n\t\t\t\t{ [stead.delim] = game.gui.hinv_delim, ['\\\\'..stead.delim] = stead.delim });\n\t\tend\n\tend\n\treturn str\nend\n\ninstead.get_ways = function()\n\tlocal r = stead.call_value(game.gui, 'hideways');\n\tif r then\n\t\treturn\n\tend\n\tlocal str = iface:cmd(\"way\");\n\tif str and str ~= '' then\n\t\tstr = stead.string.gsub(str, '\\n$','');\n\t\tstr = stead.string.gsub(str, '\\\\?['..stead.delim ..']', \n\t\t\t{ [stead.delim] = game.gui.ways_delim, [ '\\\\'..stead.delim ] = stead.delim });\n\t\treturn iface:center(str);\n\tend\n\treturn str\nend\n\ninstead.get_title = function()\n\tlocal r = stead.call_value(game.gui, 'hidetitle');\n\tif r then\n\t\treturn\n\tend\n\n\tlocal s\n\n\tif stead.api_atleast(1, 2, 0) then\n\t\ts = stead.dispof(stead.here());\n\telse\n\t\ts = stead.call(stead.here(), 'nam');\n\tend\n\tif stead.type(s) == 'string' and s ~= '' then\n\t\tstead.state = false\n\t\ts = \"<c><b>\"..stead.fmt(s)..\"</b></c>\";\n\t\ts = stead.string.gsub(s, '\\\\'..stead.delim, stead.delim);\n\tend\n\treturn s\nend\n\ninstead.finish_music = function()\n\tif instead.get_music_loop() == 0 then\n\t\treturn false\n\tend\n\tlocal n = stead.get_music()\n\tstead.set_music(n, -1);\n\treturn true\nend\n\ninstead.isEnableSave = isEnableSave;\ninstead.isEnableAutosave = isEnableAutosave;\n\n-- here is gui staff only\nfunction stat(v)\n\tv.status_type = true\n\treturn obj(v);\nend\n\nfunction isStatus(v)\n\tif stead.type(v) ~= 'table' then\n\t\treturn false\n\tend\n\tif v.status_type then\n\t\treturn true\n\tend\n\treturn false\nend\n\nstead.menu_save = function(self, name, h, need)\n\tlocal dsc;\n\tif need then\n\t\tprint (\"Warning: menu \"..name..\" can not be saved!\");\n\t\treturn\n\tend\n\tstead.savemembers(h, self, name, need);\nend\n\nMENU_TAG_ID = 1000000\n\nfunction menu(v)\n\tv.menu_type = true\n\tif v.inv == nil then\n\t\tv.inv = function(s)\n\t\t\tlocal r,v\n\t\t\tr,v = stead.call(s, 'menu');\n\t\t\tif v == nil then v = true end\n\t\t\tif r == nil then\n\t\t\t\tstead.obj_tag(stead.me(), MENU_TAG_ID); -- retag menu field\n\t\t\tend\n\t\t\treturn r, v\n\t\tend\n\tend\n\tif v.act == nil then\n\t\tv.act = function(s)\n\t\t\tlocal r,v\n\t\t\tr,v = stead.call(s, 'menu');\n\t\t\tif v == nil then v = true end\n\t\t\tif r == nil then\n\t\t\t\tstead.obj_tag(stead.me(), MENU_TAG_ID); -- retag menu field\n\t\t\tend\n\t\t\treturn r, v\n\t\tend\n\tend\n\tif v.save == nil then\n\t\tv.save = stead.menu_save;\n\tend\n\treturn obj(v);\nend\n\nfunction isMenu(v)\n\tif stead.type(v) ~= 'table' then\n\t\treturn false\n\tend\n\tif v.menu_type then\n\t\treturn true\n\tend\n\treturn false\nend\n\nstead.fmt = function(...)\n\tlocal i, res\n\tlocal a={...}\n\n\tfor i=1,stead.table.maxn(a) do\n\t\tif stead.type(a[i]) == 'string' then\n\t\t\tlocal s = stead.string.gsub(a[i],'\\t', stead.space_delim):gsub('[\\n]+', stead.space_delim);\n\t\t\ts = stead.string.gsub(s, '\\\\?[\\\\^]', { ['^'] = '\\n', ['\\\\^'] = '^',\n\t\t\t\t['\\\\\\\\'] = '\\\\' });\n\t\t\tres = stead.par('', res, s);\n\t\tend\n\tend\n\treturn res\nend\n\ngame.fading = function(s)\n\tlocal rc = false\n\tlocal p = stead.call(stead.here(), 'pic');\n\tif stead.cmd == 'load' then\n\t\tgame.lastpic = p;\n\t\treturn true\n\tend\n\tif not stead.state then --only for states!!!\n\t\treturn false\n\tend\n\tif game._time == 1 then -- first cmd\n\t\tgame.lastpic = p;\n\t\treturn true\n\tend\n\tif PLAYER_MOVED or game.lastpic ~= p then\n\t\trc = true\n\tend\n\tgame.lastpic = p\n\treturn rc\nend\n\ngame.gui.is_fading = function() --to check fading from sdl gui\n\tlocal r,g,v\n\tlocal h = stead.here()\n\tif not isRoom(h) then\n\t\treturn false\n\tend\n\tr,v = stead.call_value(h, 'fading');\n\tif r then\n\t\tif stead.tonum(r) and v == nil then\n\t\t\treturn true, stead.tonum(r)\n\t\tend\n\t\treturn r, v\n\tend\n\tg,v = stead.call_value(game, 'fading');\n\tif stead.tonum(g) and v == nil then\n\t\treturn true, stead.tonum(g)\n\tend\n\treturn g, v\nend\n\ninstead.get_fading = function()\n\tlocal r, v\n\tr, v = stead.call_value(game.gui, 'is_fading')\n\tif v == nil and r then v = game.gui.fading end\n\treturn r,v\nend\n-- vim:ts=4\n","hideinv.lua":"local attr = \"hideinv\"\nif stead.api_atleast(1, 6, 3) then\n\tgame.gui.hideinv = function(s)\n\t\tif stead.call_bool(stead.here(), 'hideinv') then\n\t\t\treturn true\n\t\tend\n\tend\n\tattr = \"noinv\"\nend\nroom = stead.inherit(room, function(v)\n\tv.entered = stead.hook(v.entered, function(f, s, ...)\n\t\tif stead.call_bool(s, attr) then\n\t\t\tme():disable_all();\n\t\tend\n\t\treturn f(s, ...)\n\tend)\n\tv.left = stead.hook(v.left, function(f, s, ...)\n\t\tif stead.call_bool(s, attr) then\n\t\t\tme():enable_all();\n\t\tend\n\t\treturn f(s, ...)\n\tend)\n\treturn v\nend)\n","hotkeys.lua":"require 'kbd'\n\nstead.module_init(function()\n\thook_keys('1','2','3','4','5','6','7','8','9','0');\nend)\n\ngame.kbd = stead.hook(game.kbd, function(f, s, down, key, ...)\n\tif down and key >= '0' and key <= '9' then\n\t\tif isDialog(stead.here()) then\n\t\t\tif key == '0' then key = '10' end\n\t\t\tlocal p = stead.here():srch(key);\n\t\t\tif p and stead.nameof(p) == key then\n\t\t\t\treturn stead.call(p, 'act');\n\t\t\tend\n\t\tend\n\t\treturn\n\tend\n\treturn f(s, down, key, ...);\nend)\n\n-- vim:ts=4\n","input.lua":"local kbden = {\n\tshifted = {\n\t[\"1\"] = \"!\",\n\t[\"2\"] = \"@\",\n\t[\"3\"] = \"#\",\n\t[\"4\"] = \"$\",\n\t[\"5\"] = \"%\",\n\t[\"6\"] = \"^\",\n\t[\"7\"] = \"&\",\n\t[\"8\"] = \"*\",\n\t[\"9\"] = \"(\",\n\t[\"0\"] = \")\",\n\t[\"-\"] = \"_\",\n\t[\"=\"] = \"+\",\n\t[\"[\"] = \"{\",\n\t[\"]\"] = \"}\",\n\t[\"\\\\\"] = \"|\",\n\t[\";\"] = \":\",\n\t[\"'\"] = \"\\\"\",\n\t[\",\"] = \"<\",\n\t[\".\"] = \">\",\n\t[\"/\"] = \"?\",\n\t}\n}\n\nlocal kbdru = {\n\t[\"q\"] = \"й\",\n\t[\"w\"] = \"ц\",\n\t[\"e\"] = \"у\",\n\t[\"r\"] = \"к\",\n\t[\"t\"] = \"е\",\n\t[\"y\"] = \"н\",\n\t[\"u\"] = \"г\",\n\t[\"i\"] = \"ш\",\n\t[\"o\"] = \"щ\",\n\t[\"p\"] = \"з\",\n\t[\"[\"] = \"х\",\n\t[\"]\"] = \"ъ\",\n\t[\"a\"] = \"ф\",\n\t[\"s\"] = \"ы\",\n\t[\"d\"] = \"в\",\n\t[\"f\"] = \"а\",\n\t[\"g\"] = \"п\",\n\t[\"h\"] = \"р\",\n\t[\"j\"] = \"о\",\n\t[\"k\"] = \"л\",\n\t[\"l\"] = \"д\",\n\t[\";\"] = \"ж\",\n\t[\"'\"] = \"э\",\n\t[\"z\"] = \"я\",\n\t[\"x\"] = \"ч\",\n\t[\"c\"] = \"с\",\n\t[\"v\"] = \"м\",\n\t[\"b\"] = \"и\",\n\t[\"n\"] = \"т\",\n\t[\"m\"] = \"ь\",\n\t[\",\"] = \"б\",\n\t[\".\"] = \"ю\",\n\t[\"`\"] = \"ё\",\n\t\n\tshifted = {\n\t[\"q\"] = \"Й\",\n\t[\"w\"] = \"Ц\",\n\t[\"e\"] = \"У\",\n\t[\"r\"] = \"К\",\n\t[\"t\"] = \"Е\",\n\t[\"y\"] = \"Н\",\n\t[\"u\"] = \"Г\",\n\t[\"i\"] = \"Ш\",\n\t[\"o\"] = \"Щ\",\n\t[\"p\"] = \"З\",\n\t[\"[\"] = \"Х\",\n\t[\"]\"] = \"Ъ\",\n\t[\"a\"] = \"Ф\",\n\t[\"s\"] = \"Ы\",\n\t[\"d\"] = \"В\",\n\t[\"f\"] = \"А\",\n\t[\"g\"] = \"П\",\n\t[\"h\"] = \"Р\",\n\t[\"j\"] = \"О\",\n\t[\"k\"] = \"Л\",\n\t[\"l\"] = \"Д\",\n\t[\";\"] = \"Ж\",\n\t[\"'\"] = \"Э\",\n\t[\"z\"] = \"Я\",\n\t[\"x\"] = \"Ч\",\n\t[\"c\"] = \"С\",\n\t[\"v\"] = \"М\",\n\t[\"b\"] = \"И\",\n\t[\"n\"] = \"Т\",\n\t[\"m\"] = \"Ь\",\n\t[\",\"] = \"Б\",\n\t[\".\"] = \"Ю\",\n\t[\"`\"] = \"Ё\",\n\t[\"1\"] = \"!\",\n\t[\"2\"] = \"@\",\n\t[\"3\"] = \"#\",\n\t[\"4\"] = \";\",\n\t[\"5\"] = \"%\",\n\t[\"6\"] = \":\",\n\t[\"7\"] = \"?\",\n\t[\"8\"] = \"*\",\n\t[\"9\"] = \"(\",\n\t[\"0\"] = \")\",\n\t[\"-\"] = \"_\",\n\t[\"=\"] = \"+\",\n\t}\n}\n\nlocal kbdlower = {\n\t['А'] = 'а',\n\t['Б'] = 'б',\n\t['В'] = 'в',\n\t['Г'] = 'г',\n\t['Д'] = 'д',\n\t['Е'] = 'е',\n\t['Ё'] = 'ё',\n\t['Ж'] = 'ж',\n\t['З'] = 'з',\n\t['И'] = 'и',\n\t['Й'] = 'й',\n\t['К'] = 'к',\n\t['Л'] = 'л',\n\t['М'] = 'м',\n\t['Н'] = 'н',\n\t['О'] = 'о',\n\t['П'] = 'п',\n\t['Р'] = 'р',\n\t['С'] = 'с',\n\t['Т'] = 'т',\n\t['У'] = 'у',\n\t['Ф'] = 'ф',\n\t['Х'] = 'х',\n\t['Ц'] = 'ц',\n\t['Ч'] = 'ч',\n\t['Ш'] = 'ш',\n\t['Щ'] = 'щ',\n\t['Ъ'] = 'ъ',\n\t['Э'] = 'э',\n\t['Ь'] = 'ь',\n\t['Ю'] = 'ю',\n\t['Я'] = 'я',\n}\n\nlocal function tolow(s)\n\tif not s then\n\t\treturn\n\tend\n\ts = s:lower();\n\tlocal xlat = kbdlower\n\tif xlat then\n\t\tlocal k,v\n\t\tfor k,v in stead.pairs(xlat) do\n\t\t\ts = s:gsub(k,v);\n\t\tend\n\tend\n\treturn s;\nend\n\nlocal function kbdxlat(s)\n\tlocal kbd\n\tif s == 'space' then\n\t\treturn ' '\n\tend\n\tif s == 'return' then\n\t\treturn '\\n'\n\tend\n\n\tif s:len() > 1 then\n\t\treturn\n\tend\n\n\tif input.kbd_alt_xlat and \n\t\t(game.codepage == 'UTF-8' or game.codepage == 'utf-8') then\n\t\tkbd = kbdru;\n\telse\n\t\tkbd = kbden\n\tend\n\n\tif kbd and input.kbd_shift then\n\t\tkbd = kbd.shifted;\n\tend\n\n\tif not kbd[s] then\n\t\tif input.kbd_shift then\n\t\t\treturn s:upper();\n\t\tend\n\t\treturn s;\n\tend\n\treturn kbd[s]\nend\n\ngame.action = stead.hook(game.action, function (f, s, cmd, ...)\n\tif cmd == 'kbd_enter' then\n\t\tlocal r,v\n\t\tif stead.here().inp_enter then\n\t\t\tr,v = stead.call(stead.here(), 'inp_enter');\n\t\telseif s.inp_enter then\n\t\t\tr,v = stead.call(s, 'inp_enter');\n\t\tend\n\t\treturn r,v -- nothing todo\n\tend\n\treturn f(s, cmd, ...)\nend)\n\nlocal lookup_inp = function()\n\tlocal i,o \n\tfor i,o in stead.opairs(objs()) do\n\t\to = stead.ref(o)\n\t\tif o._edit then\n\t\t\treturn o\n\t\tend\n\tend\nend\n\nlocal input_kbd = function(s, down, key)\n\tif not input._txt then\n\t\treturn\n\tend\n\tif key:find(\"shift\") then\n\t\tinput.kbd_shift = down\n\telseif key:find(\"alt\") then\n\t\tif down and input.inp_xlat then\n\t\t\tinput.kbd_alt_xlat = not input.kbd_alt_xlat;\n\t\tend\n\t\tinput.kbd_alt = down\n\telseif down then\n\t\tlocal o = lookup_inp();\n\t\tif not o then\n\t\t\treturn\n\t\tend\n\t\tif input.kbd_alt then\n\t\t\treturn\n\t\tend\n\t\tif key == \"return\" then\n\t\t\tif o then\n\t\t\t\to._edit = false\n\t\t\t\to._txt = input._txt\n\t\t\t\tinput._txt = false\n\t\t\t\treturn \"kbd_enter\"\n\t\t\tend\n\t\t\treturn\n\t\tend\n\t\tif key == \"backspace\" then\n\t\t\tif input._txt == '' then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tif input._txt:byte(input._txt:len()) >= 128 then\n\t\t\t\tinput._txt = input._txt:sub(1, input._txt:len() - 2);\n\t\t\telse\n\t\t\t\tinput._txt = input._txt:sub(1, input._txt:len() - 1);\n\t\t\tend\n\t\t\treturn \"wait\"\n\t\tend\n\t\tlocal c = kbdxlat(key);\n\t\tif not c then return end\n\t\tif o and stead.type(o.filter) == 'function' then\n\t\t\tc = o:filter(c);\n\t\t\tif not c then return end\n\t\tend\n\t\tinput._txt = input._txt..c;\n\t\treturn \"wait\"\n\tend\nend\n\nstead.module_init(function()\n\tinput.cursor = '_'\n\tinput.inp_xlat = true\n\tinput.key = stead.hook(input.key,\n\tfunction(f, ...)\n\t\tlocal r = input_kbd(...)\n\t\tif r then return r end\n\t\treturn f(...)\n\tend)\nend)\n\nlocal function input_esc(s)\n\tlocal rep = function(s)\n\t\treturn txtnb(s)\n\tend\n\tif not s then return end\n--\treturn s:gsub(\"\\\\\",\"\\\\\\\\\\\\\\\\\"):gsub(\">\",\"\\\\\\\\>\"):gsub(\"%^\",\"\\\\%^\"):\n\tlocal r = s:gsub(\"[^ ]+\", rep):gsub(\"[ \\t]\", rep):gsub(\"{\",\"\\\\{\"):gsub(\"}\",\"\\\\}\");\n\treturn r\nend\n\nfunction inp(n, info, txt)\n\tif stead.type(n) ~= 'string' or stead.type(info) ~= 'string' then\n\t\terror (\"Wrong parameter to inp.\", 2);\n\tend\n\tlocal v = { nam = n, _txt = '', info = info }\n\tif txt then\n\t\tv._txt = txt\n\tend\n\tv.dsc = function(s)\n\t\tif s._edit then\n\t\t\treturn s.info..input_esc(input._txt)..input.cursor\n\t\tend\n\t\treturn s.info..input_esc(s._txt)\n\tend\n\tv.text = function(s, text)\n\t\tlocal t\n\t\tif s._edit then \n\t\t\tt = input._txt \n\t\telse\n\t\t\tt = s._txt\n\t\tend\n\n\t\tif text then\n\t\t\tif s._edit then\n\t\t\t\tinput._txt = text\n\t\t\telse\n\t\t\t\ts._txt = text\n\t\t\tend\n\t\t\treturn\n\t\tend\n\t\treturn t\n\tend\n\tv.match = function(s, str)\n\t\tlocal aa = tolow(tostring(str)):gsub(\"[*]\",\".*\"):gsub(\"[?]\",\".?\");\n\t\tlocal bb = tolow(tostring(s:text()));\n\t\tif bb:find(\"^\"..aa..\"$\") then\n\t\t\treturn true\n\t\tend\n\tend\n\tv.state = function(s, t)\n\t\tlocal os = s._edit\n\t\tif t == nil then\n\t\t\treturn os\n\t\tend\n\t\ts._edit = t\n\t\tif os and  t or (not os and not t) then\n\t\t\treturn os\n\t\tend\n\t\tif s._edit then\n\t\t\tinput._txt = s._txt;\n\t\telse\n\t\t\ts._txt = input._txt\n\t\t\tinput._txt = false\n\t\tend\n\t\treturn os\n\tend;\n\tv.act = function(s)\n\t\tif input._txt and not s._edit then return true end -- somewhere else\n\t\ts:state(not s._edit)\n\t\treturn true\n\tend\n\tv.save = function(self, name, h, need)\n\t\tif need then\n\t\t\th:write(stead.string.format(\"%s = inp (%q, %q, %q);\\n\", \n\t\t\t\tname, self.nam, self.info, self._txt))\n\t\tend\n\t\tstead.savemembers(h, self, name, false);\n\tend\n\treturn obj(v)\nend\n\n-- vim:ts=4\n","kbd.lua":"game.action = stead.hook(game.action, function(f, s, cmd, ...)\n\tif cmd == 'user_kbd' then\n\t\tlocal r,v;\n\t\tif stead.here().kbd then\n\t\t\tr,v = stead.call(stead.here(), 'kbd', \n\t\t\tinput.key_event.down, input.key_event.key);\n\t\telseif s.kbd then\n\t\t\tr,v = stead.call(s, 'kbd', \n\t\t\tinput.key_event.down, input.key_event.key);\n\t\tend\n\t\tif r == nil and v == nil and not stead.api_atleast(1, 3, 5) then\n\t\t\treturn nil, true\n\t\tend\n\t\treturn r,v\n\tend\n\treturn f(s, cmd, ...);\nend)\n\nstead.module_init(function()\n\tinput.key = stead.hook(input.key, function(f, s, down, key, ...)\n\t\tif input._key_hooks[key] then\n\t\t\tinput.key_event = { key = key, down = down };\n\t\t\treturn 'user_kbd'\n\t\tend\n\t\treturn f(s, down, key, ...)\n\tend)\n\tinput._key_hooks = {}\nend)\n\nstead.hook_keys = function(...)\n\tlocal i\n\tlocal a = {...};\n\tfor i = 1, stead.table.maxn(a) do\n\t\tinput._key_hooks[tostring(a[i])] = true;\n\tend\nend\n\nstead.unhook_keys = function(...)\n\tlocal i\n\tlocal a = {...};\n\tfor i = 1, stead.table.maxn(a) do\n\t\tinput._key_hooks[tostring(a[i])] = nil;\n\tend\nend\n\nhook_keys = stead.hook_keys\nunhook_keys = stead.unhook_keys\n-- vim:ts=4\n","nolife.lua":"game.life = stead.hook(game.life, function(f, ...)\n\tif stead.call_bool(stead.here(), 'nolife') then\n\t\treturn\n\tend\n\treturn f(...)\nend)\n","nouse.lua":"game.use = function(s, w, o)\n\tlocal r, v\n\tr, v = stead.call(w, 'nouse', o);\n\tif not r and not v then\n\t\tr, v = stead.call(o, 'noused', w);\n\tend\n\tif not r and not v then\n\t\tr, v = stead.call(s, 'nouse', w, o)\n\tend\n\treturn r, v\nend\n","object.lua":"local function onevent(ev, ...)\n\tlocal vv, r\n\tif stead.api_atleast(1, 6, 3) then\n\t\tvv, r = stead.call(game, ev, ...);\n\t\tif r == false then\n\t\t\treturn vv, false\n\t\tend\n\t\tif vv == false then\n\t\t\treturn nil, false\n\t\tend\n\t\treturn vv\n\tend\nend\n\nstead.player_action = function(self, what, ...)\n\tlocal v,r,obj,vv\n\n\tif isXaction(what) then -- already xact\n\t\tobj = what\n\telse\n\t\tobj = _G[what];\n\tend\n\tif not isXaction(obj) then\n\t\tobj = stead.ref(self.where):srch(what);\n\tend\n\tif not obj then\n\t\treturn stead.call(game, 'action', what, ...); --player_do(self, what, ...);\n\tend\n\tvv, r = onevent('onact', obj, ...);\n\tif vv == false then\n\t\treturn\n\tend\n\tif r == false then \n\t\treturn vv\n\tend\n\tv, r = stead.player_take(self, what, ...);\n\tif not v and not r then\n\t\tv, r = stead.call(obj, 'act', ...);\n\t\tif stead.type(vv) == 'string' then\n\t\t\tv = stead.par(stead.space_delim, vv, v);\n\t\tend\n\t\tif not v and not r then\n\t\t\tv, r = stead.call(game, 'act', obj, ...);\n\t\tend\n\telseif stead.type(vv) == 'string' then\n\t\tv = stead.par(stead.space_delim, vv, v);\n\tend\n\treturn v, r;\nend\n\n\nstead.player_use = function(self, what, onwhat, ...)\n\tlocal obj, obj2, v, vv, r;\n\tlocal scene_use_mode = false\n\n\tobj = _G[what];\n\n\tif isXaction(obj) then -- use xact is act\n\t\treturn self:action(obj, onwhat, ...)\n\tend\n\n\tobj = self:srch(what); -- in inv?\n\n\tif not obj then -- no\n\t\tobj = stead.ref(self.where):srch(what); -- in scene?\n\t\tif not obj then -- no!\n\t\t\treturn game.err, false;\n\t\tend\n\t\tscene_use_mode = true -- scene_use_mode!\n\tend\n\n\tobj = stead.ref(obj);\n\tif onwhat == nil then -- only one?\n\t\tif scene_use_mode then\n\t\t\treturn self:action(what, ...); -- call act\n\t\tend\n\t\tvv, r = onevent('oninv', obj, ...);\n\t\tif vv == false then\n\t\t\treturn\n\t\tend\n\t\tif r == false then\n\t\t\treturn vv\n\t\tend\n\t\tv, r = stead.call(obj, 'inv', ...); -- call inv\n\t\tif stead.type(vv) == 'string' then\n\t\t\tv = stead.par(stead.space_delim, vv, v);\n\t\tend\n\t\tif not v and not r then\n\t\t\tv, r = stead.call(game, 'inv', obj, ...);\n\t\tend\n\t\treturn v, r;\n\tend\n\tobj2 = stead.ref(self.where):srch(onwhat); -- in scene?\n\tif not obj2 then\n\t\tobj2 = self:srch(onwhat); -- in inv?\n\tend\n\tif not obj2 then\n\t\treturn game.err, false;\n\tend\n\t\n\tobj2 = stead.ref(obj2)\n\n\tif not scene_use_mode or isSceneUse(obj) then\n\t\tvv, r = onevent('onuse', obj, obj2, ...);\n\t\tif vv == false then\n\t\t\treturn\n\t\tend\n\t\tif r == false then \n\t\t\treturn vv \n\t\tend\n\t\tv, r = stead.call(obj, 'use', obj2, ...);\n\t\tif stead.type(vv) == 'string' then\n\t\t\tv = stead.par(stead.space_delim, vv, v);\n\t\tend\n\t\tif r ~= false then\n\t\t\tvv = stead.call(obj2, 'used', obj, ...);\n\t\t\tif stead.type(vv) == 'string' then\n\t\t\t\tv = stead.par(stead.space_delim, v, vv);\n\t\t\tend\n\t\tend\n\tend\n\tif v == nil and vv == true and stead.api_atleast(1, 7, 1) then\n\t\tv = true\n\tend\n\tif not v then\n\t\tv, r = stead.call(game, 'use', obj, obj2, ...);\n\tend\n--\tif v == nil and stead.api_version >= \"1.3.5\" then\n--\t\treturn true\n--\tend\n\treturn v\nend\n\nstead.vobj_save = function(self, name, h, need)\n\tlocal w = stead.deref(self.where)\n\tlocal dsc = self.dsc\n\t\n\tif need then\n\t\th:write(stead.string.format(\"%s  = vobj(%s,%s,%s);\\n\",\n\t\t\tname, \n\t\t\tstead.tostring(self.nam), \n\t\t\tstead.tostring(dsc), \n\t\t\tstead.tostring(w)));\n\tend\n\tstead.savemembers(h, self, name, false);\nend\n\nstead.vobj_act = function(self, ...)\n\tlocal o, r = stead.here():srch(self); -- self.nam\n\tif stead.ref(o) and stead.ref(o).where then\n\t\treturn stead.walk(stead.ref(o).where);\n\tend\n\treturn stead.call(stead.ref(r),'act', self.nam, ...);\nend\n\nstead.vobj_used = function(self, ...)\n\tlocal o, r = stead.here():srch(self.nam);\n\treturn stead.call(stead.ref(r),'used', self.nam, ...);\nend\n\nstead.vobj_use = function(self, ...)\n\tlocal o, r = stead.here():srch(self.nam);\n\treturn stead.call(stead.ref(r),'use', self.nam, ...);\nend\n\nfunction vobj(name, dsc, w)\n\treturn obj{ nam = stead.tostr(name), \n\t\tvobject_type = true,\n\t\tdsc = dsc, \n\t\twhere = stead.deref(w), \n\t\tact = stead.vobj_act, \n\t\tused = stead.vobj_used, \n\t\tuse = stead.vobj_use,\n\t\tsave = stead.vobj_save };\nend\n\nfunction vway(name, dsc, w)\n--\to.object_type = true;\n\treturn  obj{ nam = stead.tostr(name), \n\t\tvobject_type = true,\n\t\tdsc = dsc, \n\t\tact = stead.vobj_act, \n\t\twhere = stead.deref(w), \n\t\tused = stead.vobj_used,\n\t\tuse = stead.vobj_use, \n\t\tsave = stead.vobj_save };\nend\n\nfunction isVobject(v)\n\treturn (stead.type(v) == 'table') and (v.vobject_type)\nend\n\nstead.list_check = function(self, name) -- force using of objects, instead refs\n\tlocal i, v, ii;\n\tfor i,v,ii in stead.opairs(self) do\n\t\tlocal o = stead.ref(v);\n\t\tif not isObject(o) then \n\t\t\terror (stead.string.format(\"Wrong object: %q (%s) at %s\", \n\t\t\t\tstead.tostr(v), stead.tostr(stead.type(v)),\n\t\t\t\tname ..\"[\"..stead.tostr(ii)..\"]\"));\n\t\t\treturn false\n\t\tend\n\t\tif (v.auto_allocated and not stead.ref(v.key_name)) -- renew\n\t\t\tor (isObject(stead.deref(v)) and not v._dynamic_type) then -- no named object!\n\t\t\tlocal n = stead.string.format(\"%s[%d]\", name, ii);\n\t\t\tv = allocator:new(n, n);\n\t\t\tself[ii] = v;\n\t\t\tv.auto_allocated = true;\n\t\t\tfor_each(v, n, stead.check_list, isList, stead.deref(v));\n\t\telse\n\t\t\tself[ii] = o;\n\t\tend\n\tend\n\treturn true; \nend\n\nstead.list_add = function(self, name, pos)\n\tlocal nam = name\n\tif stead.initialized then\n\t\tnam = stead.ref(name);\n\tend\n\tif not nam then\n\t\terror (\"Add wrong object to list: \"..stead.tostr(name), 2);\n\tend\n\tif self:look(nam) then\n\t\treturn nil\n\tend\n\tself.__modified__ = true;\n\tif isObject(stead.deref(nam)) then\n\t\tnam._dynamic_type = true\n\tend\n\tif stead.tonum(pos) then\n\t\tpos = stead.tonum(pos)\n\t\tif pos <= #self then\n\t\t\tstead.table.insert(self, pos, nam);\n\t\telse\n\t\t\tself[pos] = nam; -- for spare lists\n\t\tend\n\telse\n\t\tstead.table.insert(self, nam);\n\tend\n\treturn true\nend\n\nstead.list_set = function(self, name, pos)\n\tlocal nam = name\n\tlocal i = stead.tonum(pos);\n\tif not i then\n\t\treturn nil\n\tend\n\tif stead.initialized then\n\t\tnam = stead.ref(name);\n\tend\n\tif not nam then\n\t\terror (\"Set wrong object in list: \"..stead.tostr(name), 2);\n\tend\n\tif isObject(stead.deref(nam)) then\n\t\tnam._dynamic_type = true\n\tend\n\tself.__modified__ = true;\n\tself[i] = nam; -- for spare lists\n\treturn true\nend\n\nstead.list_concat = function(self, other, pos)\n\tlocal n,o,ii\n\tfor n,o,ii in stead.opairs(other) do\n\t\to = stead.ref(o);\n\t\tif pos == nil then\n\t\t\tself:add(o);\n\t\telse \n\t\t\tself:add(o, pos);\n\t\t\tpos = pos + 1;\n\t\tend\n\tend\nend\n\nstead.delim = '|'\n\nstead.list_str = function(self)\n\tlocal i, v, vv, o;\n\tfor i,o in stead.opairs(self) do\n\t\to = stead.ref(o);\n\t\tif isObject(o) and not isDisabled(o) then\n\t\t\tvv = stead.dispof(o)\n\t\t\tvv = stead.xref(vv, o);\n\t\t\tv = stead.par(stead.delim, v, vv);\n\t\tend\n\tend\n\treturn v;\nend\n\nstead.obj_str = function(self)\n\tlocal i, v, vv, o;\n\tif not isObject(self) then\n\t\treturn\n\tend\n\tif isDisabled(self) then\n\t\treturn \n\tend\n\tfor i,o in stead.opairs(self.obj) do\n\t\to = stead.ref(o);\n\t\tif isObject(o) and not isDisabled(o) then\n\t\t\tvv = stead.dispof(o)\n\t\t\tvv = stead.xref(vv, o);\n\t\t\tv = stead.par(stead.delim, v, vv, stead.obj_str(o));\n\t\tend\n\tend\n\treturn v;\nend\n\nfunction path(w, wh) -- search in way, disabled too\n\tif not wh then\n\t\twh = stead.here();\n\telse\n\t\twh = stead.ref(wh);\n\tend\n\tlocal o = ways(wh):srch(w, true);\n\to = stead.ref(o);\n\tif isRoom(o) then\n\t\treturn o\n\tend\n\treturn nil\nend\n\ngame.lifes = list(game.lifes)\nstead:init(); -- reinit ob\n\n-- vim:ts=4\n","para.lua":"require \"format\"\nformat.para = true\n","prefs.lua":"prefs = obj {\n\tnam = 'preferences',\n\tsystem_type = true,\n\tload = function(s)\n\t\tlocal name = instead_savepath() .. '/prefs';\n\t\tlocal f, err = loadfile(name);\n\t\tif not f then return nil end\n\t\tf();\n\tend,\n\tini = function(s)\n\t\treturn s:load()\n\tend,\n\tstore = function(s)\n\t\ts:save()\n\t\tstead.clearvar(s);\n\tend,\n\tsave = function(s) -- save prefs on every save\n\t\tlocal name = instead_savepath() .. '/prefs';\n\t\tlocal name_tmp = name..'.tmp'\n\t\tlocal h = stead.io.open(name_tmp, \"wb\");\n\t\tif not h then return false end\n\t\tstead.savemembers(h, s, 'prefs', true);\n\t\th:flush();\n\t\th:close();\n\t\tstead.os.remove(name);\n\t\tstead.os.rename(name_tmp, name);\n\tend,\n\tpurge = function(s)\n\t\tlocal name = instead_savepath() .. '/prefs';\n\t\tlocal k,v\n\t\tfor k,v in stead.pairs(s) do\n\t\t\tif stead.type(v) ~= 'function' and k ~= 'nam' and k ~= 'system_type' then\n\t\t\t\ts[k] = nil\n\t\t\tend\n\t\tend\n\t\treturn stead.os.remove(name);\n\tend\n};\n\n-- vim:ts=4\n","proxymenu.lua":"stead.menu_prefix = '   '\n\nlocal mpar = function(v, vv, rc) \t\t\n\tif stead.type(v) == 'string' or stead.type(vv) == 'string' then\n\t\treturn stead.par(stead.space_delim, v, vv);\n\telseif v == true or vv == true then\n\t\treturn true\n\tend\n\treturn rc\nend\n\nlocal call = function(o, m, ...)\n\tlocal rc = nil\n\tlocal v, r = stead.call(o, m, ...); \n\tif r == false or v == false then\n\t\trc = false\n\telseif r or v then \n\t\trc = true \n\tend\n\treturn v, r, rc\nend\n\nstead.obj_proxy = function(o, act, use_mode, used_act, useit_act)\n\tlocal v = {};\n\tv.proxy_type = true;\n\n\tlocal d = stead.dispof(o);\n\n\tif stead.type(d) == 'string' then\n\t\tv.nam = stead.menu_prefix..d;\n\tend\n\n\tif inv():srch(o) then\n\t\tv.nam = txtem(v.nam);\n\tend\n\n\tif not v.nam then\n\t\tv.nam = true\n\tend\n\n\tv.pobj = o;\n\tv.pact = act;\n\tv.use_mode = use_mode;\n\tv.used_act = used_act;\n\tv.useit_act = useit_act;\n\n\tv.save = function(self, name, h, need)\n\t\tif need then\n\t\t\th:write(stead.string.format(name..\" = stead.obj_proxy(%s, %s, %s, %s, %s);\\n\", \n\t\t\t\tstead.tostring(self.pobj), \n\t\t\t\tstead.tostring(self.pact),  \n\t\t\t\tstead.tostring(self.use_mode),\n\t\t\t\tstead.tostring(self.used_act),\n\t\t\t\tstead.tostring(self.useit_act)));\n\t\tend\n\t\tstead.savemembers(h, self, name, false);\n\tend\n\n\tif use_mode then\n\t\tv.use = function(s, w)\n\t\t\tif w.proxy_type then\n\t\t\t\tlocal v, r, vv, rr, rc = false, ri\n\t\t\t\tlocal act = s.pact\n\t\t\t\tv, r, ri = call(game, 'before_'..act, s.pobj, w.pobj);\n\t\t\t\trc = ri or rc\n\t\t\t\tif ri == false then \n\t\t\t\t\treturn v, false \n\t\t\t\tend\n\t\t\t\tvv, r, ri = call(s.pobj, act, w.pobj);\n\t\t\t\trc = ri or rc\n\t\t\t\tv = mpar(v, vv, rc);\n\n\t\t\t\tif ri == false then\n\t\t\t\t\treturn v, false\n\t\t\t\tend\n\n\t\t\t\tif stead.type(s.used_act) == 'string' \n\t\t\t\t\tand ri == nil then -- used only if use did nothing\n\t\t\t\t\tvv, r, ri = call(w.pobj, s.used_act, s.pobj);\n\t\t\t\t\trc = ri or rc\n\t\t\t\t\tv = mpar(v, vv, rc);\n\n\t\t\t\t\tif ri == false then\n\t\t\t\t\t\treturn v, false\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\tif ri then\n\t\t\t\t\tvv, rr, ri = call(game, 'after_'..act, s.pobj, w.pobj);\n\t\t\t\t\trc = rc or ri\n\t\t\t\t\tv = mpar(v, vv, rc);\n\n\t\t\t\t\tif ri == false then\n\t\t\t\t\t\treturn v, false\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\tif v == nil then\n\t\t\t\t\tv = stead.call(game, act, s.pobj, w.pobj);\n\t\t\t\tend\n\n\t\t\t\treturn v, false;\n\t\t\tend\n\t\tend\n\tend\n\n\tv.inv = function(s)\n\t\tlocal v, r, vv, rr, rc = false, ri\n\t\tlocal act = s.pact\n\t\tif s.use_mode then\n\t\t\tact = s.useit_act\n\t\t\tif stead.type(act) ~= 'string' then\n\t\t\t\treturn nil\n\t\t\tend\n\t\tend\n\n\t\tv, r, ri = call(game, 'before_'..act, s.pobj); \n\t\trc = rc or ri\n\t\tif ri == false then\n\t\t\treturn v\n\t\tend\n\n\t\tvv, r, ri = call(s.pobj, act); \n\t\trc = rc or ri\n\t\tv = mpar(v, vv, rc)\n\n\t\tif ri == false then\n\t\t\treturn v\n\t\tend\n\n\t\tif ri then\n\t\t\tvv, rr, ri = call(game, 'after_'..act, s.pobj); \n\t\t\trc = rc or ri\n\t\t\tv = mpar(v, vv, rc);\n\t\tend\n\t\tif v == nil then\n\t\t\tv = stead.call(game, act, s.pobj);\n\t\tend\n\n\t\treturn v, rc;\n\tend\n\n\tif use_mode then\n\t\treturn obj(v)\n\tend\n\treturn menu(v)\nend\n\nstead.proxy_fill_objs = function(s, w, act, use_mode, used_act, useit_act)\n\tlocal ii,i,o\n\tlocal rc = false\n\tfor i,o,ii in stead.opairs(w) do\n\t\to = stead.ref(o);\n\t\tif isObject(o) and not isDisabled(o) and o ~= s and not isPhrase(o) \n\t\t\tand not o.proxy_type and not isStatus(o) then\n\n\t\t\ts.obj:add(stead.obj_proxy(o, act, use_mode, used_act, useit_act));\n\t\t\tif not isRoom(o) then\n\t\t\t\tstead.proxy_fill_objs(s, o.obj, act, use_mode, used_act, useit_act);\n\t\t\tend\n\t\t\trc = true\n\t\tend\n\tend\n\treturn rc\nend \n\nlocal select_only = function(s)\n\tlocal k, o, i\n\tfor k,o in stead.opairs(stead.me().obj) do\n\t\to = stead.ref(o)\n\t\tif o.action_type and o._state and o ~= s then\n\t\t\to:inv();\n\t\tend\n\tend\n\tstead.obj_tag(stead.me(), MENU_TAG_ID);\nend\n\n\nlocal proxy_menu = function(nam, act, _scene, _inv, _way, use_mode, used_act, useit_act, _ifhave)\n\tlocal v = { };\n\tif stead.type(act) ~= 'string' then\n\t\terror(\"Wrong parameter to proxy_menu.\", 3)\n\tend\n\tif null[act] then\n\t\terror(stead.tostring(act)..\"is a reserved handler. Do not use it.\", 3)\n\tend\n\n\tif used_act and null[used_act] then\n\t\terror(stead.tostring(used_act)..\"is a reserved handler. Do not use it.\", 3)\n\tend\n\n\tif useit_act and null[useit_act] then\n\t\terror(stead.tostring(useit_act)..\"is a reserved handler. Do not use it.\", 3)\n\tend\n\n\tv.action_type = true;\n\tv._state = false;\n\tv.nam = nam;\n\tv.disp = function(s)\n\t\tlocal n = stead.call(s, 'nam')\n\t\tif s._state then\n\t\t\treturn txtu(txtnb(n));\n\t\tend\n\t\treturn txtnb(n);\n\tend\n\n\tv.fill_scene = _scene;\n\tv.fill_inv = _inv;\n\tv.fill_ifhave = _ifhave;\n\tv.fill_way = _way;\n\n\tv.gen = function(s)\n\t\tlocal k,o,i\n\t\tlocal rc = false\n\t\ts.obj:zap();\n\t\tif s.fill_inv then\n\t\t\trc = stead.proxy_fill_objs(s, inv(), act, use_mode, used_act, useit_act);\n\t\tend\n\t\tif not s.fill_ifhave or rc then\n\t\t\tif s.fill_scene then\n\t\t\t\tstead.proxy_fill_objs(s, stead.here().obj, act, use_mode, used_act, useit_act);\n\t\t\tend\n\t\tend\n\t\tif s.fill_way then\n\t\t\tstead.proxy_fill_objs(s, stead.here().way, act, use_mode, used_act, useit_act);\n\t\tend\n\t\tselect_only(s);\n\tend\n\tv.inv = function(s)\n\t\tlocal i,o\n\t\tlocal k,v\n\t\ts._state = not s._state \n\t\tif s._state then\n\t\t\ts:gen();\n\t\telse\n\t\t\ts.obj:zap();\n\t\tend\n\t\treturn nil, true -- to say instead, do not redraw scene, only inv ;)\n\tend\n\treturn menu(v);\nend\n\nlocal function gen_actions(s)\n\tlocal k, o\n\tfor k, o in stead.opairs(stead.me().obj) do\n\t\to = stead.ref(o)\n\t\tif o.action_type and o._state then\n\t\t\to:gen();\n\t\tend\n\tend\nend\n\nact_menu = function(nam, act)\n\tlocal v = { };\n\tv.action_type = true;\n\tv.nam = nam;\n\tv.gen = function(s)\n\tend\n\tv.inv = function(s)\n\t\tlocal v, r \n\t\tv, r = stead.call(game, act);\n\t\treturn v, r\n\tend\n\treturn menu(v);\nend\n\nobj_menu = function(nam, act, _scene, _inv, _way)\n\treturn proxy_menu(nam, act, _scene, _inv, _way)\nend\n\nuse_menu = function(nam, act, used_act, useit_act, _scene, _inv, _ifhave)\n\treturn proxy_menu(nam, act, _scene, _inv, false, true, used_act, useit_act, _ifhave)\nend\n\ninv = function(s)\n    return stead.me().inventory;\nend\n\ngame.onuse = function(s, v, w) -- do not let use on non proxy obj\n\tif not v.proxy_type and not w.proxy_type then\n\t\treturn\n\tend\n\tif not v.proxy_type or not w.proxy_type then\n\t\treturn false\n\tend\nend\n\nplayer = stead.inherit(player, function(v)\n\tv.inv = function(s)\n\t\tgen_actions(s);\n\t\treturn stead.player_inv(s);\n\tend\n\tv.inventory = list {}\n\treturn v\nend)\n\npl = player(pl) -- reinit\n-- vim:ts=4\n","quotes.lua":"require \"format\"\nformat.quotes = true\n","snapshots.lua":"game._snapshots = {}\nstead.make_snapshot = function(nr)\n\tif not stead.tonum(nr) then nr = 0 end\n\tlocal h = { };\n\th.txt = ''\n\th.write = function(s, ...)\n\t\tlocal i\n\t\tlocal a = {...};\n\t\tfor i = 1, stead.table.maxn(a) do\n\t\t\ts.txt = s.txt .. stead.tostr(a[i]);\n\t\tend\n\tend\n\tlocal old = game._snapshots; game._snapshots = nil\n\tstead.do_savegame(game, h);\n\tgame._snapshots = old\n\tgame._snapshots[nr] = h.txt;\nend\n\nfunction isSnapshot(nr)\n\tif not stead.tonum(nr) then nr = 0 end\n\treturn (game._snapshots[nr] ~= nil)\nend\n\nstead.restore_snapshot = function (nr)\n\tif not stead.tonum(nr) then nr = 0 end\n\tlocal ss = game._snapshots\n\tif not ss[nr] then return nil, true end -- nothing todo\n\tlocal i,v\n\n\tif stead.api_atleast(1, 7, 1) then\n\t\tstead.gamereset(\"main.lua\", true);\n\telse\n\t\tstead.gamefile(\"main.lua\", true);\n\tend\n\n\tlocal f, err = stead.eval(ss[nr]..' ');\n\tif not f then return end\n\tlocal i,r = f();\n\tgame._snapshots = ss\n\tif r then\n\t\treturn nil, false\n\tend\n\n\ti = stead.do_ini(game, true);\n\n\tif stead.api_atleast(1, 7, 1) then\n\t\tgame:start()\n\t\tstead.started = true\n\t\tPLAYER_MOVED = true -- force fading\n\tend\n\n\tRAW_TEXT = true\n--\tdelete_snapshot(nr);\n\tif stead.cctx() then\n\t\tstead.pr(i)\n\tend\n\treturn i;\nend\n\nstead.delete_snapshot = function(nr)\n\tif not stead.tonum(nr) then nr = 0 end\n\tgame._snapshots[nr] = nil\nend\n\nfunction make_snapshot(nr)\n\tif stead.type(nr) ~= 'number' then\n\t\tnr = 0\n\tend\n\tMAKE_SNAPSHOT = nr\nend\n\nfunction restore_snapshot(nr)\n\treturn stead.restore_snapshot(nr)\nend\n\nfunction delete_snapshot(nr)\n\treturn stead.delete_snapshot(nr);\nend\n\niface.cmd = stead.hook(iface.cmd, function(f, ...)\n\tlocal r,v = f(...);\n\tif MAKE_SNAPSHOT ~= nil then\n\t\tstead.make_snapshot(MAKE_SNAPSHOT);\n\t\tMAKE_SNAPSHOT = nil\n\tend\n\treturn r,v\nend)\n-- vim:ts=4\n","sound.lua":"stead.sound_load = instead_sound_load\nstead.sound_free = instead_sound_free\nstead.sounds_free = instead_sounds_free\nstead.sound_channel = instead_sound_channel\nstead.sound_volume = instead_sound_volume\nstead.sound_panning = instead_sound_panning\n\nsound = {\n\tnam = 'sound';\n\tobject_type = true;\n\tsystem_type = true;\n\tload = function(fname)\n\t\treturn stead.sound_load(fname);\n\tend;\n\tfree = function(key)\n\t\treturn stead.sound_free(key);\n\tend;\n\tplay = function(key, ...)\n\t\treturn stead.add_sound(key, ...)\n\tend;\n\tstop = function(...)\n\t\tstead.stop_sound(...);\n\tend;\n\tplaying = function(s,...)\n\t\tif stead.type(s) ~= 'number' then\n\t\t\treturn stead.is_sound()\n\t\tend\n\t\treturn stead.sound_channel(s,...)\n\tend;\n\tpan = function(c, l, r, ...)\n\t\treturn stead.sound_panning(c, l, r, ...)\n\tend;\n\tvol = function(v, ...)\n\t\treturn stead.sound_volume(v, ...)\n\tend\n}\n\nstead.module_init(function()\n\tstead.sounds_free();\nend)\n","sprites.lua":"require \"theme\"\n\nstead.font_load = instead_font_load\nstead.font_free = instead_font_free\nstead.font_scaled_size = instead_font_scaled_size\nstead.sprite_alpha = instead_sprite_alpha\nstead.sprite_dup = instead_sprite_dup\nstead.sprite_scale = instead_sprite_scale\nstead.sprite_rotate = instead_sprite_rotate\nstead.sprite_text = instead_sprite_text\nstead.sprite_text_size = instead_sprite_text_size\nstead.sprite_draw = instead_sprite_draw\nstead.sprite_copy = instead_sprite_copy\nstead.sprite_compose = instead_sprite_compose\nstead.sprite_fill = instead_sprite_fill\nstead.sprite_pixel = instead_sprite_pixel\nstead.sprite_load = instead_sprite_load\nstead.sprite_free = instead_sprite_free\nstead.sprite_size = instead_sprite_size\nstead.sprites_free = instead_sprites_free\nstead.sprite_colorkey = instead_sprite_colorkey\n\nsprite = {\n\tnam = 'sprites';\n\tobject_type = true;\n\tsystem_type = true;\n\n\tscreen = function(s)\n\t\tif theme.get 'scr.gfx.mode' ~= 'direct' then\n\t\t\treturn\n\t\tend\n\t\treturn 'screen'\n\tend;\n\n\tfont_scaled_size = function(size)\n\t\treturn stead.font_scaled_size(size);\n\tend;\n\tfont = function(font, size, ...)\n\t\treturn stead.font_load(font, size, ...);\n\tend;\n\tfree_font = function(font)\n\t\treturn stead.font_free(font);\n\tend;\n\tfont_height = function(font)\n\t\tlocal w,h = stead.sprite_text_size(font)\n\t\treturn h\n\tend;\n\talpha = function(name, alpha, ...)\n\t\treturn stead.sprite_alpha(name, alpha, ...);\n\tend;\n\tcolorkey = function(name, color, ...)\n\t\treturn stead.sprite_colorkey(name, color, ...);\n\tend;\n\tdup = function(name, ...)\n\t\treturn stead.sprite_dup(name, ...);\n\tend;\n\tscale = function(name, xs, ys, smooth, ...)\n\t\tif smooth == nil then\n\t\t\tsmooth = true -- default is on\n\t\tend\n\t\treturn stead.sprite_scale(name, xs, ys, smooth,...);\n\tend;\n\trotate = function(name, angle, smooth, ...)\n\t\tif smooth == nil then\n\t\t\tsmooth = true -- default is on\n\t\tend\n\t\treturn stead.sprite_rotate(name, angle, smooth, ...);\n\tend;\n\ttext = function(font, text, col, style, ...)\n\t\treturn stead.sprite_text(font, text, col, style, ...);\n\tend;\n\tsize = function(spr)\n\t\treturn stead.sprite_size(spr);\n\tend;\n\ttext_size = function(fnt, spr)\n\t\treturn stead.sprite_text_size(fnt, spr);\n\tend;\n\tdraw = function(s, fx, fy, fw, fh, d, x, y, alpha)\n\t\tif d == nil and x == nil and y == nil then\n\t\t\treturn stead.sprite_draw(s, 0, 0, -1, -1, fx, fy, fw, fh);\n\t\tend\n\t\treturn stead.sprite_draw(s, fx, fy, fw, fh, d, x, y, alpha);\n\tend;\n\tcopy = function(s, fx, fy, fw, fh, d, x, y, alpha)\n\t\tif d == nil and x == nil and y == nil then\n\t\t\treturn stead.sprite_copy(s, 0, 0, -1, -1, fx, fy, fw, fh);\n\t\tend\n\t\treturn stead.sprite_copy(s, fx, fy, fw, fh, d, x, y, alpha);\n\tend;\n\tcompose = function(s, fx, fy, fw, fh, d, x, y, alpha)\n\t\tif d == nil and x == nil and y == nil then\n\t\t\treturn stead.sprite_compose(s, 0, 0, -1, -1, fx, fy, fw, fh);\n\t\tend\n\t\treturn stead.sprite_compose(s, fx, fy, fw, fh, d, x, y, alpha);\n\tend;\n\tfill = function(d, x, y, w, h, col)\n\t\tif h == nil and col == nil then\n\t\t\treturn stead.sprite_fill(d, 0, 0, -1, -1, x);\n\t\tend \n\t\treturn stead.sprite_fill(d, x, y, w, h, col);\n\tend;\n\tpixel = function(d, x, y, col, alpha)\n\t\treturn stead.sprite_pixel(d, x, y, col, alpha)\n\tend;\n\tload = function(fname, ...)\n\t\treturn stead.sprite_load(fname, ...);\n\tend;\n\tblank = function(w, h, ...)\n\t\tlocal t = 'blank:'..stead.tostr(w)..'x'..stead.tostr(h)\n\t\treturn stead.sprite_load(t, ...)\n\tend;\n\tbox = function(w, h, col, alpha, ...)\n\t\tlocal t = 'box:'..stead.tostr(w)..'x'..stead.tostr(h)\n\t\tif col then\n\t\t\tt = t..','..stead.tostr(col)\n\t\tend\n\t\tif alpha then\n\t\t\tt = t..','..stead.tostr(alpha)\n\t\tend\n\t\treturn stead.sprite_load(t, ...)\n\tend;\n\tfree = function(key)\n\t\treturn stead.sprite_free(key);\n\tend;\n}\n\nstead.module_init(function()\n\tstead.sprites_free();\nend)\n","stead.lua":"stead = {\n\tversion = \"2.4.1\",\n\tapi_version = \"1.1.6\", -- last version before 1.2.0\n\ttable = table,\n\tdelim = ',',\n\tbusy = instead_busy,\n\tscene_delim = \"^^\",\n\tspace_delim = ' ',\n\tstring = string,\n\ttostr = tostring,\n\ttonum = tonumber,\n\ttype = type,\n\tipairs = ipairs,\n\tpairs = pairs, \n\tmath = math,\n\tticks = instead_ticks,\n\tmouse_pos = instead_mouse_pos,\n\tmouse_show = instead_mouse_show,\n\tfinger_pos = instead_finger_pos,\n\tmouse_filter = instead_mouse_filter, \n\tset_timer = instead_timer,\n\trandom = instead_random,\n\trandomseed = instead_srandom,\n\tnext = next,\n\tmath = math,\n\tio = io,\n\tos = os,\n\treaddir = instead_readdir,\n\tcall_top = 0,\n\tcall_ctx = { txt = nil, self = nil },\n--\tfunctions = {}, -- code blocks\n\ttimer = function()\n\t\tif stead.type(timer) == 'table' and stead.type(timer.callback) == 'function' then\n\t\t\treturn timer:callback();\n\t\tend\n\t\treturn\n\tend,\n\tinput = function(event, ...)\n\t\tif stead.type(input) ~= 'table' then\n\t\t\treturn\n\t\tend\n\t\tif event == 'kbd' then\n\t\t\tif stead.type(input.key) == 'function' then\n\t\t\t\treturn input:key(...); -- pressed, event\n\t\t\tend\n\t\telseif event == 'mouse' then\n\t\t\tif stead.type(input.click) == 'function' then\n\t\t\t\treturn input:click(...); -- pressed, x, y, mb\n\t\t\tend\n\t\telseif event == 'finger' then\n\t\t\tif stead.type(input.finger) == 'function' then\n\t\t\t\treturn input:finger(...); -- pressed, x, y, finger\n\t\t\tend\n\t\telseif event == 'event' then\n\t\t\tif stead.type(input.event) == 'function' then\n\t\t\t\treturn input:event(...);\n\t\t\tend\n\t\tend\n\t\treturn\n\tend,\n\tmodules_ini = {},\n\tmodule_init = function(f, ...)\n\t\tif stead.type(f) ~= 'function' then\n\t\t\terror (\"Wrong parameter to mod_init.\", 2);\n\t\tend\n\t\tstead.table.insert(stead.modules_ini, f);\n\t\tf();\n\tend\n}\n\nfunction instead_menu_toggle(n)\n\tif n == nil then\n\t\tn = 'main'\n\telseif type(n) ~= 'string' then\n\t\tn = 'toggle'\n\tend\n\tstead.need_menu = n\nend\n\nstead.menu_toggle = instead_menu_toggle\n\nstead.api_atleast = function(...)\n\tlocal k\n\tlocal v\n\tfor k, v in stead.ipairs {...} do\n\t\tif stead.type(k) ~= 'number' then\n\t\t\treturn false\n\t\tend\n\t\tif v > (stead.api_version_table[k] or 0) then\n\t\t\treturn false\n\t\tend\n\t\tif v < (stead.api_version_table[k] or 0) then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn true\nend;\n\nstead.atleast = function(...)\n\tlocal k\n\tlocal v\n\tfor k, v in stead.ipairs {...} do\n\t\tif stead.type(k) ~= 'number' then\n\t\t\treturn false\n\t\tend\n\t\tif v > (stead.version_table[k] or 0) then\n\t\t\treturn false\n\t\tend\n\t\tif v < (stead.version_table[k] or 0) then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn true\nend;\n\nstead.last_act = function(s)\n\tlocal r = game.__last_act\n\n\tif s ~= nil and s ~= true then\n\t\tgame.__last_act = s\n\tend\n\n\treturn r\nend\n\nstead.last_disp = function(s)\n\tlocal r = game._lastdisp\n\n\tif s ~= nil then\n\t\tif not s then\n\t\t\tgame._lastdisp = nil\n\t\telse\n\t\t\tgame._lastdisp = s\n\t\tend\n\tend\n\treturn r\nend\n\nstead.nop = function(s) -- to refresh entry scene w/o time tick\n\tRAW_TEXT = true\n\treturn stead.last_disp() or ''\nend\n\nstead.need_scene = function(s)\n\tif s == nil then\n\t\tNEED_SCENE = true\n\telse\n\t\tNEED_SCENE = s\n\tend\nend\n\nif not stead.busy then\n\tstead.busy = function(v)\n\tend\nend\n\nif _VERSION == \"Lua 5.1\" then\n\tstead.eval = loadstring\n\tstead.unpack = unpack\nelse\n\tstead.eval = load\n\tstead.unpack = table.unpack\n\tstead.table.maxn = table_get_maxn\n\tstring.gfind = string.gmatch\n\tmath.mod = math.fmod\n\tmath.log10 = function(a)\n\t\treturn stead.math.log(a, 10)\n\tend\nend\n\ninstead = stead;\n\nfunction stead.getcmd(str)\n\tlocal a = {}\n\tlocal n = 1\n\tlocal cmd;\n\tlocal i,k = stead.string.find(str, '[a-zA-Z0-9_]+');\n\tif not i or not k then\n\t\tcmd = str;\n\telse\n\t\tcmd = stead.string.sub(str, i, k);\n\tend\n\tstead.cmd = cmd\n\tif cmd == 'load' or cmd == 'save' then\n\t\ta[1] = stead.strip(stead.string.sub(str, k + 1));\n\t\tstead.args = a;\n\t\treturn cmd, a\n\tend\n\twhile i do\n\t\tk = k + 1;\n\t\ti,k = stead.string.find(str,'[^,]+', k);\n\t\tif not i then\n\t\t\tbreak\n\t\tend\n\t\ta[n] = stead.strip(stead.string.sub(str, i, k));\n\t\tn = n + 1;\n\tend\n\tstead.args = a;\n\treturn cmd, a\nend\n\nstead.tostring = function(v)\n\tif isCode(v) then\n\t\tv = stead.string.format(\"code %q\", stead.functions[v].code);\n\telseif stead.type(v) == 'string' then\n\t\tv = stead.string.format(\"%q\", v);\n\telseif v == nil or stead.type(v) == 'boolean' or stead.type(v) == 'number' then\n\t\tv = stead.tostr(v);\n\telseif stead.type(v) == 'table' and stead.type(stead.deref(v)) == 'string' then\n\t\tv = stead.deref(v);\n\telse\n\t\tv = nil\n\tend\n\treturn v\nend\n\nstead.cctx = function()\n\treturn stead.call_ctx[stead.call_top];\nend\n\nstead.callpush = function(v, ...)\n\tstead.call_top = stead.call_top + 1;\n\tstead.call_ctx[stead.call_top] = { txt = nil, self = v, action = false };\n\targs = {...};\n\targ1 = args[1]\n\targ2 = args[2]\n\targ3 = args[3]\n\targ4 = args[4]\n\targ5 = args[5]\n\targ6 = args[6]\n\targ7 = args[7]\n\targ8 = args[8]\n\targ9 = args[9]\n\t-- dirty but clean and fast :)\n\tself = v\nend\n\nstead.clearargs = function()\n\targ1 = nil\n\targ2 = nil\n\targ3 = nil\n\targ4 = nil\n\targ5 = nil\n\targ6 = nil\n\targ7 = nil\n\targ8 = nil\n\targ9 = nil\n\tself = nil\nend\n\nstead.callpop = function()\n\tstead.call_ctx[stead.call_top] = nil;\n\tstead.call_top = stead.call_top - 1;\n\tif stead.call_top < 0 then\n\t\terror (\"callpush/callpop mismatch\")\n\tend \n\tstead.clearargs()\nend\n\nstead.pclr = function()\n\tstead.cctx().txt = nil\nend\n\nstead.pget = function()\n\treturn stead.cctx().txt;\nend\n\nstead.p = function(...)\n\tlocal i\n\tlocal a = {...}\n\tif stead.cctx() == nil then\n\t\terror (\"Call from global context.\", 2);\n\tend\n\tfor i = 1, stead.table.maxn(a) do\n\t\tstead.cctx().txt = stead.par('', stead.cctx().txt, stead.tostr(a[i]));\n\tend\n\tstead.cctx().txt = stead.cat(stead.cctx().txt, stead.space_delim);\nend\n\nstead.pr = function(...)\n\tlocal i\n\tlocal a = {...}\n\tif stead.cctx() == nil then\n\t\terror (\"Call from global context.\", 2);\n\tend\n\tfor i = 1, stead.table.maxn(a) do\n\t\tstead.cctx().txt = stead.par('', stead.cctx().txt, stead.tostr(a[i]));\n\tend\nend\n\nstead.pn = function(...)\n\tif stead.cctx() == nil then\n\t\terror (\"Call from global context.\", 2);\n\tend\n\tp(...);\n\tstead.cctx().txt = stead.par('', stead.cctx().txt,'^');\nend\n\n-- merge strings with \"space\" as separator\nstead.par = function(space,...)\n\tlocal i, res\n\tlocal a = {...};\n\tfor i = 1, stead.table.maxn(a) do\n\t\tif stead.type(a[i]) == 'string' then\n\t\t\tif res == nil then\n\t\t\t\tres = \"\"\n\t\t\telse\n\t\t\t\tres = res..space;\n\t\t\tend\n\t\t\tres = res..a[i];\n\t\tend \n\tend\n\treturn res;\nend\n-- add to not nill string any string\nstead.cat = function(v,...)\n\tlocal i, res\n\tif not v then\n\t\treturn nil\n\tend\n\tres = v;\n\tlocal a = {...}\n\tfor i = 1, stead.table.maxn(a) do\n\t\tif stead.type(a[i]) == 'string' then\n\t\t\tres = res..a[i];\n\t\tend \n\tend\n\treturn res;\nend\n\nfunction txtnb(v)\n\tif stead.type(v) ~= 'string' then return nil; end\n\treturn iface:nb(v);\nend\n\nfunction img(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:img(v);\nend\n\nfunction imgl(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:imgl(v);\nend\n\nfunction imgr(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:imgr(v);\nend\n\nfunction txtem(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:em(v)\nend\n\nfunction txtst(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:st(v)\nend\n\nfunction txtr(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:right(v)\nend\n\nfunction txtl(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:left(v)\nend\n\nfunction txtc(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:center(v)\nend\n\nfunction txttab(v,a)\n\treturn iface:tab(v, a)\nend\n\nfunction txty(v, a)\n\treturn iface:y(v, a)\nend\n\nfunction txtj(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:just(v)\nend\n\nfunction txtb(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:bold(v)\nend\n\nfunction txtu(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:under(v)\nend\n\nfunction txtnm(n, v)\n\tif stead.type(v) ~= 'string' or not stead.tonum(n) then return nil; end\n\treturn iface:enum(n, v);\nend\n\nfunction txttop(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:top(v)\nend\n\nfunction txtbottom(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:bottom(v)\nend\n\nfunction txtmiddle(v)\n\tif stead.type(v) ~= 'string' then return nil; end; \n\treturn iface:middle(v)\nend\n\nstead.fmt = function(...)\n\tlocal i, res\n\tlocal a = {...};\n\n\tfor i=1,stead.table.maxn(a) do\n\t\tif stead.type(a[i]) == 'string' then\n\t\t\tlocal s = stead.string.gsub(a[i],'[\\t ]+', stead.space_delim);\n\t\t\ts = stead.string.gsub(s, '[\\n]+', stead.space_delim);\n\t\t\ts = stead.string.gsub(s, '\\\\?[\\\\^]', { ['^'] = '\\n', ['\\\\^'] = '^', ['\\\\\\\\'] = '\\\\'} );\n\t\t\tres = stead.par('', res, s);\n\t\tend\n\tend\n\treturn res\nend\n\n-- integer lists\nlocal inext = function(t, k)\n\tlocal v\n\tk, v = stead.next(t, k);\n\twhile k and not stead.tonum(k) do\n\t\tk, v = stead.next(t, k);\n\tend\n\tif not stead.tonum(k) then\n\t\treturn nil\n\tend\n\treturn k, v\nend\n\nlocal ilist = function(s, var)\n\treturn inext, s, nil;\nend\n\nlocal ordered_i = function(t)\n\tlocal ordered = {};\n\tlocal i,v, max;\n\tmax = 0;\n\tfor i,v in ilist(t) do\n\t\tstead.table.insert(ordered, i);\n\t\tmax = max + 1;\n\tend\n\tstead.table.sort(ordered);\n\tordered.i = 1;\n\tordered.max = max;\n\treturn ordered;\nend\n\nlocal onext = function(t, k)\n\tlocal v\n\tif not k then\n\t\tk = ordered_i(t);\n\tend\n\tif k.i > k.max then\n\t\treturn nil\n\tend\n\tv = k[k.i]\n\tk.i = k.i + 1\n\treturn k, t[v], v;\nend\n\nfunction opairs(s)\n\treturn onext, s, nil;\nend\nstead.opairs = opairs\n\nfunction isPlayer(v)\n\treturn (stead.type(v) == 'table') and (v.player_type)\nend\n\nfunction isRoom(v)\n\treturn (stead.type(v) == 'table') and (v.location_type)\nend\n\nfunction isPhrase(v)\n\treturn (stead.type(v) == 'table') and (v.phrase_type)\nend\n\nfunction isDialog(v)\n\treturn (stead.type(v) == 'table') and (v.dialog_type)\nend\n\nfunction isDisabled(v)\n\treturn (stead.type(v) == 'table') and (v._disabled)\nend\n\nfunction isRemoved(v)\n\treturn (stead.type(v) == 'table') and (v._disabled == -1)\nend\n\nfunction isObject(v)\n\treturn (stead.type(v) == 'table') and (v.object_type)\nend\n\nfunction isXaction(v)\n\treturn (stead.type(v) == 'table') and (v.xaction_type)\nend\n\n\nstead.obj_xref = function(self,str)\n\tfunction xrefrep(str)\n\t\tlocal s = stead.string.gsub(str,'[\\001\\002]','');\n\t\treturn stead.xref(s, self);\n\tend\n\tif not str then\n\t\treturn\n\tend\n\tif not isObject(self) then\n\t\treturn str;\n\tend\n\tlocal s = stead.string.gsub(str, '\\\\?[\\\\{}]', \n\t\t{ ['{'] = '\\001', ['}'] = '\\002', [ '\\\\{' ] = '{', [ '\\\\}' ] = '}' }):gsub('\\001([^\\002]+)\\002', xrefrep):gsub('[\\001\\002]', { ['\\001'] = '{', ['\\002'] = '}' });\n\treturn s;\nend\n\nstead.obj_look = function(self)\n\tlocal i, vv, o\n\tif isDisabled(self) then\n\t\treturn\n\tend\n\tlocal v = stead.call(self,'dsc');\n\tif game.hinting then\n\t\tv = self:xref(v);\n\telseif v then\n\t\tv = stead.string.gsub(v, '[{}]','');\n\tend\n\tfor i,o in stead.opairs(self.obj) do\n\t\to = stead.ref(o);\n\t\tif isObject(o) then\n\t\t\tvv = stead.obj_look(o);\n\t\t\tv = stead.par(stead.space_delim, v, vv); \n\t\tend\n\tend\n\treturn v;\nend\n\n\nstead.obj_remove = function(self)\n\tself._disabled = -1;\n\treturn self\nend\n\nstead.obj_disable = function(self)\n\tself._disabled = true;\n\treturn self\nend\n\nstead.obj_enable = function(self)\n\tself._disabled = false;\n\treturn self\nend\n\nstead.obj_disabled = function(self)\n\treturn (self._disabled == true);\nend\n\nstead.obj_enable_all = function(s)\n\tif not isObject(s) then\n\t\treturn\n\tend\n\tobjs(s):enable_all();\nend\n\nstead.obj_disable_all = function(s)\n\tif not isObject(s) then\n\t\treturn\n\tend\n\tobjs(s):disable_all();\nend\n\nstead.obj_save = function(self, name, h, need)\n\tlocal dsc;\n\tif need then\n\t\tprint (\"Warning: object \"..name..\" can not be saved!\");\n\t\treturn\n\tend\n\tstead.savemembers(h, self, name, need);\nend\n\nstead.obj_str = function(self)\n\tlocal i, v, vv, o;\n\tif not isObject(self) then\n\t\treturn\n\tend\n\tif isDisabled(self) then\n\t\treturn \n\tend\n\tfor i,o in stead.opairs(self.obj) do\n\t\to = stead.ref(o);\n\t\tif o~= nil and not isDisabled(o) then -- isObject is better, but compat layer must be ok\n\t\t\tvv = stead.call(o, 'nam');\n\t\t\tvv = stead.xref(vv, o);\n\t\t\tv = stead.par(',', v, vv, stead.obj_str(o));\n\t\tend\n\tend\n\treturn v;\nend\n\nfunction obj(v)\n\tif v.nam == nil then\n\t\tif isRoom(v) then\n\t\t\tif isDialog(v) then\n\t\t\t\terror (\"No dialog name in constructor.\", 3);\n\t\t\tend\n\t\t\terror (\"No room name in constructor.\", 3);\n\t\tend\n\t\terror (\"No object name in constructor.\", 2);\n\tend\n\tv.object_type = true;\n\n\tif v.xref == nil then\n\t\tv.xref = stead.obj_xref;\n\tend\n\n\tif v.look == nil then\n\t\tv.look = stead.obj_look;\n\tend\n\tif v.enable == nil then\n\t\tv.enable = stead.obj_enable;\n\tend\n\tif v.disable == nil then\n\t\tv.disable = stead.obj_disable;\n\tend\n\tif v.disabled == nil then\n\t\tv.disabled = stead.obj_disabled;\n\tend\n\tif v.enable_all == nil then\n\t\tv.enable_all = stead.obj_enable_all;\n\tend\n\tif v.disable_all == nil then\n\t\tv.disable_all = stead.obj_disable_all;\n\tend\n\tif v.remove == nil then\n\t\tv.remove = stead.obj_remove;\n\tend\n\tif v.obj == nil then\n\t\tv.obj = {};\n\tend\n\tif v.srch == nil then\n\t\tv.srch = stead.obj_search;\n\tend\n\tif v.str == nil then\n\t\tv.str = stead.obj_str;\n\tend\n\tv.obj = list(v.obj);\n\tif v.save == nil then\n\t\tv.save = stead.obj_save;\n\tend\n\treturn v\nend\n\n\nfunction stead.ref(n, nofunc) -- ref object by name\n\tif stead.type(n) == 'string' then\n\t\tif stead.type(_G[n]) == 'table' then -- fastest path\n\t\t\treturn _G[n];\n\t\tend\n\t\tlocal f = stead.eval('return '..n);\n\t\tif f then\n\t\t\treturn stead.ref(f(), nofunc);\n\t\tend\n\t\treturn nil;\n\tend\n\tif stead.type(n) == 'table' then\n\t\treturn n;\n\tend\n\tif stead.type(n) == 'function' and not nofunc then\n\t\tlocal r,v = pcall(n);\n\t\tif not r then\n\t\t\treturn nil\n\t\tend\n\t\treturn stead.ref(v);\n\tend\n\treturn nil\nend\n\nfunction stead.deref(n)\n\tif stead.type(n) == 'string' then\n\t\treturn n\n\tend\n\t\n\tif stead.type(n) == 'table' and stead.type(n.key_name) == 'string' then\n\t\treturn n.key_name\n\tend\n\treturn n\nend\n\nstead.list_check = function(self, name)\n\tlocal i, v, ii;\n\tfor i,v,ii in stead.opairs(self) do\n\t\tlocal o = stead.ref(v);\n\t\tif not o then -- isObject(o) then -- compat\n\t\t\terror (\"No object: \"..name..\"[\"..stead.tostr(ii)..\"]\"..\" (\"..stead.tostr(stead.type(v))..\")\")\n\t\t\treturn false\n\t\tend\n\t\tif stead.deref(v) then\n\t\t\tself[ii] = stead.deref(v);\n\t\tend\n\tend\n\treturn true; \nend\n\nstead.list_str = function(self)\n\tlocal i, v, vv, o;\n\tfor i,o in stead.opairs(self) do\n\t\to = stead.ref(o);\n\t\tif o~= nil and not isDisabled(o) then\n\t\t\tvv = stead.call(o, 'nam');\n\t\t\tvv = stead.xref(vv, o);\n\t\t\tv = stead.par(',', v, vv);\n\t\tend\n\tend\n\treturn v;\nend\n\n\nstead.list_add = function(self, name, pos)\n\tlocal nam\n\tnam = stead.deref(name);\n\tif self:look(nam) then\n\t\treturn nil\n\tend\n\tself.__modified__ = true;\n\tif stead.tonum(pos) then\n\t\tpos = stead.tonum(pos)\n\t\tif pos <= #self then\n\t\t\tstead.table.insert(self, pos, nam);\n\t\telse\n\t\t\tself[pos] = nam; -- for spare lists\n\t\tend\n\telse\n\t\tstead.table.insert(self, nam);\n\tend\n\treturn true\nend\n\nstead.list_set = function(self, name, pos)\n\tlocal nam\n\tlocal i = stead.tonum(pos);\n\tif not i then\n\t\treturn nil\n\tend\n\tnam = stead.deref(name);\n\tself.__modified__ = true;\n\tself[i] = nam; -- for spare lists\n\treturn true\nend\n\nstead.list_find = function(self, name)\n\tlocal n, v, ii\n\tlocal o = stead.ref(name, true)\n\tfor n,v,ii in stead.opairs(self) do \n\t\tif stead.ref(v) == o then -- do not call func while search\n\t\t\treturn ii; \n\t\tend\t\n\tend\n\treturn nil\nend\n\nstead.list_disable_all = function(s)\n\tlocal k,v\n\tfor k,v in stead.opairs(s) do\n\t\tlocal o = stead.ref(v);\n\t\tif isObject(o) then\n\t\t\to:disable()\n\t\tend\n\tend\nend\n\nstead.list_enable_all = function(s)\n\tlocal k,v\n\tfor k,v in stead.opairs(s) do\n\t\tlocal o = stead.ref(v);\n\t\tif isObject(o) then\n\t\t\to:enable()\n\t\tend\n\tend\nend\n\nstead.list_enable = function(s, w)\n\tlocal o, i = stead.list_search(s, w, true);\n\to = stead.ref(o);\n\tif isObject(o) then\n\t\to:enable()\n\t\treturn o\n\tend\nend\n\nstead.list_disable = function(s, w)\n\tlocal o, i = stead.list_search(s, w, true);\n\to = stead.ref(o);\n\tif isObject(o) then\n\t\to:disable()\n\t\treturn o\n\tend\nend\n\nstead.list_save = function(self, name, h, need)\n\tif self.__modifyed__ or self.__modified__ then -- compat\n\t\th:write(name..\" = list({});\\n\");\n\t\tneed = true;\n\tend\n\tstead.savemembers(h, self, name, need);\nend\n\nstead.list_name = function(self, name, dis)\n\tlocal n, o, ii\n\tfor n,o,ii in stead.opairs(self) do\n\t\to = stead.ref(o);\n\t\tif isObject(o) then\n\t\t\tlocal nam = stead.call(o,'nam') ;\n\t\t\tif ( not isDisabled(o) or dis ) and name == stead.tostr(nam) then\n\t\t\t\treturn ii;\n\t\t\tend\n\t\tend\n\tend\n\treturn nil\nend\nstead.list_id = function(self, id, dis)\n\tlocal n,o,ii\n\tfor n,o,ii in stead.opairs(self) do\n\t\to = stead.ref(o);\n\t\tif dis or not isDisabled(o) then\n\t\t\tif isObject(o) and id == o.id then\n\t\t\t\treturn ii;\n\t\t\tend\n\t\tend\n\tend\nend\n\nstead.list_search = function(self, n, dis)\n\tlocal i;\n\ti = self:look(n);\n\tif not i then\n\t\ti = self:name(n, dis);\n\tend\n\tif not i and stead.tonum(n) then\n\t\ti = self:byid(stead.tonum(n), dis);\n\t\tif not i then\n\t\t\treturn nil\n\t\tend\n\tend\n\tif not dis and isDisabled(stead.ref(self[i])) then\n\t\treturn nil;\n\tend\n\treturn self[i], i;\nend\n\nstead.list_zap = function(self)\n\tlocal n,o,ii\n\tfor n,o,ii in stead.opairs(self) do\n\t\tself[ii] = nil;\n\tend\n\tself.__modified__ = true\n\treturn self\nend\n\nstead.list_concat = function(self, other, pos)\n\tlocal n,o,ii\n\tfor n,o,ii in stead.opairs(other) do\n\t\to = stead.ref(o);\n\t\tif pos == nil then\n\t\t\tself:add(stead.deref(o));\n\t\telse \n\t\t\tself:add(stead.deref(o), pos);\n\t\t\tpos = pos + 1;\n\t\tend\n\tend\nend\n\nstead.list_del = function(self, name)\n\tlocal v,n\n\tv, n = self:srch(name);\n\tif n == nil then\n\t\treturn nil;\n\tend\n\tself.__modified__ = true\n\tif n <= #self then\n\t\tv = stead.table.remove(self, n);\n\telse\n\t\tv = self[n];\n\t\tself[n] = nil -- for spare lists\n\tend\n\treturn v\nend\n\nstead.list_purge = function(self, name)\n\tlocal v,n\n\tv, n = self:srch(name, true);\n\tif n == nil then\n\t\treturn nil;\n\tend\n\tself.__modified__ = true\n\tv = stead.table.remove(self, n);\n\tif not v then\n\t\tv = self[n];\n\t\tself[n] = nil -- for spare lists\n\tend\n\treturn v\nend\n\nstead.list_replace = function(self, name, name2)\n\tlocal o, ii\n\to, ii = self:srch(name);\n\tif ii then\n\t\tself:set(name2, ii);\n\telse\n\t\tself:add(name2);\n\tend\n\treturn ii;\nend\n\nfunction list(v)\n\tv.list_type = true;\n\tv.add = stead.list_add;\n\tv.set = stead.list_set;\n\tv.cat = stead.list_concat;\n\tv.zap = stead.list_zap;\n\tv.del = stead.list_del;\n\tv.purge = stead.list_purge;\n\tv.replace = stead.list_replace;\n\tv.look = stead.list_find;\n\tv.name = stead.list_name;\n\tv.byid = stead.list_id;\n\tv.srch = stead.list_search;\n\tv.str = stead.list_str;\n\tv.check = stead.list_check;\n\tv.save = stead.list_save;\n\tv.enable = stead.list_enable;\n\tv.disable = stead.list_disable;\n\tv.enable_all = stead.list_enable_all;\n\tv.disable_all = stead.list_disable_all;\n\treturn v;\nend\n\nfunction isList(v)\n\treturn (stead.type(v) == 'table') and (v.list_type == true)\nend\n\nstead.call = function(v, n, ...)\n\tif stead.type(v) ~= 'table' then\n\t\terror (\"Call on non table object:\"..stead.tostr(n), 2);\n\tend\n\tif v[n] == nil then\n\t\treturn nil,nil;\n\tend\n\tif stead.type(v[n]) == 'string' then\n\t\treturn v[n];\n\tend\n\tif stead.type(v[n]) == 'function' then\n\t\tstead.callpush(v, ...)\n\t\tlocal a,b = v[n](v, ...);\n\t\t-- boolean, nil\n\t\tif stead.type(a) == 'boolean' and b == nil then\n\t\t\tb, a = a, stead.pget()\n\t\t\tif a == nil then\n\t\t\t\tif stead.cctx().action then\n\t\t\t\t\ta = true\n\t\t\t\telse\n\t\t\t\t\ta = b\n\t\t\t\t\tb = nil\n\t\t\t\tend\n\t\t\tend \n\t\telseif a == nil and b == nil then\n\t\t\ta = stead.pget()\n\t\t\tb = nil\n\t\tend\n\t\tif a == nil and b == nil and stead.cctx().action then\n\t\t\ta = true\n\t\tend\n\t\tstead.callpop()\n\t\treturn a,b\n\tend\n\tif stead.type(v[n]) == 'boolean' then\n\t\treturn v[n]\n\tend\n\terror (\"Method not string nor function:\"..stead.tostr(n), 2);\nend\n\nstead.call_bool = function(v, n, ...)\n\tif stead.type(v) ~= 'table' then\n\t\terror (\"Call bool on non table object:\"..n, 2);\n\tend\n\t\n\tif v[n] == nil then\n\t\treturn nil\n\tend\t\n\t\n\tif v[n] == false then\n\t\treturn false;\n\tend\n\t\n\tif stead.type(v[n]) == 'function' then\n\t\tstead.callpush(v, ...)\n\t\tlocal r,v = v[n](v, ...);\n\t\tstead.callpop();\n\t\treturn r,v;\n\tend\n\treturn true; -- not nil\nend\n\nstead.call_value = function(v, n, ...)\n\tif stead.type(v) ~= 'table' then\n\t\terror (\"Call value on non table object:\"..n, 2);\n\tend\n\t\n\tif v[n] == nil then\n\t\treturn nil\n\tend\t\n\t\n\tif stead.type(v[n]) ~= 'function' then\n\t\treturn v[n];\n\tend\n\tstead.callpush(v, ...)\n\tlocal r,v = v[n](v, ...);\n\tstead.callpop();\n\treturn r,v;\nend\n\nstead.room_scene = function(self)\n\tlocal v;\n\tv = iface:title(stead.call(self,'nam'));\n\tv = stead.par(stead.scene_delim, v, stead.call(self,'dsc')); --obj_look(self));\n\treturn stead.cat(v, stead.space_delim);\nend\n\nstead.room_look = function(self)\n\tlocal i, vv, o;\n\tfor i,o in stead.opairs(self.obj) do\n\t\to = stead.ref(o);\n\t\tif isObject(o) then\n\t\t\tvv = stead.par(stead.space_delim, vv, o:look());\n\t\tend\n\tend\n\treturn stead.cat(vv, stead.space_delim);\nend\n\nstead.obj_search = function(v, n, dis)\n\tlocal i;\n\tlocal o;\n\tif not dis and isDisabled(v) then\n\t\treturn\n\tend\n\to = v.obj:srch(n, dis);\n\tif o then\n\t\treturn o, v;\n\tend\n\tfor i,o in stead.opairs(v.obj) do\n\t\to = stead.ref(o);\n\t\tif isObject(o) then\n\t\t\tlocal r,rr = stead.obj_search(o, n, dis);\n\t\t\tif r then\n\t\t\t\treturn r, rr;\n\t\t\tend\n\t\tend\n\tend\n\treturn;\nend\n\nstead.room_save = function(self, name, h, need)\n\tlocal dsc;\n\tif need then\n\t\tprint (\"Warning: room \"..name..\" can not be saved!\");\n\t\treturn\n\tend\n\tstead.savemembers(h, self, name, need);\nend\n\nfunction room(v) --constructor\n--\tif v.nam == nil then\n--\t\terror (\"No room name in constructor.\", 2);\n--\tend\n\tif v.scene == nil then\n\t\tv.scene = stead.room_scene;\n\tend\n\tif v.look == nil then\n\t\tv.look = stead.room_look;\n\tend\n\tif v.save == nil then\n\t\tv.save = stead.room_save;\n\tend\n\tv.location_type = true;\n\tif v.way == nil then\n\t\tv.way = { };\n\tend\n\tv.way = list(v.way);\n\tv = obj(v);\n\treturn v;\nend\n\nstead.dialog_enter = function(self)\n\tif not stead.dialog_rescan(self) then\n\t\treturn nil, false\n\tend\n\treturn nil, true\nend\n\nstead.dialog_scene = function(self)\n\tlocal v\n\tv = iface:title(stead.call(self,'nam'));\n\tv = stead.par(stead.scene_delim, v, stead.call(self, 'dsc')); --obj_look(self));\n\treturn v;\nend\n\nstead.dialog_look = function(self)\n\tlocal i,n,v,ph\n\tn = 1\n\tfor i,ph in stead.opairs(self.obj) do\n\t\tph = stead.ref(ph);\n\t\tif isPhrase(ph) and not isDisabled(ph) then\n\t\t\tv = stead.par('^', v, txtnm(n, ph:look()));\n\t\t\tn = n + 1\n\t\tend\n\tend\n\treturn v;\nend\n\nstead.dialog_rescan = function(self)\n\tlocal i,k,ph\n\tk = 1\n\tfor i,ph in stead.opairs(self.obj) do\n\t\tph = stead.ref(ph);\n\t\tif isPhrase(ph) and not isDisabled(ph) then\n\t\t\tph.nam = stead.tostr(k);\n\t\t\tk = k + 1;\n\t\tend\n\tend\n\tif k == 1 then\n\t\treturn false\n\tend\n\treturn true\nend\n\nstead.dialog_empty = function(self)\n\treturn not stead.dialog_rescan(self);\nend\n\nstead.dialog_phrase = function(self, num)\n\tif not stead.tonum(num) then\n\t\tif isPhrase(stead.ref(num)) then\n\t\t\treturn stead.ref(num);\n\t\tend\n\t\treturn nil\n\tend\n\treturn stead.ref(self.obj[stead.tonum(num)]);\nend\n\nstead.phrase_seen = function(s, enb, ...)\n\tlocal i, ph\n\tlocal a = {...}\n\tif stead.table.maxn(a) == 0 then\n\t\tstead.table.insert(a, stead.cctx().self);\n\tend\n\tfor i=1,stead.table.maxn(a) do\n\t\tph = stead.dialog_phrase(s, a[i]);\n\t\tlocal r = not isPhrase(ph) or isRemoved(ph) or ph:disabled();\n\t\tif not enb then r = not r end\n\t\tif r then return false end\n\tend\n\treturn true\nend\n\nstead.dialog_pseen = function(s, ...)\n\treturn stead.phrase_seen(s, true, ...);\nend\n\nstead.dialog_punseen = function(s, ...)\n\treturn stead.phrase_seen(s, false, ...);\nend\n\nlocal function ponoff(s, on, ...)\n\tlocal i, ph\n\tlocal a = {...}\n\tif stead.table.maxn(a) == 0 then\n\t\tstead.table.insert(a, stead.cctx().self)\n\tend\n\tfor i=1,stead.table.maxn(a) do\n\t\tph = stead.dialog_phrase(s, a[i]);\n\t\tif isPhrase(ph) and not isRemoved(ph) then\n\t\t\tif on then\n\t\t\t\tph:enable();\n\t\t\telse \n\t\t\t\tph:disable();\n\t\t\tend\n\t\tend\n\tend\nend\n\nstead.dialog_prem = function(s, ...)\n\tlocal i, ph\n\tlocal a = {...}\n\tif stead.table.maxn(a) == 0 then\n\t\tstead.table.insert(a, stead.cctx().self);\n\tend\n\tfor i=1,stead.table.maxn(a) do\n\t\tph = stead.dialog_phrase(s, a[i]);\n\t\tif isPhrase(ph) then\n\t\t\tph:remove();\n\t\tend\n\tend\nend\n\nstead.dialog_pon = function(self,...)\n\treturn ponoff(self, true, ...);\nend\n\nstead.dialog_poff = function(self,...)\n\treturn ponoff(self, false, ...);\nend\n\nfunction dlg(v) --constructor\n\tv.dialog_type = true;\n\tif v.ini == nil then\n\t\tv.ini = stead.dialog_enter;\n\tend\n\tif v.enter == nil then\n\t\tv.enter = stead.dialog_enter;\n\tend\n\tif v.look == nil then\n\t\tv.look = stead.dialog_look;\n\tend\n\tif v.scene == nil then\n\t\tv.scene = stead.dialog_scene;\n\tend\n\tif v.pon == nil then\n\t\tv.pon = stead.dialog_pon;\n\tend\n\tif v.poff == nil then\n\t\tv.poff = stead.dialog_poff;\n\tend\n\tif v.prem == nil then\n\t\tv.prem = stead.dialog_prem;\n\tend\n\tif v.pseen == nil then\n\t\tv.pseen = stead.dialog_pseen;\n\tend\n\tif v.punseen == nil then\n\t\tv.punseen = stead.dialog_punseen;\n\tend\n\tif v.empty == nil then\n\t\tv.empty = stead.dialog_empty;\n\tend\n\tv = room(v);\n\treturn v;\nend\n\nstead.phrase_action = function(self)\n\tlocal ph = self;\n\tlocal r, ret;\n\n\tif isDisabled(ph) then\n\t\treturn nil, false\n\tend\n-- here it is\n\tph:disable(); -- /* disable it!!! */\n\n\tlocal last = stead.call(ph, 'ans');\n\n\tif stead.type(ph.do_act) == 'string' then\n\t\tlocal f = stead.eval(ph.do_act);\n\t\tif f ~= nil then\n\t\t\tret = f();\n\t\telse\n\t\t\terror (\"Error while eval phrase action.\");\n\t\tend\n\telseif stead.type(ph.do_act) == 'function' then\n\t\tret = ph.do_act(self);\n\tend\n\n\tif ret == nil then ret = stead.pget(); end\n\n\tif last == true or ret == true then\n\t\tr = true;\n\tend\n\n\tlocal wh = stead.here();\n\n\twhile isDialog(wh) and not stead.dialog_rescan(wh) and stead.from(wh) ~= wh do\n\t\twh = stead.from(wh)\n\tend\n\n\tif wh ~= stead.here() then\n\t\tret = stead.par(stead.space_delim, ret, stead.back(wh));\n\tend\n\t\n\tret = stead.par(stead.scene_delim, last, ret);\n\t\n\tif ret == nil then\n\t\treturn r -- hack?\n\tend\n\treturn ret\nend\n\nstead.phrase_save = function(self, name, h, need)\n\tif need then\n\t\tlocal m = \" = phr(\"\n\t\tif isDisabled(self) then\n\t\t\tm = \" = _phr(\"\n\t\tend\n\t\th:write(stead.string.format(\"%s%s%s,%s,%s);\\n\", \n\t\t\tname, m, \n\t\t\tstead.tostring(self.dsc), \n\t\t\tstead.tostring(self.ans), \n\t\t\tstead.tostring(self.do_act)));\n\tend\n\tstead.savemembers(h, self, name, false);\nend\n\nstead.phrase_look = function(self, n)\n\tif isDisabled(self) then\n\t\treturn\n\tend\n\tlocal v = stead.call(self, 'dsc');\n\tif stead.type(v) ~= 'string' then return; end\n\tif game.hinting then\n\t\treturn self:xref('{'..v..'}');\n\tend\n\treturn v;\nend\n\nfunction phrase(o) --constructor\n\tlocal ret = o;\n\tret.look = stead.phrase_look;\n\tret.nam = ''; -- for start\n\tret.phrase_type = true;\n\tret.act = stead.phrase_action;\n\tret.save = stead.phrase_save;\n\tret = obj(ret);\n\treturn ret;\nend\n\nfunction _phr(ask, answ, act)\n\tlocal p = phrase ({ dsc = ask, ans = answ, do_act = act });\n\tp:disable();\n\treturn p;\nend\n\nfunction phr(ask, answ, act)\n\tlocal p = phrase ({ dsc = ask, ans = answ, do_act = act });\n--\tp:enable();\n\treturn p;\nend\n\nstead.player_inv = function(self)\n\treturn iface:inv(stead.cat(self:str()));\nend\n\nstead.player_ways = function(self)\n\treturn iface:ways(stead.cat(stead.ref(self.where).way:str()));\nend\n\nstead.player_objs = function(self)\n\treturn iface:objs(stead.cat(stead.ref(self.where):str()));\nend\n\nstead.player_look = function(self)\n\treturn stead.ref(self.where):scene();\nend\n\nstead.obj_tag = function(self, id)\n\tlocal k,v\n\n\tif isDisabled(self) then\n\t\treturn id\n\tend\n\t\n\tfor k,v in stead.opairs(self.obj) do\n\t\tv = stead.ref(v);\n\t\tif isObject(v) and not isDisabled(v) then\n\t\t\tid = id + 1;\n\t\t\tv.id = id;\n\t\t\tid = stead.obj_tag(v, id);\n\t\tend\n\tend\n\treturn id;\nend\n\nstead.player_tagall = function(self)\n\tlocal id, k, v;\n\tid = 0;\n\n\tid = stead.obj_tag(stead.here(), id);\n\tid = stead.obj_tag(stead.me(), id);\n\n\tfor k,v in stead.opairs(ways()) do\n\t\tv = stead.ref(v);\n\t\tif isRoom(v) and not isDisabled(v) then\n\t\t\tid = id + 1;\n\t\t\tv.id = id;\n\t\tend\n\tend\nend\n\nstead.player_action = function(self, what, ...)\n\tlocal v,r,obj\n\tobj = stead.ref(self.where):srch(what);\n\tif not obj then\n\t\treturn stead.call(stead.ref(game), 'action', what, ...); --player_do(self, what, ...);\n\tend\n\tv, r = stead.player_take(self, what, ...);\n\tif not v then\n\t\tv, r = stead.call(stead.ref(obj), 'act', ...);\n\t\tif not v and r ~= true then\n\t\t\tv, r = stead.call(stead.ref(game), 'act', obj, ...);\n\t\tend\n\tend\n\treturn v, r;\nend\n\nstead.player_take = function(self, what, ...)\n\tlocal v,r,obj,w\n\tobj,w = stead.ref(self.where):srch(what);\n\tif not obj then\n\t\treturn nil, false;\n\tend\n\tv,r = stead.call(stead.ref(obj), 'tak', ...);\n\tif v and r ~= false then\n\t\ttake(obj, w);\n\tend\n\treturn v;\nend\n\nstead.player_use = function(self, what, onwhat, ...)\n\tlocal obj, obj2, v, vv, r;\n\tlocal scene_use_mode = false\n\n\tobj = self:srch(what); -- in inv?\n\tif not obj then -- no\n\t\tobj = stead.ref(self.where):srch(what); -- in scene?\n\t\tif not obj then -- no!\n\t\t\treturn game.err, false;\n\t\tend\n\t\tscene_use_mode = true -- scene_use_mode!\n\tend\n\tif onwhat == nil then -- only one?\n\t\tif scene_use_mode then\n\t\t\treturn self:action(what, ...); -- call act\n\t\telse\n\t\t\tv, r = stead.call(stead.ref(obj),'inv', ...); -- call inv\n\t\tend\n\t\tif not v and r ~= true then\n\t\t\tv, r = stead.call(game, 'inv', obj, ...);\n\t\tend\n\t\treturn v, r;\n\tend\n\tobj2 = stead.ref(self.where):srch(onwhat); -- in scene?\n\tif not obj2 then\n\t\tobj2 = self:srch(onwhat); -- in inv?\n\tend\n\tif not obj2 or obj2 == obj then\n\t\treturn game.err, false;\n\tend\n\tif not scene_use_mode or isSceneUse(stead.ref(obj)) then\n\t\tv, r = stead.call(stead.ref(obj), 'use', obj2, ...);\n\t\tif r ~= false then\n\t\t\tvv = stead.call(stead.ref(obj2), 'used', obj, ...);\n\t\tend\n\tend\n\tif not v and not vv then\n\t\tv, r = stead.call(game, 'use', obj, obj2, ...);\n\tend\n\treturn stead.par(stead.space_delim, v, vv);\nend\n\nstead.player_back = function(self)\n\tlocal where = stead.ref(self.where);\n\tif where == nil then\n\t\treturn nil,false\n\tend\n\treturn stead.go(self, where.__from__, true);\nend\n\nstead.go = function(self, where, back)\n\tlocal was = self.where;\n\tlocal need_scene = false;\t\n\tlocal ret\n\n\tif not stead.in_walk_call then\n\t\tret = function(rc) stead.in_walk_call = false return nil end\n\telse\n\t\tret = function(rc) return rc end\n\tend\n\n\tstead.in_walk_call = true\n\n\tif where == nil then\n\t\treturn nil,ret(false)\n\tend\n\tif not isRoom(stead.ref(where)) then\n\t\terror (\"Trying to go nowhere: \"..where, 2);\n\tend\n\tif not isRoom(stead.ref(self.where)) then\n\t\terror (\"Trying to go from nowhere: \"..self.where, 2);\n\tend\n\n\tif stead.in_entered_call or stead.in_onexit_call then\n\t\terror (\"Do not use walk from onexit/entered action! Use exit/enter action instead:\" .. self.where, 2);\n\tend\n\n\tlocal v, r;\n\tif not isVroom(stead.ref(where)) and not stead.in_exit_call then\n\t\tstead.in_exit_call = true -- to break recurse\n\t\tv,r = stead.call(stead.ref(self.where), 'exit', where);\n\t\tstead.in_exit_call = nil\n\t\tif r == false then\n\t\t\treturn v, ret(r)\n\t\tend\n\tend\n\n\tlocal res = v;\n\n\tv = nil;\n\tif not back or not isDialog(stead.ref(self.where)) or isDialog(stead.ref(where)) then\n\t\tv, r = stead.call(stead.ref(where), 'enter', self.where);\n\t\tif r == false then\n\t\t\treturn v, ret(r)\n\t\tend\n\t\tneed_scene = true;\n\t\tif stead.ref(was) ~= stead.ref(self.where) then -- jump !!!\n\t\t\twhere = stead.deref(self.where);\n\t\t\tneed_scene = false;\n\t\tend\n\tend\n\tres = stead.par(stead.scene_delim, res, v);\n\n\tif not back then\n\t\tstead.ref(where).__from__ = stead.deref(self.where);\n\tend\n\n\tself.where = stead.deref(where);\n\n\tret();\n\n\tPLAYER_MOVED = true\n\tif need_scene then -- or isForcedsc(stead.ref(where)) then -- i'am not sure...\n\t\treturn stead.par(stead.scene_delim, res, stead.ref(where):scene());\n\tend\n\treturn res;\nend\n\nstead.player_walk = function(self, where, ...)\n\tlocal v, r = stead.go(self, where, ...);\n\treturn v, r;\nend\n\nstead.player_go = function(self, where)\n\tlocal w = stead.ref(self.where).way:srch(where);\n\tif not w then\n\t\treturn nil,false\n\tend\n\tlocal v, r = stead.go(self, w, false);\n\treturn v, r;\nend\n\nstead.player_save = function(self, name, h)\n\th:write(stead.string.format('%s.where = %q;\\n', stead.tostr(name), stead.deref(self.where)));\n\tstead.savemembers(h, self, name, false);\nend\n\nfunction player(v)\n\tif v.nam == nil then\n\t\terror (\"No player name in constructor.\", 2);\n\tend\n\tif v.where == nil then\n\t\tv.where = 'main';\n\tend\n\tif v.tag == nil then\n\t\tv.tag = stead.player_tagall;\n\tend\n\tif v.walk == nil then\n\t\tv.walk = stead.player_walk;\n\tend\n\tif v.go == nil then\n\t\tv.go = stead.player_go;\n\tend\n\tif v.ways == nil then\n\t\tv.ways = stead.player_ways;\n\tend\n\tif v.back == nil then\n\t\tv.back = stead.player_back;\n\tend\n\tif v.look == nil then\n\t\tv.look = stead.player_look;\n\tend\n\tif v.inv == nil then\n\t\tv.inv = stead.player_inv;\n\tend\n\tif v.use == nil then\n\t\tv.use = stead.player_use;\n\tend\n\tif v.action == nil then\n\t\tv.action = stead.player_action;\n\tend\n\tif v.save == nil then\n\t\tv.save = stead.player_save;\n\tend\n\tif v.objs == nil then\n\t\tv.objs = stead.player_objs;\n\tend\n\tv.player_type = true;\n\treturn obj(v);\nend\n\nstead.game_life = function(self)\n\tlocal i,o\n\tlocal av,v\n\tstead.in_life_call = true;\n\tstead.in_life_move = false\n\tstead.lifes_op = {}; -- lifes to on/off\n\tstead.PLAYER_MOVED = PLAYER_MOVED\n\tfor i,o in stead.opairs(self.lifes) do\n\t\tlocal vv\n\t\tlocal pre\n\t\to = stead.ref(o);\n\t\tif not isDisabled(o) then\n\t\t\tPLAYER_MOVED = false\n\t\t\tvv,pre = stead.call(o, 'life');\n\t\t\tif PLAYER_MOVED then -- clear life output, but not current\n\t\t\t\tav = nil\n\t\t\t\tv = nil\n\t\t\t\tstead.in_life_move = true\n\t\t\t\tACTION_TEXT = vv;\n\t\t\telseif pre then\n\t\t\t\tav = stead.par(stead.space_delim, av, vv);\n\t\t\telse\n\t\t\t\tv = stead.par(stead.space_delim, v, vv);\n\t\t\tend\n\t\tend\n\tend\n\tPLAYER_MOVED = stead.in_life_move\n\tif not PLAYER_MOVED then PLAYER_MOVED = stead.PLAYER_MOVED end\n\tstead.PLAYER_MOVED = nil\n\tstead.in_life_call = false;\n\tfor i,o in stead.ipairs(stead.lifes_op) do\n\t\tif o[1] then\n\t\t\tstead.lifeon(o[2], o[3]);\n\t\telse\n\t\t\tstead.lifeoff(o[2]);\n\t\tend\n\tend\n\tstead.lifes_op = nil;\n\treturn v, av;\nend\n\nstead.player_moved = function()\n\treturn PLAYER_MOVED or stead.PLAYER_MOVED\nend\n\nstead.life_moved = function()\n\treturn stead.in_life_move\nend\n\nstead.check_list = function(k, v, p)\n\tif v.check == nil or not v:check(stead.string.format(\"%s[%q]\", p, k)) then\n\t\terror (\"error in list: \"..stead.object..'.'..k);\n\tend\nend\n\nstead.check_room = function(k, v)\n\tif v.obj == nil then\n\t\terror(\"no obj in room:\"..k);\n\tend\n\tif v.way == nil then\n\t\terror(\"no way in room:\"..k);\n\tend\nend\n\nstead.check_player = function(k, v)\n\tv.where = stead.deref(v.where);\nend\n\nstead.check_object = function(k, v)\n\tif not v.nam then\n\t\terror (\"No name in \"..k);\n\tend\n\tif isRoom(v) then\n\t\tstead.check_room(k, v);\n\tend\n\tif isPlayer(v) then\n\t\tstead.check_player(k, v);\n\tend\n\tfor_each(v, k, stead.check_list, isList, stead.deref(v))\nend\n\nfunction for_everything(f, ...)\n\tlocal is_ok = function(s)\n\t\treturn true\n\tend\n\tfor_each(_G, '_G', f, is_ok, ...)\nend\n\nlocal compat_api = function()\n\tif stead.compat_api then\n\t\treturn\n\tend\n\n\tif not stead.api_atleast(1, 6, 0) then\n\t\tif not go then\n\t\t\tgo = stead.go\n\t\tend\n\t\tif not goin then\n\t\t\tgoin = walkin\n\t\tend\n\t\tif not goout then\n\t\t\tgoout = walkout\n\t\tend\n\t\tif not goback then\n\t\t\tgoback = walkback\n\t\tend\n\t\tif not _G[\"goto\"] then\n\t\t\tif _VERSION == \"Lua 5.1\" then -- 5.1 lua\n\t\t\t\t_G[\"goto\"] = walk\n\t\t\tend\n\t\tend\n\tend\n\n\tif not stead.api_atleast(1, 7, 1) then\n\t\tif not goin then\n\t\t\tgoin = function() error (\"Please use 'walkin' instead 'goin'.\", 2) end\n\t\tend\n\t\tif not goout then\n\t\t\tgoout = function() error (\"Please use 'walkout' instead 'goout'.\", 2) end\n\t\tend\n\t\tif not goback then\n\t\t\tgoback = function() error (\"Please use 'walkback' instead 'goback'.\", 2) end\n\t\tend\n\t\tif not _G[\"goto\"] then\n\t\t\tif _VERSION == \"Lua 5.1\" then -- 5.1 lua\n\t\t\t\t_G[\"goto\"] = function() error (\"Please use 'walk' instead 'goto'.\", 2) end\n\t\t\tend\n\t\tend\n\n\t\tget_savepath = instead_savepath\n\t\tget_gamepath = instead_gamepath\n\t\tget_steadpath = instead_steadpath\n\t\tget_themespath = instead_themespath\n\t\tget_gamespath = instead_gamespath\n\n\t\ttheme_var = instead_themevar\n\t\ttheme_name = instead_theme_name\n\n\t\tis_sound = instead_sound\n\n\t\tset_timer = instead_timer\n\n\t\tmenu_toggle = instead_menu_toggle\n\t\tstead_busy = instead_busy\n\t\treaddir = instead_readdir\n\n\t\tsound_load = instead_sound_load\n\t\tsound_free = instead_sound_free\n\t\tsounds_free = instead_sounds_free\n\t\tsound_channel = instead_sound_channel\n\t\tsound_volume = instead_sound_volume\n\t\tsound_panning = instead_sound_panning\n\n\t\tfont_load = instead_font_load\n\t\tfont_free = instead_font_free\n\t\tfont_scaled_size = instead_font_scaled_size\n\n\t\tsprite_alpha = instead_sprite_alpha\n\t\tsprite_dup = instead_sprite_dup\n\t\tsprite_scale = instead_sprite_scale\n\t\tsprite_rotate = instead_sprite_rotate\n\t\tsprite_text = instead_sprite_text\n\t\tsprite_text_size = instead_sprite_text_size\n\t\tsprite_draw = instead_sprite_draw\n\t\tsprite_copy = instead_sprite_copy\n\t\tsprite_compose = instead_sprite_compose\n\t\tsprite_fill = instead_sprite_fill\n\t\tsprite_pixel = instead_sprite_pixel\n\t\tsprite_load = instead_sprite_load\n\t\tsprite_free = instead_sprite_free\n\t\tsprite_size = instead_sprite_size\n\t\tsprites_free = instead_sprites_free\n\n\t\tcall = stead.call\n\t\tcall_bool = stead.call_bool\n\t\tcall_value = stead.call_value\n\n\t\tget_title = stead.get_title\n\t\tget_picture = stead.get_picture\n\t\tget_inv = stead.get_inv\n\t\tget_ways = stead.get_ways\n\n\t\tget_autosave = stead.get_autosave\n\n\t\tfmt = stead.fmt\n\n\t\tobj_tag = stead.obj_tag\n\n\t\tmodule_init = stead.module_init\n\n\t\tplayer_inv = stead.player_inv\n\t\tdialog_enter = stead.dialog_enter\n\tend\n\n\tif not stead.api_atleast(1, 4, 5) then\n\t\tstead.xref = function(...)\n\t\t\treturn xref(...);\n\t\tend\n\n\t\t-- internals of call\n\t\tcctx = stead.cctx\n\t\tcallpush = stead.callpush\n\t\tcallpop = stead.callpop\n\t\tclearargs = stead.clearargs\n\t\t-- saving\n\t\tsavemembers = stead.savemembers;\n\t\tsavevar = stead.savevar\n\t\tclearvar = stead.clearvar\n\n\t--\tdo_ini = stead.do_ini\n\t--\tdo_savegame = stead.do_savegame\n\tend\n\n\tstead.compat_api = true\nend\n\nstead.do_ini = function(self, load)\n\tlocal v='',vv\n\tlocal function call_key(k, o)\n\t\to.key_name = k;\n\tend\n\tlocal function call_codekey(k, o)\n\t\tstead.functions[o].key_name = k;\n\tend\n\tlocal function call_ini(k, o, ...)\n\t\tv = stead.par('', v, stead.call(o, 'ini', ...));\n\tend\n\tstead.math.randomseed(stead.os.time(stead.os.date(\"*t\")))\n\tstead.rnd(1); stead.rnd(2); stead.rnd(3); -- Lua bug?\n\tif stead.type(game) ~= 'table' then\n\t\terror (\"No valid 'game' object.\");\n\tend\n\tif not isPlayer(stead.me()) then\n\t\terror (\"No valid player.\");\n\tend\n\tif not isRoom(stead.here()) then\n\t\terror (\"No valid room.\");\n\tend\n\tgame.pl = stead.deref(game.pl);\n\tstead.me().where = stead.deref(stead.me().where);\n--\tgame.where = stead.deref(game.where);\n\n\tif not load then \n\t\tcompat_api()\n\n\t\tfor_everything(function(k, s)\n\t\t\tif isObject(s) then\n\t\t\t\tcall_key(k, s)\n\t\t\telseif isCode(s) then\n\t\t\t\tcall_codekey(k, s)\n\t\t\tend\n\t\tend)\n\t\tfor_each_object(stead.check_object);\n\t\tcall_key(\"game\", game);\n\t\tfor_each(game, \"game\", stead.check_list, isList, stead.deref(game))\n\tend\n\n\tfor_each_object(call_ini, load);\n\n\tstead.me():tag();\n\tif not self.showlast then\n\t\tstead.last_disp(false)\n\tend\n\tstead.initialized = true\n\treturn stead.par('',v, stead.last_disp()); --stead.par('^^',v);\nend\n\nstead.game_ini = function(self)\n\tlocal v,vv\n\tv = stead.do_ini(self);\n\tvv = iface:title(stead.call(self,'nam'));\n\tvv = stead.par(stead.scene_delim, vv, stead.call(self,'dsc'));\n\tif stead.type(init) == 'function' then\n\t\tinit();\n\tend\n--\tif stead.type(hooks) == 'function' then\n--\t\thooks();\n--\tend\n\treturn stead.par(stead.scene_delim, vv, v);\nend\n\nstead.game_start = function(s)\n\tif stead.type(start) == 'function' then\n\t\tstart() -- start function\n\tend\nend\n\nfunction game(v)\n\tif v.nam == nil then\n\t\terror (\"No game name in constructor.\", 2);\n\tend\n\tif v.pl == nil then\n\t\tv.pl = 'player';\n\tend\n\tif v.ini == nil then\n\t\tv.ini = stead.game_ini;\n\tend\n\tif v.start == nil then\n\t\tv.start = stead.game_start\n\tend\n\tif v.save == nil then\n\t\tv.save = stead.game_save;\n\tend\n\tif v.load == nil then\n\t\tv.load = stead.game_load;\n\tend\n\tif v.life == nil then\n\t\tv.life = stead.game_life;\n\tend\n\tif v.step == nil then\n\t\tv.step = stead.game_step;\n\tend\n\tif v.lifes == nil then\n\t\tv.lifes = {};\n\tend\n\tv.lifes = list(v.lifes);\n\tv._time = 0;\n\tv._running = true;\n\tv.game_type = true;\n\treturn v;\nend\n\nfunction live(v)\n\treturn stead.ref(game.lifes:srch(v));\nend\n\nfunction isEnableSave()\n\tif game.enable_save == nil or stead.get_autosave() then\n\t\treturn true\n\tend\n\treturn stead.call_bool(game, 'enable_save');\nend\n\nfunction isEnableAutosave()\n\tif game.enable_autosave == nil then\n\t\treturn true\n\tend\n\treturn stead.call_bool(game, 'enable_autosave');\nend\n\nfunction for_each(o, n, f, fv, ...)\n\tlocal call_list = {}\n\tlocal k,v\n\tif stead.type(o) ~= 'table' then\n\t\treturn\n\tend\n\tstead.object = n;\n\n\tfor k,v in stead.pairs(o) do\n\t\tif fv(v) then\n\t\t\tstead.table.insert(call_list, { k = k, v = v });\n\t\tend\n\tend\n\n\tfor k, v in stead.ipairs(call_list) do\n\t\tf(v.k, v.v, ...);\n\tend\nend\n\nfunction isCode(s)\n\treturn stead.type(s) == 'function' and stead.type(stead.functions[s]) == 'table'\nend\nfunction for_each_codeblock(f,...)\n\tfor_each(_G, '_G', f, isCode, ...)\nend\n\nfunction for_each_object(f,...)\n\tfor_each(_G, '_G', f, isObject, ...)\nend\n\nfunction for_each_player(f,...)\n\tfor_each(_G, '_G', f, isPlayer, ...)\nend\n\nfunction for_each_room(f,...)\n\tfor_each(_G, '_G', f, isRoom, ...)\nend\n\nfunction for_each_list(f,...)\n\tfor_each(_G, '_G', f, isList, ...)\nend\n\nstead.clearvar = function(v)\n\tlocal k,o\n\tfor k,o in stead.pairs(v) do\n\t\tif stead.type(o) == 'table' and o.__visited__ ~= nil then\n\t\t\to.__visited__ = nil\n\t\t\to.auto_saved = nil\n\t\t\tstead.clearvar(o)\n\t\tend\n\tend\nend\n\nstead.savemembers = function(h, self, name, need)\n\tlocal k,v\n\tfor k,v in stead.pairs(self) do\n\t\tlocal need2\n\t\tif k ~= \"__visited__\" then\n\t\t\tneed2 = false\n\t\t\tif isForSave(k, v, self) then\n\t\t\t\tneed2 = true;\n\t\t\tend\n\n\t\t\tif stead.type(k) == 'string' then\n\t\t\t\tstead.savevar(h, v, name..'['..stead.string.format(\"%q\",k)..']', need or need2);\n\t\t\telseif stead.type(k) == 'number' then\n\t\t\t\tstead.savevar(h, v, name..\"[\"..k..\"]\", need or need2)\n\t\t\telseif stead.type(k) == 'table' and stead.type(k.key_name) == 'string' then\n\t\t\t\tstead.savevar(h, v, name..\"[\"..k.key_name..\"]\", need or need2)\n\t\t\tend\n\t\tend\n\tend\nend\n-- savemembers = stead.savemembers;\n\nstead.savevar = function(h, v, n, need)\n\tlocal r,f\n\n\tif v == nil or stead.type(v) == \"userdata\" or\n\t\t\t stead.type(v) == \"function\" then\n\t\tif isCode(v) and need then\n\t\t\tif stead.type(stead.functions[v].key_name) == 'string' \n\t\t\t\tand stead.functions[v].key_name ~= n then\n\t\t\t\th:write(stead.string.format(\"%s=%s\\n\", n, stead.functions[v].key_name))\n\t\t\telse\n\t\t\t\th:write(stead.string.format(\"%s=code %q\\n\", n, stead.functions[v].code))\n\t\t\tend\n\t\tend\n--\t\tif need then\n--\t\t\terror (\"Variable \"..n..\" can not be saved!\");\n--\t\tend \n\t\treturn \n\tend\n\n--\tif stead.string.find(n, '_') ==  1 or stead.string.match(n,'^%u') then\n--\t\tneed = true;\n--\tend\n\n\tif stead.type(v) == \"string\" then\n\t\tif not need then \n\t\t\treturn\n\t\tend\n\t\th:write(stead.string.format(\"%s=%q\\n\",n,v))\n\t\treturn;\n\tend\n \t\n\tif stead.type(v) == \"table\" then\n\t\tif v == _G then return end\n\t\tif stead.type(v.key_name) == 'string' and v.key_name ~= n then -- just xref\n\t\t\tif v.auto_allocated and not v.auto_saved then\n\t\t\t\tv:save(v.key_name, h, false, true); -- here todo\n\t\t\tend\n\t\t\tif need then\n\t\t\t\tif stead.ref(v.key_name) == nil then\n\t\t\t\t\tv.key_name = 'null'\n\t\t\t\tend\n\t\t\t\th:write(stead.string.format(\"%s = %s\\n\", n, v.key_name));\n\t\t\tend\n\t\t\treturn\n\t\tend\n\t\tif v.__visited__ ~= nil then\n\t\t\treturn\n\t\tend\n\n\t\tv.__visited__ = n;\n\n\t\tif stead.type(v.save) == 'function' then\n\t\t\tv:save(n, h, need);\n\t\t\treturn;\n\t\tend\n\n\t\tif need then\n\t\t\th:write(n..\" = {};\\n\");\n\t\tend\n\n\t\tstead.savemembers(h, v, n, need);\n\t\treturn;\n\tend\n\n\tif not need then\n\t\treturn\n\tend\n\th:write(n, \" = \",tostring(v))\n\th:write(\"\\n\") \nend\n-- savevar = stead.savevar\n\nstead.gamereset = function(file, forget)\n\tstead.clearargs()\n\tif stead.api_atleast(2, 2, 0) then\n\t\tinit = function() -- init called only once\n\t\tend\n\tend\n\tif forget then\n\t\tstead.stop_music();\n\t\tstead.stop_sound();\n\t\ttimer:stop();\n\t\tif stead.type(variables) == 'table' then\n\t\t\tlocal k,v\n\t\t\tfor k,v in stead.ipairs(variables) do\n\t\t\t\t_G[v] = nil\n\t\t\tend\n\t\t\tvariables = nil\n\t\t\tvariables_save = nil\n\t\tend\n\t\tinit = function() -- null init function\n\t\tend\n\t\tstart = function() -- null start function\n\t\tend\n\t\tfor_each_object(function(k, o) -- destroy all objects\n\t\t\tif o.system_type then\n\t\t\t\treturn\n\t\t\tend\n\t\t\t_G[k] = nil\n\t\tend);\n\t\tgame._scripts = { }\n\t\tgame.lifes:zap()\n\t\tgame.scriptsforget = true\n\t\t-- anything else?\n\t\tstead:init();\n\tend\n\tdofile(file);\n\tgame:ini();\n\n\tif #game._scripts == 0 or file ~= game._scripts[#game._scripts] then\n\t\tif #game._scripts ~= 0 or file ~= 'main.lua' then\n\t\t\tstead.table.insert(game._scripts, file);\n\t\tend\n\tend\nend\n\nstead.gamefile = function(file, forget)\n\tstead.gamereset(file, forget)\n\tif forget then\n\t\tgame:start()\n\t\tstead.started = true\n\t\treturn stead.walk(stead.here(), false, false, true);\n\tend\nend\n\n\nstead.do_savegame = function(s, h)\n\tstead.busy(true)\n\tlocal function save_object(key, value, h)\n\t\tstead.busy(true)\n\t\tstead.savevar(h, value, key, false);\n\tend\n\tlocal function save_var(key, value, h)\n\t\tstead.busy(true)\n\t\tstead.savevar(h, value, key, isForSave(key, value, _G))\n\tend\n\tlocal forget = game.scriptsforget\n\tlocal i,v\n\tfor i,v in stead.ipairs(s._scripts) do\n\t\th:write(stead.string.format(\"stead.gamereset(%q,%s)\\n\", \n\t\t\tv, stead.tostr(forget)))\n\t\tforget = nil\n\tend\n\tsave_object('allocator', allocator, h); -- always first!\n\tfor_each_object(save_object, h);\n\tsave_object('game', s, h);\n\tfor_everything(save_var, h);\n--\tsave_object('_G', _G, h);\n\tstead.clearvar(_G);\n\tstead.busy(false)\nend\n\nstead.savename = function()\n\treturn stead.call(stead.here(), 'nam');\nend\n\nstead.game_save = function(self, name, file) \n\tlocal h;\n\n\tif file ~= nil then\n\t\tfile:write(stead.string.format(\"%s.pl = %q\\n\", name, stead.deref(self.pl)));\n\t\tstead.savemembers(file, self, name, false);\n\t\treturn nil, true\n\tend\n\n\tif not isEnableSave() then\n\t\treturn nil, false\n\tend\n\n\tif name == nil then\n\t\treturn nil, false\n\tend\n\th = stead.io.open(name,\"wb\");\n\tif not h then\n\t\treturn nil, false\n\tend\n\tlocal n\n\tif stead.type(stead.savename) == 'function' then\n\t\tn = stead.savename()\n\tend\n\tif stead.type(n) == 'string' and n ~= \"\" then\n\t\th:write(\"-- $Name: \"..n:gsub(\"\\n\",\"\\\\n\")..\"$\\n\");\n\tend\n\tstead.do_savegame(self, h);\n\th:flush();\n\th:close();\n\tgame.autosave = false; -- we have only one try for autosave\n\tstead.restart_game = false\n\treturn nil;\nend\n\nstead.game_load = function(self, name) \n\tif name == nil then\n\t\treturn nil, false\n\tend\n\tlocal f, err = loadfile(name);\n\tif f then\n\t\tlocal i,r = f();\n\t\tif r then\n\t\t\treturn nil, false\n\t\tend\n\t\ti, r = stead.do_ini(self, true);\n\t\tif not stead.started then\n\t\t\tgame:start()\n\t\t\tstead.started = true\n\t\tend\n\t\treturn i, r\n\tend\n\treturn nil, false\nend\n\n\nstead.game_step = function(self)\n\tself._time = self._time + 1;\n\treturn self:life(self);\nend\n\n\ngame = game {\n\tcodepage = \"UTF-8\",\n\tnam = \"INSTEAD -- Simple Text Adventure interpreter v\"..stead.version..\" '2009-2016 by Peter Kosyh\",\n\tdsc = [[\nCommands:^\n    look(or just enter), act <on what> (or just what), use <what> [on what], go <where>,^\n    back, inv, way, obj, quit, save <fname>, load <fname>.]],\n\tpl ='pl',\n\tshowlast = true, \n\t_scripts = {},\n};\n\nstead.strip = function(s)\n\tlocal s = stead.tostr(s);\n\ts = stead.string.gsub(s, '^[ \\t]*', '');\n\ts = stead.string.gsub(s, '[ \\t]*$', '');\n\treturn s;\nend\n\nfunction isForcedsc(v)\n\tlocal r,g\n\tr = stead.call_bool(v, 'forcedsc');\n\tif r then\n\t\treturn true\n\tend\n\tg = stead.call_bool(game, 'forcedsc', v);\n\treturn g and r ~= false\nend\n\nfunction isSceneUse(v)\n\tlocal o,g\n\to = stead.call_bool(v, 'scene_use');\n\tif o then\n\t\treturn true\n\tend\n\tg = stead.call_bool(game, 'scene_use', v);\n\treturn g and o ~= false\nend\n\niface = {\n\tanchor = function(self)\n\t\treturn '';\n\tend;\n\timg = function(self, str)\n\t\treturn '';\n\tend,\n\tnb = function(self, str)\n\t\treturn str;\n\tend,\n\tem = function(self, str)\n\t\treturn str;\n\tend,\n\tright = function(self, str)\n\t\treturn str;\n\tend,\n\tleft = function(self, str)\n\t\treturn str;\n\tend,\n\tcenter = function(self, str)\n\t\treturn str;\n\tend,\n\tjust = function(self, str)\n\t\treturn str;\n\tend,\n\ttop = function(self, str)\n\t\treturn str;\n\tend,\n\tbottom = function(self, str)\n\t\treturn str;\n\tend,\n\tmiddle = function(self, str)\n\t\treturn str;\n\tend,\n\ttab = function(self, str, al)\n\t\treturn '';\n\tend;\n\tbold = function(self, str)\n\t\treturn str;\n\tend,\n\tunder = function(self, str)\n\t\treturn str;\n\tend,\n\tst = function(self, str)\n\t\treturn str;\n\tend,\n\tenum = function(self, n, str)\n\t\treturn n..' - '..str;\n\tend,\n\txref = function(self, str, obj)\n\t\tlocal o = stead.ref(stead.here():srch(obj));\n\t\tif not o then \n\t\t\to = stead.ref(ways():srch(obj));\n\t\tend\n\t\tif not o then\n\t\t\to = stead.ref(stead.me():srch(obj));\n\t\tend\n\t\tif not o or not o.id then\n\t\t\treturn str;\n\t\tend\n\t\treturn stead.cat(str,\"(\"..stead.tostr(o.id)..\")\");\n\tend,\n\ttitle = function(self, str)\n\t\treturn \"[\"..str..\"]\";\n\tend,\n\tobjs = function(self, str)\n\t\treturn str;\n\tend,\n\tways = function(self, str)\n\t\treturn str;\n\tend,\n\tinv = function(self, str)\n\t\treturn str;\n\tend,\n\ttext = function(self, str)\n\t\tif str then\n\t\t\tprint(str);\n\t\tend\n\tend,\n\tfmt = function(self, cmd, st, moved, r, av, objs, pv) -- st -- changed state (main win), move -- loc changed\n\t\tlocal l, vv\n\t\tif st and not moved then\n\t\t\tif cmd ~= 'look' then\n\t\t\t\tav = txtem(av);\n\t\t\t\tpv = txtem(pv);\n\t\t\t\tr  = txtem(r);\n\t\t\t\tif isForcedsc(stead.here()) then\n\t\t\t\t\tl = stead.me():look();\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tvv = stead.fmt(stead.cat(stead.par(stead.scene_delim, l, r, av, objs, pv), '^'));\n\t\treturn vv\n\tend,\n\tcmd = function(self, inp)\n\t\tlocal r, v;\n\t\tv = false\n\t\tstead.state = false; -- changed state (main screen)\n\t\tlocal a = { };\n\t\tlocal cmd;\n\t\tRAW_TEXT = nil\n\t\tPLAYER_MOVED = nil\n\t\tstead.set_sound(); -- empty sound\n\t\tcmd,a = stead.getcmd(inp);\n\t\tif cmd == '' then cmd = 'look' end\n--\t\tstead.me():tag();\n\t\tlocal oldloc = stead.here();\n\t\tif cmd == 'look' then\n\t\t\tstead.state = true\n\t\t\tr,v = stead.me():look();\n\t\telseif cmd == 'obj' then\n\t\t\tr,v = stead.me():objs();\n\t\telseif cmd == 'inv' then\n\t\t\tr,v = stead.me():inv();\n\t\telseif cmd == 'way' then\n\t\t\tr,v = stead.me():ways();\n\t\telseif cmd == 'ls' then\n\t\t\tr = stead.par(stead.scene_delim, stead.me():objs(), stead.me():inv(), stead.me():ways());\n\t\t\tv = nil;\n\t\telseif cmd == 'go' then\n\t\t\tstead.state = true\n\t\t\tr,v = stead.me():go(stead.unpack(a));\n\t\telseif cmd == 'back' then\n\t\t\tstead.state = true\n\t\t\tr,v = stead.me():go(stead.from());\n\t\telseif cmd == 'act' then\n\t\t\tstead.state = true\n\t\t\tr,v = stead.me():action(stead.unpack(a));\n\t\telseif cmd == 'use' then\n\t\t\tstead.state = true\n\t\t\tr,v = stead.me():use(stead.unpack(a));\n\t\telseif cmd == 'save' then\n\t\t\tr, v = game:save(stead.unpack(a));\n\t\telseif cmd == 'load' then\n\t\t\tr, v = game:load(stead.unpack(a));\n\t\t\tif v ~= false and game.showlast then\n\t\t\t\treturn r;\n\t\t\tend\n\t\telseif cmd == 'wait' then -- nothing todo in game, skip tick\n\t\t\tv = nil;\n\t\t\tr = true;\n\t\t\tstead.state = true\n\t\telseif cmd == 'nop' then -- inv only\n\t\t\tv = true;\n\t\t\tr = nil;\n\t\t\tstead.state = true\n\t\telse\n\t\t\tstead.state = true\n\t\t\tr,v = stead.me():action(cmd, stead.unpack(a));\n\t\tend\n\t\t-- here r is action result, v - ret code value\t\n\t\t-- state -- game state changed\n\t\tif stead.state and r == nil and v == true then -- we do nothing\n\t\t\treturn nil, true; -- menu\n\t\tend\n\n\t\tif stead.state and r == nil and v == nil and stead.api_atleast(1, 3, 5) then -- new goto\n\t\t\treturn nil, false -- really nothing\n\t\tend\n\n\t\tif RAW_TEXT and v ~= false then\n\t\t\treturn stead.cat(r, '\\n'), true;\n\t\tend\n\n\t\tif v == false then\n\t\t\treturn stead.cat(r, '\\n'), false;\n\t\tend\n\n\t\tACTION_TEXT = r; -- here, life methods can redefine this\n\n\t\tlocal av, pv -- av -- active lifes, pv -- background\n\t\tlocal vv\n\n\t\tif stead.state then\n\t\t\tpv,av = game:step();\n\t\t\tstead.me():tag();\n\t\t\tvv = stead.here():look();\n\t\tend\n\n\t\tvv = self:fmt(cmd, stead.state, (oldloc ~= stead.here()) or PLAYER_MOVED, \n\t\t\tACTION_TEXT, av, vv, pv);\n\n\t\tif stead.state then\n\t\t\tstead.last_disp(vv or false)\n\t\t\tstead.last_act(ACTION_TEXT)\n\t\tend\n\t\tif vv == nil then -- nil is error\n\t\t\tvv = ''\n\t\tend\n\t\treturn vv, true; -- action is here\n\tend, \n\tshell = function(self)\n\t\tlocal inp, i, k, cmd, a, n;\n\t\tstead.me():tag();\t\t\n\t\twhile game._running do\n\t\t\tinp = stead.io.read(\"*l\");\n\t\t\tif inp == 'quit' then\n\t\t\t\tbreak;\n\t\t\tend\n\t\t\tself:text(self:cmd(inp));\n\t\tend\n\tend\n};\n\n\nfunction me()\n\treturn stead.ref(game.pl);\nend\nstead.me = me\n\nfunction where(s)\n\tif not isObject(stead.ref(s)) then error(\"Wrong parameter to where.\", 2); end\n\tif isPlayer(stead.ref(s)) then\n\t\treturn stead.ref(stead.ref(s).where);\n\tend\n\treturn stead.ref(stead.ref(s).__where__);\nend\n\nfunction here()\n\treturn stead.ref(stead.me().where);\nend\nstead.here = here\n\nfunction from(w)\n\tif w == nil then\n\t\tw = stead.here();\n\telse\n\t\tw = stead.ref(w);\n\tend\n\treturn stead.ref(w.__from__);\nend\nstead.from = from\n\nstead.time = function(s)\n\tlocal n = game._time;\n\tif stead.type(s) == 'number' then\n\t\tgame._time = s\n\tend\n\treturn n\nend\n\nfunction inv()\n\treturn stead.me().obj;\nend\n\nfunction objs(w)\n\tif not w then\n\t\treturn stead.here().obj;\n\telse\n\t\treturn stead.ref(w).obj;\n\tend\nend\n\nfunction ways(w)\n\tif not w then\n\t\treturn stead.here().way;\n\telse\n\t\treturn stead.ref(w).way;\n\tend\nend\n\nstead.xref = function(str, obj, ...)\n\tif stead.type(str) ~= 'string' then return nil; end; \n\treturn iface:xref(str, obj, ...);\nend\nxref = stead.xref\n\nfunction pseen(...)\n\tif not isDialog(stead.here()) then\n\t\treturn\n\tend\n\treturn stead.here():pseen(...);\nend\n\nfunction punseen(...)\n\tif not isDialog(stead.here()) then\n\t\treturn\n\tend\n\treturn stead.here():punseen(...);\nend\n\nfunction pon(...)\n\tif not isDialog(stead.here()) then\n\t\treturn\n\tend\n\tstead.here():pon(...);\nend\n\nfunction poff(...)\n\tif not isDialog(stead.here()) then\n\t\treturn\n\tend\n\tstead.here():poff(...);\nend\n\nfunction prem(...)\n\tif not isDialog(stead.here()) then\n\t\treturn\n\tend\n\tstead.here():prem(...);\nend\n\nfunction lifeon(what, nr)\n\tif stead.in_life_call then\n\t\tstead.table.insert(stead.lifes_op, { true, what, nr });\n\t\treturn\n\tend\n\tgame.lifes:add(what, nr);\nend\nstead.lifeon = lifeon\n\nfunction lifeoff(what)\n\tif stead.in_life_call then\n\t\tstead.table.insert(stead.lifes_op, { false, what });\n\t\treturn\n\tend\n\tgame.lifes:del(what);\nend\nstead.lifeoff = lifeoff\n\nstead.allocator_save = function(s, name, h, need, auto)\n\tif s.auto_allocated and not auto then\n\t\treturn\n\tend\n\tif need then\n\t\tif s.auto_allocated then -- in current realization always false\n\t\t\tlocal m = stead.string.format(\"allocator:new(%s, %s)\\n\", \n\t\t\t\tstead.tostring(s.constructor),\n\t\t\t\tstead.tostring(s.constructor));\n\t\t\th:write(m);\n\t\telse\n\t\t\tlocal m = stead.string.format(\" = allocator:get(%s, %s)\\n\",\n\t\t\t\tstead.tostring(name),\n\t\t\t\tstead.tostring(s.constructor));\n\t\t\th:write(name..m);\n\t\t\tif stead.api_atleast(1, 3, 0) then\n\t\t\t\tm = stead.string.format(\"stead.check_object(%s, %s)\\n\",\n\t\t\t\t\tstead.tostring(name),\n\t\t\t\t\tname);\n\t\t\t\th:write(m);\n\t\t\tend\n\t\tend\n\tend\n\tstead.savemembers(h, s, name, false);\n\tif s.auto_allocated then\n\t\ts.auto_saved = true\n\tend\nend\n\nfunction new(str)\n\tif stead.type(str) ~= 'string' then\n\t\terror(\"Non string constructor in new.\", 2);\n\tend\n\treturn allocator:new(str);\nend\n\nfunction delete(v)\n\tallocator:delete(v);\nend\n\nstead.vobj_save = function(self, name, h, need)\n\tlocal dsc = self.dsc;\n\tlocal w = stead.deref(self.where);\n\t\n\tif need then\n\t\th:write(stead.string.format(\"%s  = vobj(%s, %s, %s, %s);\\n\",\n\t\t\tname, \n\t\t\tstead.tostring(self.key), \n\t\t\tstead.tostring(self.nam), \n\t\t\tstead.tostring(dsc), \n\t\t\tstead.tostring(w)));\n\n\tend\n\tstead.savemembers(h, self, name,false);\nend\n\nstead.vobj_act = function(self, ...)\n\tlocal o, r = stead.here():srch(self); -- self.nam\n\tif stead.ref(o) and stead.ref(o).where then\n\t\treturn stead.walk(stead.ref(o).where);\n\tend\n\treturn stead.call(stead.ref(r),'act', self.key, ...);\nend\n\nstead.vobj_used = function(self, ...)\n\tlocal o, r = stead.here():srch(self.nam);\n\treturn stead.call(stead.ref(r),'used', self.key, ...);\nend\n\nfunction vobj(key, name, dsc, w)\n\tif not stead.tonum(key) then\n\t\terror (\"vobj key must be number!\", 2);\n\tend\n\treturn obj{ key = key, nam = name, dsc = dsc, where = stead.deref(w), act = stead.vobj_act, used = stead.vobj_used, save = stead.vobj_save, obj = list({}) };\nend\n\nfunction vway(name, dsc, w)\n\treturn  obj{ key = -1, nam = name, dsc = dsc, act = stead.vobj_act, where = stead.deref(w), used = stead.vobj_used, save = stead.vobj_save, obj = list({}), };\nend\n\nstead.vroom_save = function(self, name, h, need)\n\tif need then\n\t\tlocal t = stead.string.format(\"%s = vroom(%s, %q);\\n\",\n\t\t\tname, stead.tostring(self.nam), \n\t\t\t\tstead.deref(self.where))\n\t\th:write(t);\n\tend\n\tstead.savemembers(h, self, name,false);\nend\n\nstead.vroom_enter = function(self, ...)\n\treturn stead.walk(self.where);\nend\n\nfunction isVroom(v)\n\treturn (stead.type(v) == 'table') and (v.vroom_type)\nend\n\nfunction vroom(name, w)\n\tif w == nil then\n\t\terror(\"Wrong parameter to vroom.\", 2);\n\tend\n\treturn room { vroom_type = true, nam = name, where = stead.deref(w), enter = stead.vroom_enter, save = stead.vroom_save, };\nend\n\nfunction walk(what)\n\tlocal v,r=stead.me():walk(what);\n\tstead.me():tag();\n\treturn v,r;\nend\nstead.walk = walk;\n\nfunction back()\n\treturn stead.me():back();\nend\nstead.back = back;\n\nstead.rnd = function(...)\n\tif stead.random then\n\t\treturn stead.random(...)\n\tend\n\treturn stead.math.random(...);\nend\n\nstead.rndseed = function(...)\n\tif stead.randomseed then\n\t\treturn stead.randomseed(...)\n\tend\n\tstead.math.randomseed(...)\nend\n\nfunction taken(obj)\n\tif isObject(stead.ref(obj)) and stead.ref(obj)._taken then\n\t\treturn true\n\tend\n\treturn false;\nend\n\nfunction remove(obj, from)\n\tlocal o,w\n\tfrom = stead.ref(from)\n\tif from then\n\t\tif isList(from) then\n\t\t\treturn from:del(obj)\n\t\tend\n\t\to,w = from:srch(obj);\n\telse\n\t\to,w = stead.here():srch(obj);\n\tend\n\tif w then\n\t\tstead.ref(w).obj:del(obj);\n\tend\n\to = stead.ref(o);\n\tif not isObject(o) then\n\t\to = stead.ref(obj);\n\tend\n\tif isObject(o) then\n\t\to.__where__ = nil;\n\tend\n\treturn o\nend\nstead.remove = remove\n\nfunction purge(obj, from)\n\tlocal o,w\n\tfrom = stead.ref(from)\n\tif from then\n\t\tif isList(from) then\n\t\t\treturn from:purge(obj)\n\t\tend\n\t\to,w = from:srch(obj, true);\n\telse\n\t\to,w = stead.here():srch(obj, true);\n\tend\n\tif w then\n\t\tstead.ref(w).obj:purge(obj);\n\tend\n\to = stead.ref(o);\n\tif not isObject(o) then\n\t\to = stead.ref(obj);\n\tend\n\tif isObject(o) then\n\t\to.__where__ = nil;\n\tend\n\treturn o\nend\nstead.purge = purge\n\nfunction taketo(obj, wh, pos)\n\tlocal o = remove(obj, wh);\n\tif not isObject(o) then\n\t\terror (\"Trying to take wrong object.\", 2);\n\tend\n\tinv():add(obj, pos);\n\to._taken = true\n\twh = stead.deref(stead.me())\n\tif stead.type(wh) == 'string' then\n\t\to.__where__ = wh;\n\tend\n\treturn o\nend\n\nfunction take(obj, wh)\n\treturn taketo(obj, wh);\nend\n\nfunction takef(obj, wh)\n\treturn taketo(obj, wh, 1);\nend\n\nfunction putto(obj, w, pos)\n\tlocal wh\n\tlocal o = stead.ref(obj);\n\tif not isObject(o) then\n\t\terror (\"Trying to put wrong object.\", 2);\n\tend\n\tif not w then\n\t\twh = stead.deref(stead.here());\n\t\tw = stead.here();\n\telse\n\t\twh = stead.deref(w);\n\t\tw = stead.ref(w);\n\tend\n\tif isList(w) then\n\t\tw:add(obj, pos);\n\telse\n\t\tw.obj:add(obj, pos);\n\tend\n\tif stead.type(wh) == 'string' then\n\t\to.__where__ = wh;\n\tend\n\treturn o;\nend\n\n\nfunction put(obj, w)\n\treturn stead.placeto(obj, w);\nend\n\nfunction putf(obj, w)\n\treturn stead.placeto(obj, w, 1);\nend\n\nplace = put\nplacef = putf\nplaceto = putto\nstead.placeto = placeto\n\nfunction replace(obj, obj2, from)\n\tlocal o,w,i\n\tif not isObject(stead.ref(obj2)) then\n\t\terror (\"Wrong parameter to replace.\", 2);\n\tend\n\tfrom = stead.ref(from)\n\tif from then\n\t\tif isList(from) then\n\t\t\tfrom:replace(obj, obj2);\n\t\t\treturn stead.ref(obj)\n\t\tend\n\t\to,w = from:srch(obj);\n\telse\n\t\to,w = stead.here():srch(obj);\n\tend\n\tif w then\n\t\tstead.ref(w).obj:replace(o, obj2);\n\t\tstead.ref(obj2).__where__ = stead.deref(w);\n\telse\n\t\tstead.placeto(obj2, from);\n\tend\n\to = stead.ref(o);\n\tif not isObject(o) then\n\t\to = stead.ref(obj);\n\tend\n\tif isObject(o) then\n\t\to.__where__ = nil;\n\tend\n\treturn o;\nend\n\nfunction drop(obj, w)\n\tlocal o = put(obj, w);\n\tif not isObject(o) then\n\t\terror (\"Trying to drop wrong object.\", 2);\n\tend\n\tinv():del(obj);\n\to._taken = false\n\treturn o;\nend\n\nfunction dropf(obj, w)\n\tlocal o = putf(obj, w);\n\tif not isObject(o) then\n\t\terror (\"Trying to dropf wrong object.\", 2);\n\tend\n\tinv():del(obj);\n\to._taken = false\n\treturn o;\nend\n\nfunction dropto(obj, w, pos)\n\tlocal o = putto(obj, w, pos);\n\tif not isObject(o) then\n\t\terror (\"Trying to dropto wrong object.\", 2);\n\tend\n\tinv():del(obj);\n\to._taken = false\n\treturn o;\nend\n\nfunction seen(obj, wh)\n\tif not wh then\n\t\twh = stead.here();\n\telse\n\t\twh = stead.ref(wh);\n\tend\n\tlocal o,w = wh:srch(obj);\n\to = stead.ref(o);\n\tif isObject(o) then\n\t\treturn o,w\n\tend\n\treturn nil\nend\n\nfunction exist(obj, wh)\n\tif not wh then\n\t\twh = stead.here();\n\telse\n\t\twh = stead.ref(wh);\n\tend\n\tlocal o,w = wh:srch(obj, true);\n\to = stead.ref(o);\n\tif isObject(o) then\n\t\treturn o,w\n\tend\n\treturn nil\nend\n\nfunction have(obj)\n\tlocal o = inv():srch(obj);\n\to = stead.ref(o);\n\tif isObject(o) then\n\t\treturn o\n\tend\n\treturn nil\nend\n\nfunction moveto(obj, there, from, pos)\n\tstead.remove(obj, from);\n\tstead.placeto(obj, there, pos);\n\treturn stead.ref(obj);\nend\nstead.moveto = moveto\n\nfunction move(obj, there, from)\n\treturn stead.moveto(obj, there, from);\nend\n\nfunction movef(obj, there, from)\n\treturn stead.moveto(obj, there, from, 1);\nend\n\nstead.get_picture = function()\n\tlocal s = stead.call(stead.here(),'pic');\n\tif not s then\n\t\ts = stead.call(game, 'pic');\n\tend\n\treturn s;\nend\n\nstead.get_title = function()\n\tlocal s = stead.call(stead.here(),'nam');\n\treturn s;\nend\n\nstead.get_music = function()\n\treturn game._music, game._music_loop;\nend\n\nstead.get_music_loop = function()\n\treturn game._music_loop;\nend\n\nstead.save_music = function(s)\n\tif s == nil then\n\t\ts = self\n\tend\n\ts.__old_music__ = stead.get_music();\n\ts.__old_loop__ = stead.get_music_loop();\nend\n\nstead.restore_music = function(s)\n\tif s == nil then\n\t\ts = self\n\tend\n\tstead.set_music(s.__old_music__, s.__old_loop__);\nend\n\nstead.set_music = function(s, count)\n\tgame._music = s;\n\tif not stead.tonum(count) then\n\t\tgame._music_loop = 0;\n\telse\n\t\tgame._music_loop = stead.tonum(count);\n\tend\nend\n\nstead.set_music_fading = function(o, i)\n\tif o and o == 0 then o = -1 end\n\tif i and i == 0 then i = -1 end\n\n\tgame._music_fadeout = o\n\tif not i then\n\t\tgame._music_fadein = o\n\telse\n\t\tgame._music_fadein = i\n\tend\nend\n\nstead.get_music_fading = function()\n\treturn game._music_fadeout, game._music_fadein\nend\n\nstead.stop_music = function()\n\tstead.set_music(nil, -1);\nend\n\nstead.is_music = function()\n\treturn game._music ~= nil and game._music_loop ~= -1\nend\n\nif instead_sound == nil then\n\tfunction instead_sound()\n\t\treturn false -- sdl-instead export own function\n\tend\nend\nstead.is_sound = instead_sound\n\nif instead_savepath == nil then\n\tfunction instead_savepath()\n\t\treturn \"./\"\n\tend\nend\n\nfunction autosave(slot)\n\tgame.autosave = true;\n\tgame.autosave_slot = slot;\nend\nstead.autosave = autosave;\n\nstead.get_restart = function()\n\treturn stead.restart_game\nend\n\nstead.get_menu = function()\n\tlocal n = stead.need_menu\n\tstead.need_menu = nil\n\treturn n\nend\n\nstead.restart = function()\n\tstead.restart_game = true\nend\n\nstead.get_autosave = function()\n\treturn game.autosave, game.autosave_slot\nend\n\nstead.get_sound = function()\n\treturn game._sound, game._sound_channel, game._sound_loop;\nend\n\nstead.get_sound_chan = function()\n\treturn game._sound_channel\nend\n\nstead.get_sound_loop = function()\n\treturn game._sound_loop\nend\n\nstead.stop_sound = function(chan, fo)\n\tif not stead.tonum(chan) then\n\t\tif stead.tonum(fo) then\n\t\t\tstead.set_sound('@-1,'..stead.tostr(fo));\n\t\telse\n\t\t\tstead.set_sound('@-1');\n\t\tend\n\t\treturn\n\tend\n\tif stead.tonum(fo) then\n\t\tstead.add_sound('@'..stead.tostr(chan)..','..stead.tostr(fo));\n\telse\n\t\tstead.add_sound('@'..stead.tostr(chan));\n\tend\nend\n\nstead.add_sound = function(s, chan, loop)\n\tif stead.type(s) ~= 'string' then\n\t\treturn\n\tend\n\tif stead.type(game._sound) == 'string' then\n\t\tif stead.tonum(chan) then\n\t\t\ts = s..'@'..stead.tostr(chan);\n\t\tend\n\t\tif stead.tonum(loop) then\n\t\t\ts = s..','..stead.tostr(loop)\n\t\tend\n\t\tstead.set_sound(game._sound..';'..s, stead.get_sound_chan(), stead.get_sound_loop());\n\telse\n\t\tstead.set_sound(s, chan, loop);\n\tend\nend\n\nstead.set_sound = function(s, chan, loop)\n\tgame._sound = s;\t\n\tif not stead.tonum(loop) then\n\t\tgame._sound_loop = 1;\n\telse\n\t\tgame._sound_loop = stead.tonum(loop);\n\tend\n\n\tif not stead.tonum(chan) then\n\t\tgame._sound_channel = -1;\n\telse\n\t\tgame._sound_channel = stead.tonum(chan);\n\tend\nend\n\nfunction change_pl(p)\n\tlocal o = stead.ref(p);\n\tif stead.type(stead.deref(p)) ~= 'string' or not o then\n\t\terror (\"Wrong player name in change_pl...\", 2);\n\tend\n\tgame.pl = stead.deref(p);\n\treturn stead.walk(o.where, false, true, true); -- no call enter/exit\nend\n\nfunction disabled(o)\n\treturn isDisabled(stead.ref(o))\nend\n\nfunction disable(o)\n\to = stead.ref(o)\n\tif isObject(o) then\n\t\to:disable()\n\tend\n\treturn o\nend\n\nfunction enable(o)\n\to = stead.ref(o)\n\tif isObject(o) then\n\t\to:enable()\n\tend\n\treturn o\nend\n\nfunction disable_all(o)\n\to = stead.ref(o)\n\tif isObject(o) or isList(o) then\n\t\to:disable_all()\n\tend\n\treturn o\nend\n\nfunction enable_all(o)\n\to = stead.ref(o)\n\tif isObject(o) or isList(o) then\n\t\to:enable_all()\n\tend\n\treturn o\nend\n\nfunction isForSave(k, v, s) -- k - key, v - value, s -- parent table\n\tif stead.type(k) == 'function' then\n\t\treturn false\n\tend\n\tif stead.type(v) == 'function' or stead.type(v) == 'userdata' then\n\t\treturn false\n\tend\n\treturn stead.string.find(k, '_') ==  1 or stead.string.match(k,'^%u')\nend\n\nstead.inherit = function(o, f)\n\treturn function(...)\n\t\treturn f(o(...))\n\tend\nend\ninherit = stead.inherit\n\nstead.hook = function(o, f)\n\treturn function(...)\n\t\tlocal ff\n\t\tif stead.type(o) ~= 'function' then\n\t\t\tff = function(s)\n\t\t\t\treturn o;\n\t\t\tend\n\t\telse\n\t\t\tff = o\n\t\tend\n\t\treturn f(ff, ...)\n\tend\nend\nhook = stead.hook\n\nfunction nameof(v)\n\tif isObject(v) then\n\t\tlocal r = stead.call(v, 'nam');\n\t\treturn r\n\tend\nend\n\nstead.nameof = nameof\n\nstead.dispof = function(v)\n\tif isObject(v) then\n\t\tlocal r\n\t\tif game.gui then\n\t\t\tr = stead.call(v, 'disp')\n\t\tend\n\t\tif r == nil then\n\t\t\tr = stead.call(v, 'nam');\n\t\tend\n\t\treturn r\n\tend\nend\n\nfunction stead_version(v)\n\tif not stead.tostr(v) then\n\t\treturn\n\tend\n\tlocal n\n\n\tstead.version_table = {}\n\tstead.api_version_table = {}\n\n\tfor n in stead.string.gmatch(stead.version, \"[0-9]+\") do\n\t\tstead.table.insert(stead.version_table, stead.tonum(n))\n\tend\n\n\tfor n in stead.string.gmatch(v, \"[0-9]+\") do\n\t\tstead.table.insert(stead.api_version_table, stead.tonum(n))\n\tend\n\n\tif not stead.atleast(stead.unpack(stead.api_version_table)) then\n\t\terror ([[The game requires instead engine of version ]] ..v.. [[ or higher.\n\t\thttp://instead.sourceforge.net]], 2)\n\tend\n\n\tstead.api_version = v\n\n\tif stead.api_atleast(1, 2, 0) then\n\t\trequire (\"walk\")\n\t\trequire (\"vars\")\n\t\trequire (\"object\")\n\tend\n\tif stead.api_atleast(1, 6, 3) then\n\t\trequire (\"dlg\")\n\tend\nend\ninstead_version = stead_version\n\nfunction code(v)\n\tlocal f = stead.eval(v)\n\tif not f then\n\t\terror (\"Wrong script: \"..stead.tostr(v), 2);\n\tend\n\tstead.functions[f] = { f = f, code = v };\n\treturn f;\nend\nstead.code = code\n\n--- here the game begins\nstead.objects = function(s)\n\tnull = obj {\n\t\tnam = 'null';\n\t}\n\n\tinput = obj { -- input object\n\t\tsystem_type = true,\n\t\tnam = 'input',\n\t--[[\tkey = function(s, down, key)\n\t\t\treturn\n\t\tend, ]]\n\t--[[\tclick = function(s, down, mb, x, y, [ px, py ] )\n\t\t\treturn\n\t\tend ]]\n\t};\n\n\ttimer = obj { -- timer calls stead.timer callback \n\t\tnam = 'timer',\n\t\tini = function(s)\n\t\t\tif stead.tonum(s._timer) ~= nil and stead.type(stead.set_timer) == 'function' then\n\t\t\t\tstead.set_timer(s._timer);\n\t\t\tend\n\t\tend,\n\t\tget = function(s)\n\t\t\tif stead.tonum(s._timer) == nil then\n\t\t\t\treturn 0\n\t\t\tend\n\t\t\treturn stead.tonum(s._timer);\n\t\tend,\n\t\tstop = function(s)\n\t\t\treturn s:set(0);\n\t\tend,\n\t\tdel = function(s)\n\t\t\treturn s:set(0);\n\t\tend,\n\t\tset = function(s, v)\n\t\t\ts._timer = stead.tonum(v);\n\t\t\tif stead.type(stead.set_timer) ~= 'function' then\n\t\t\t\treturn false\n\t\t\tend\n\t\t\tstead.set_timer(v)\n\t\t\treturn true\n\t\tend,\n\t\t--[[ \tcallback = function(s)\n\t\t\tend, ]]\n\t};\n\n\tallocator = obj {\n\t\tnam = 'allocator',\n\t\tget = function(s, n, c)\n\t\t\tif isObject(stead.ref(n)) and stead.api_atleast(1, 3, 0) then -- static?\n\t\t\t\treturn stead.ref(n);\n\t\t\tend\n\t\t\tlocal v = stead.ref(c);\n\t\t\tif not v then\n\t\t\t\terror (\"Null object in allocator: \"..stead.tostr(c));\n\t\t\tend\n\t\t\tv.key_name = n;\n\t\t\tv.save = stead.allocator_save;\n\t\t\tv.constructor = c;\n\t\t\treturn v\n\t\tend,\n\t\tdelete = function(s, w)\n\t\t\tw = stead.ref(w);\n\t\t\tif stead.type(w.key_name) ~= 'string' then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tlocal f = stead.eval(w.key_name..'= nil;');\n\t\t\tif f then\n\t\t\t\tf();\n\t\t\tend\n\t\tend,\n\t\tnew = function(s, n, key)\n\t\t\tlocal v = stead.ref(n);\n\t\t\tif stead.type(v) ~= 'table' or stead.type(n) ~= 'string' then\n\t\t\t\terror (\"Error in new.\", 2);\n\t\t\tend\n\t\t\tv.save = stead.allocator_save;\n\t\t\tv.constructor = n;\n\t\t\tif key then\n\t\t\t\ts.objects[key] = v\n\t\t\t\tv.key_name = stead.string.format('allocator[\"objects\"][%s]', stead.tostring(key));\n\t\t\telse\n\t\t\t\tlocal nm = #s.objects + 1 -- here is new index\n\t\t\t\tstead.table.insert(s.objects, v);\n\t\t\t\tv.key_name = 'allocator[\"objects\"]['..stead.tostr(nm)..']';\n\t\t\tend\n\t\t\tif stead.api_atleast(1, 3, 0) then\n\t\t\t\tstead.check_object(v.key_name, v)\n\t\t\tend\n\t\t\treturn v\n\t\tend,\n\t\tobjects = {\n\t\t\tsave = function(self, name, h, need)\n\t\t\t\tstead.savemembers(h, self, name, true);\n\t\t\tend,\n\t\t},\n\t};\n\n\tpl = player {\n\t\tnam = \"Incognito\",\n\t\twhere = 'main',\n\t\tobj = { }\n\t};\n\n\tmain = room {\n\t\tnam = 'main',\n\t\tdsc = 'No main room defined.',\n\t};\nend\n\n\nstead.sandbox = function()\n\tif STANDALONE then\n\t\treturn\n\tend\n-- sandbox --\nlocal check_path = function(realpath, type, find, gsub, savepath, gamepath, path)\n\tif not path then\n\t\treturn false\n\tend\n\tpath = realpath(path)\n\tif not path then\n\t\treturn false\n\tend\n\tlocal spath = realpath(savepath)\n\tif not spath then\n\t\treturn false\n\tend\n\tlocal s = find(path, spath..'/', 1, true)\n\tif s ~= 1 then\n\t\tspath = realpath(gamepath);\n\t\tif spath then\n\t\t\ts = find(path, spath..'/', 1, true)\n\t\tend\n\tend\n\tif s ~= 1 then\n\t\treturn false\n\tend\n\treturn true\nend\n\nlocal build_sandbox_open = function(realpath, error, type, find, gsub, savepath, gamepath)\n\treturn stead.hook(io.open, function(f, path, acc, ...)\n\t\tif type(acc) ~= 'string' or not find(acc, \"[aw+]\") then -- only write access\n\t\t\treturn f(path, acc, ...)\n\t\tend\n\t\tif not check_path(realpath, type, find, gsub, savepath, gamepath, path) then\n\t\t\terror (\"Access denied (write): \".. path, 3);\n\t\t\treturn false\n\t\tend\n\t\treturn f(path, acc, ...)\n\tend)\nend\n\nlocal build_sandbox_remove = function(realpath, error, type, find, gsub, savepath, gamepath)\n\treturn stead.hook(os.remove, function(f, path, ...)\n\t\tif type(path) ~= 'string' then\n\t\t\treturn f(path, ...)\n\t\tend\n\t\tif not check_path(realpath, type, find, gsub, savepath, gamepath, path) then\n\t\t\terror (\"Access denied (remove): \".. path, 3);\n\t\t\treturn false\n\t\tend\n\t\treturn f(path, ...)\n\tend)\nend\n\nlocal build_sandbox_rename = function(realpath, error, type, find, gsub, savepath, gamepath)\n\treturn stead.hook(os.rename, function(f, oldname, newname, ...)\n\t\tif not check_path(realpath, type, find, gsub, savepath, gamepath, oldname) or \n\t\t\tnot check_path(realpath, type, find, gsub, savepath, gamepath, newname) then\n\t\t\terror (\"Access denied (rename): \".. oldname .. ', '.. newname, 3);\n\t\t\treturn false\n\t\tend\n\t\treturn f(oldname, newname, ...)\n\tend)\nend\n\nlocal build_sandbox_output = function(realpath, error, type, find, gsub, savepath, gamepath)\n\treturn stead.hook(io.output, function(f, path, ...)\n\t\tif not check_path(realpath, type, find, gsub, savepath, gamepath, path) then\n\t\t\terror (\"Access denied (output): \".. path, 3);\n\t\t\treturn false\n\t\tend\n\t\treturn f(path, ...)\n\tend)\nend\n\nio.open = build_sandbox_open(instead_realpath, error, type, string.find, string.gsub, \n\t\tinstead_savepath(), instead_gamepath());\n\nos.remove = build_sandbox_remove(instead_realpath, error, type, string.find, string.gsub, \n\t\tinstead_savepath(), instead_gamepath());\n\nos.rename = build_sandbox_rename(instead_realpath, error, type, string.find, string.gsub, \n\t\tinstead_savepath(), instead_gamepath());\n\nio.output = build_sandbox_output(instead_realpath, error, type, string.find, string.gsub, \n\t\tinstead_savepath(), instead_gamepath());\n\nos.execute = function(s)\n\tprint (\"Warning: trying to do os.execute: \"..s);\nend\n\nio.popen = function(s)\n\tprint (\"Warning: trying to do io.popen: \"..s);\nend\n\nos.tmpname = function(s)\n\tprint (\"Warning: trying to do os.tmpname\");\nend\n\nif not DEBUG then\n\tdebug = nil\nend\npackage.cpath = \"\"\npackage.preload = {}\npackage = nil\n\nend\n-- end of sandbox --\n\nstead.init = function(s)\n\tstead.initialized = false\n\tstead.started = false\n\tstead:objects();\n\ts.functions = {} -- code blocks\n\tlocal k,v\n\tfor k,v in stead.ipairs(s.modules_ini) do\n\t\tv();\n\tend\n\tif stead.type(stead.sandbox) == 'function' then\n\t\tstead.sandbox()\n\t\tstead.sandbox = nil\n\tend\nend\n\n-- those are sill in global space\nadd_sound = stead.add_sound\nset_sound = stead.set_sound\nstop_sound = stead.stop_sound\n\nget_sound = stead.get_sound\nget_sound_loop = stead.get_sound_loop\nget_sound_chan = stead.get_sound_chan\n\nget_music = stead.get_music\nget_music_fading = stead.get_music_fading\nget_music_loop = stead.get_music_loop\n\nset_music = stead.set_music\nset_music_fading = stead.set_music_fading\nstop_music = stead.stop_music\n\nsave_music = stead.save_music\nrestore_music = stead.restore_music\n\nis_music = stead.is_music\n\nref = stead.ref\nderef = stead.deref\n\nmouse_pos = stead.mouse_pos\nmouse_filter = stead.mouse_filter\n\nget_ticks = stead.ticks\n\npclr = stead.pclr\npget =  stead.pget\np = stead.p\npr = stead.pr\npn = stead.pn\npar = stead.par\ncat = stead.cat\nplayer_moved = stead.player_moved\nrnd = stead.rnd;\ngamefile = stead.gamefile\ntime = stead.time\n\ninstead_version(stead.api_version)\n-- vim:ts=4\n","theme.lua":"theme = {\n\tnam = 'theme';\n\tobject_type = true;\n\tsystem_type = true;\n\tsave = function(self, name, h, need)\n\t\tlocal k,v\n\t\tif self.name() ~= '.' then\n\t\t\treturn\n\t\tend\n\t\tfor k,v in stead.pairs(self.vars) do\n\t\t\th:write(stead.string.format(\"theme.set(%q, %q);\\n\", k, v))\n\t\tend\n\tend;\n\treset = function(...)\n\t\tlocal i\n\t\tlocal a = {...};\n\t\tfor i = 1, stead.table.maxn(a) do\n\t\t\tlocal name = a[i]\n\t\t\tlocal v\n\t\t\tif name then\n\t\t\t\tv = theme.reset_vars[name]\n\t\t\t\tif v then\n\t\t\t\t\tinstead_theme_var(name, v);\n\t\t\t\t\ttheme.vars[name] = nil\n\t\t\t\t\ttheme.reset_vars[name] = nil\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend;\n\tset = function(name, val)\n\t\tif val and name then\n\t\t\tif not theme.reset_vars[name] then\n\t\t\t\ttheme.reset_vars[name] = instead_theme_var(name)\n\t\t\tend\n\t\t\tinstead_theme_var(name, stead.tostr(val));\n\t\t\ttheme.vars[name] = stead.tostr(val);\n\t\tend\n\tend;\n\tname = function()\n\t\treturn instead_theme_name(name);\n\tend;\n\tget = function(name)\n\t\treturn instead_theme_var(name);\n\tend;\n\twin = {\n\t\treset = function()\n\t\t\ttheme.reset(\"win.x\", \"win.y\", \"win.w\", \"win.h\",\n\t\t\t\t\"win.col.fg\", \"win.col.link\", \"win.col.alink\",\n\t\t\t\t\"win.fnt.name\", \"win.fnt.size\", \"win.fnt.height\");\n\t\tend;\n\t\tgeom = function(x, y, w, h)\n\t\t\ttheme.set(\"win.x\", x);\n\t\t\ttheme.set(\"win.y\", y);\n\t\t\ttheme.set(\"win.w\", w);\n\t\t\ttheme.set(\"win.h\", h);\n\t\tend;\n\t\tcolor = function(fg, link, alink)\n\t\t\ttheme.set(\"win.col.fg\", fg);\n\t\t\ttheme.set(\"win.col.link\", link);\n\t\t\ttheme.set(\"win.col.alink\", alink);\n\t\tend;\n\t\tfont = function(name, size, height)\n\t\t\ttheme.set(\"win.fnt.name\", name);\n\t\t\ttheme.set(\"win.fnt.size\", size);\n\t\t\ttheme.set(\"win.fnt.height\", height);\n\t\tend;\n\t\tgfx = {\n\t\t\treset = function()\n\t\t\t\ttheme.reset(\"win.gfx.up\", \"win.up.x\", \"win.up.y\");\n\t\t\t\ttheme.reset(\"win.gfx.down\", \"win.down.x\", \"win.down.y\");\n\t\t\tend;\n\t\t\tup = function(pic, x, y)\n\t\t\t\ttheme.set(\"win.gfx.up\", pic);\n\t\t\t\ttheme.set(\"win.up.x\", x);\n\t\t\t\ttheme.set(\"win.up.y\", y);\n\t\t\tend;\n\t\t\tdown = function(pic, x, y)\n\t\t\t\ttheme.set(\"win.gfx.down\", pic);\n\t\t\t\ttheme.set(\"win.down.x\", x);\n\t\t\t\ttheme.set(\"win.down.y\", y);\n\t\t\tend;\n\t\t};\n\t};\n\tinv = {\n\t\treset = function()\n\t\t\ttheme.reset(\"inv.x\", \"inv.y\", \"inv.w\", \"inv.h\",\n\t\t\t\t\"inv.col.fg\", \"inv.col.link\", \"inv.col.alink\",\n\t\t\t\t\"inv.fnt.name\", \"inv.fnt.size\", \"inv.fnt.height\",\n\t\t\t\t\"inv.mode\");\n\t\tend;\n\t\tgeom = function(x, y, w, h)\n\t\t\ttheme.set(\"inv.x\", x);\n\t\t\ttheme.set(\"inv.y\", y);\n\t\t\ttheme.set(\"inv.w\", w);\n\t\t\ttheme.set(\"inv.h\", h);\n\t\tend;\n\t\tcolor = function(fg, link, alink)\n\t\t\ttheme.set(\"inv.col.fg\", fg);\n\t\t\ttheme.set(\"inv.col.link\", link);\n\t\t\ttheme.set(\"inv.col.alink\", alink);\n\t\tend;\n\t\tfont = function(name, size, height)\n\t\t\ttheme.set(\"inv.fnt.name\", name);\n\t\t\ttheme.set(\"inv.fnt.size\", size);\n\t\t\ttheme.set(\"inv.fnt.height\", height);\n\t\tend;\n\t\tmode = function(mode)\n\t\t\ttheme.set(\"inv.mode\", mode);\n\t\tend;\n\t\tgfx = {\n\t\t\treset = function()\n\t\t\t\ttheme.reset(\"inv.gfx.up\", \"inv.up.x\", \"inv.up.y\");\n\t\t\t\ttheme.reset(\"inv.gfx.down\", \"inv.down.x\", \"inv.down.y\");\n\t\t\tend;\n\t\t\tup = function(pic, x, y)\n\t\t\t\ttheme.set(\"inv.gfx.up\", pic);\n\t\t\t\ttheme.set(\"inv.up.x\", x);\n\t\t\t\ttheme.set(\"inv.up.y\", y);\n\t\t\tend;\n\t\t\tdown = function(pic, x, y)\n\t\t\t\ttheme.set(\"inv.gfx.down\", pic);\n\t\t\t\ttheme.set(\"inv.down.x\", x);\n\t\t\t\ttheme.set(\"inv.down.y\", y);\n\t\t\tend;\n\t\t};\n\t};\n\tmenu = {\n\t\treset = function()\n\t\t\ttheme.reset(\"menu.bw\",\n\t\t\t\t\"menu.col.fg\", \"menu.col.bg\", \"menu.col.alpha\",\n\t\t\t\t\"menu.col.link\", \"menu.col.alink\",\n\t\t\t\t\"menu.fnt.name\", \"menu.fnt.size\", \"menu.fnt.height\");\n\t\tend;\n\t\tbw = function(w)\n\t\t\ttheme.set(\"menu.bw\", w);\n\t\tend;\n\t\tcolor = function(fg, bg, alpha, link, alink)\n\t\t\ttheme.set(\"menu.col.fg\", fg);\n\t\t\ttheme.set(\"menu.col.bg\", bg);\n\t\t\ttheme.set(\"menu.col.alpha\", alpha);\n\t\t\ttheme.set(\"menu.col.link\", link);\n\t\t\ttheme.set(\"menu.col.alink\", alink);\n\t\tend;\n\t\tfont = function(name, size, height)\n\t\t\ttheme.set(\"menu.fnt.name\", name);\n\t\t\ttheme.set(\"menu.fnt.size\", size);\n\t\t\ttheme.set(\"menu.fnt.height\", height);\n\t\tend;\n\t\tgfx = {\n\t\t\treset = function()\n\t\t\t\ttheme.reset(\"menu.gfx.button\", \"menu.button.x\", \"menu.button.y\");\n\t\t\tend;\n\t\t\tbutton = function(b, x, y)\n\t\t\t\ttheme.set(\"menu.gfx.button\", b);\n\t\t\t\ttheme.set(\"menu.button.x\", x);\n\t\t\t\ttheme.set(\"menu.button.y\", y);\n\t\t\tend;\n\t\t};\n\t};\n\tgfx = {\n\t\treset = function()\n\t\t\ttheme.reset(\"scr.gfx.cursor.normal\", \"scr.gfx.cursor.use\",\n\t\t\t\t\"scr.gfx.cursor.x\", \"scr.gfx.cursor.y\",\n\t\t\t\t\"scr.gfx.mode\", \"scr.gfx.pad\",\n\t\t\t\t\"scr.gfx.bg\");\n\t\tend;\n\t\tcursor = function(norm, use, x, y)\n\t\t\ttheme.set(\"scr.gfx.cursor.normal\", norm);\n\t\t\ttheme.set(\"scr.gfx.cursor.use\", use);\n\t\t\ttheme.set(\"scr.gfx.cursor.x\", x);\n\t\t\ttheme.set(\"scr.gfx.cursor.y\", y);\n\t\tend;\n\t\tmode = function(mode)\n\t\t\ttheme.set(\"scr.gfx.mode\", mode);\n\t\tend;\n\t\tpad = function(pad)\n\t\t\ttheme.set(\"scr.gfx.pad\", pad);\n\t\tend;\n\t\tbg = function(bg)\n\t\t\ttheme.set(\"scr.gfx.bg\", bg);\n\t\tend;\n\t};\n\tsnd = {\n\t\treset = function()\n\t\t\ttheme.reset(\"snd.click\");\n\t\tend;\n\t\tclick = function(w)\n\t\t\ttheme.set(\"snd.click\", w);\n\t\tend\n\t}\n}\n\ntheme.vars = {}\ntheme.reset_vars = {}\n","timer.lua":"game.action = stead.hook(game.action, function(f, s, cmd, ...)\n\tif cmd == 'user_timer' then\n\t\tlocal r,v\n\t\tif stead.here().timer then\n\t\t\tr,v = stead.call(stead.here(), 'timer');\n\t\telseif s.timer then\n\t\t\tr,v = stead.call(s, 'timer');\n\t\tend\n\t\tif r == nil and v == nil and not stead.api_atleast(1, 3, 5) then\n\t\t\treturn nil, true\n\t\tend\n\t\treturn r,v\n\tend\n\treturn f(s, cmd, ...);\nend)\n\nstead.module_init(function()\n\ttimer.callback = function(s)\n\t\treturn 'user_timer'\n\tend\nend)\n\n-- vim:ts=4\n","vars.lua":"function isForSave(k, v, s) -- k - key, v - value, s -- parent table\n\tlocal i,o\n\tif stead.type(s.variables_save) == 'table' and \n\t\ts.variables_save[k] then\n\t\t\treturn true\n\tend\n\tif stead.type(k) == 'function' then\n\t\treturn false\n\tend\n\tif stead.type(v) == 'function' or stead.type(v) == 'userdata' then\n\t\treturn false\n\tend\n\tif stead.type(k) ~= 'string' then\n\t\treturn false\n\tend\n\treturn stead.string.find(k, '_') ==  1\nend\n\nlocal function __vars_add(s, v, set)\n\tlocal k, o\n\tif stead.type(s.variables) ~= 'table' then s.variables = {} end\n\tfor k,o in stead.pairs(v) do\n\t\tif stead.tonum(k) then\n\t\t\tstead.table.insert(s.variables, o);\n\t\telseif s.variables[k] then\n\t\t\terror (\"Variable overwrites variables object: \"..stead.tostr(k))\n\t\telseif k ~= 'variable_type' then\n\t\t\tif set and not isObject(o) then \n\t\t\t\tif s[k] then\n\t\t\t\t\tif s == _G then\n\t\t\t\t\t\tprint (\"Global variable '\"..stead.tostr(k)..\"' conflicts with \"..stead.type(s[k]));\n\t\t\t\t\telse\n\t\t\t\t\t\terror (\"Variable conflict: \"..stead.tostr(k));\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tstead.table.insert(s.variables, k);\n\t\t\t\ts[k] = o\n\t\t\telse\n\t\t\t\ts.variables[k] = o\n\t\t\tend\n\t\tend\n\tend\nend\n\nlocal function __vars_fill(v)\n\tlocal k,o\n\tif stead.type(v) ~= 'table' then\n\t\treturn\n\tend\n\tfor k,o in stead.ipairs(v) do\n\t\tif stead.type(o) == 'table' and o.variable_type then\n\t\t\t__vars_add(v, o);\n\t\t\tv[k] = false\n\t\tend\n\tend\n\tif stead.type(v.variables) == 'table' then\n\t\tlocal k,o\n\t\tlocal vars = {}\n\t\tv.variables_save = {}\n\t\tfor k,o in stead.pairs(v.variables) do\n\t\t\tif stead.tonum(k) and stead.type(o) == 'string' then\n\t\t\t\tstead.table.insert(vars, o)\n\t\t\telse\n\t\t\t\tif v[k] then\n\t\t\t\t\terror (\"Variable overwrites object property: \"..stead.tostr(k));\n\t\t\t\tend\n\t\t\t\tv[k] = o\n\t\t\t\tstead.table.insert(vars, k);\n\t\t\tend\n\t\tend\n\t\tfor k,o in stead.ipairs(vars) do\n\t\t\tv.variables_save[o] = true\n\t\tend\n\t\tv.variables = vars;\n\tend\nend\n\nvars_object = obj {\n\tnam = 'vars',\n\tsystem_type = true,\n\tini = function(s)\n\t\t__vars_fill(_G)\n\t\t__vars_fill(pl)\n\t\t__vars_fill(game)\n\tend\n}\n\nobj = stead.hook(obj, \nfunction(f, v, ...)\n\t__vars_fill(v)\n\treturn f(v, ...)\nend)\n\nstead.add_var = function(s, v) \n\tif not v then \n\t\tv = s \n\t\ts = _G \n\tend\n\tif stead.type(v) ~= 'table' then\n\t\terror(\"Wrong parameter to stead.add_var.\");\n\tend\n\tif not v.variable_type then\n\t\tv = var(v)\n\tend\n\t__vars_add(s, v, true)\n\t__vars_fill(s)\nend\n\nstead.module_init(function()\n\tlocal k,v\n\tif stead.type(variables) == 'nil' then\n\t\tvariables = {}\n\t\treturn\n\tend \n\tif stead.type(variables) ~= 'table' then\n\t\treturn\n\tend\n\tfor k,v in stead.ipairs(variables) do\n\t\t_G[v] = nil\n\tend\n\tvariables = {}\nend)\n\nfunction var(v)\n\tv.variable_type = true\n\treturn v\nend\n\nfunction global(v)\n\tif stead.type(v) ~= 'table' then\n\t\terror(\"Wrong parameter to global.\", 2);\n\tend\n\t__vars_add(_G, v, true);\nend\n-- vim:ts=4\n","walk.lua":"local function onevent(ev, ...)\n\tlocal vv, r\n\tif stead.api_atleast(1, 6, 3) then\n\t\tvv, r = stead.call(game, ev, ...);\n\t\tif r == false then\n\t\t\treturn vv, false\n\t\tend\n\t\tif vv == false then\n\t\t\treturn nil, false\n\t\tend\n\t\treturn vv\n\tend\nend\n\nlocal go = function (self, where, back, noenter, noexit, nodsc)\n\tlocal was = self.where;\n\tlocal need_scene = false;\n\tlocal ret\n\n\tif not stead.in_walk_call then\n\t\tret = function(rc) stead.in_walk_call = false return nil end\n\telse\n\t\tret = function(rc) return rc end\n\tend\n\n\tstead.in_walk_call = true\n\n\tif where == nil then\n\t\treturn nil, ret(false)\n\tend\n\n\tif not isRoom(stead.ref(where)) then\n\t\terror (\"Trying to go nowhere: \"..where);\n\tend\n\n\tif not isRoom(stead.ref(self.where)) then\n\t\terror (\"Trying to go from nowhere: \"..self.where);\n\tend\n\n\tif stead.in_entered_call or stead.in_onexit_call then\n\t\terror (\"Do not use walk from left/entered action! Use exit/enter action instead:\" .. self.where);\n\tend\n\n\tlocal v, r, jump;\n\n\tif not isVroom(stead.ref(where)) and not stead.in_exit_call and not noexit then\n\t\tstead.in_exit_call = true -- to break recurse\n\t\tv,r = stead.call(stead.ref(self.where), 'exit', stead.ref(where));\n\t\tstead.in_exit_call = nil\n\t\tif r == false or (stead.api_atleast(1, 3, 0) and v == false and r == nil) then\n\t\t\treturn v, ret(r)\n\t\tend\n\t\tif stead.api_atleast(2, 4, 0) then\n\t\t\tjump = PLAYER_MOVED\n\t\telse\n\t\t\tjump = (self.where ~= was)\n\t\tend\n\t\tif jump then\n\t\t\twhere = stead.deref(self.where) -- jump\n\t\tend\n\tend\n\n\tlocal res = v;\n\tv = nil;\n\n\tif not isVroom(stead.ref(where)) then\n\t\tself.where = stead.deref(where);\n\tend\n\n\tif not jump and not noenter then\n\t\tv, r = stead.call(stead.ref(where), 'enter', stead.ref(was));\n\t\tif r == false or (stead.api_atleast(1, 3, 0) and v == false and r == nil) then\n\t\t\tself.where = was;\n\t\t\treturn stead.par(stead.scene_delim, res, v), ret(r)\n\t\tend\n\tend\n\t\n\tif stead.api_atleast(2, 4, 0) then\n\t\tneed_scene = not PLAYER_MOVED;\n\telse\n\t\tneed_scene = not (stead.ref(where) ~= stead.ref(self.where))\n\tend\n\n\tres = stead.par(stead.scene_delim, res, v);\n\n\tif not back then\n\t\tstead.ref(where).__from__ = stead.deref(was);\n\tend\n\n\tret()\n\n\tPLAYER_MOVED = true\n\tif need_scene and not nodsc then\n\t\tNEED_SCENE = true\n\tend\n\n\tif not stead.in_walk_call  then\n\t\tlocal to = self.where\n\t\tif not noexit then\n\t\t\tself.where = was\n\t\t\tstead.in_onexit_call = true\n\t\t\tv = stead.call(stead.ref(was), 'left', stead.ref(to));\n\t\t\tstead.in_onexit_call = false\n\t\t\tres = stead.par(stead.scene_delim, res, v);\n\t\tend\n\n\t\tself.where = stead.deref(to)\n\n\t\tif not noenter then\n\t\t\tstead.in_entered_call = true\n\t\t\tv = stead.call(stead.ref(to), 'entered', stead.ref(was));\n\t\t\tstead.in_entered_call = false\n\t\t\tres = stead.par(stead.scene_delim, res, v);\n\t\tend\n\n\t\tif stead.tonum(stead.ref(to).__visited) then\n\t\t\tstead.ref(to).__visited = stead.ref(to).__visited + 1;\n\t\telseif stead.here().__visited == nil then\n\t\t\tstead.ref(to).__visited = 1\n\t\tend\n\t\tif not stead.api_atleast(1, 6, 3) and isDialog(stead.ref(to)) then\n\t\t\tstead.dialog_rescan(stead.ref(to))\n\t\tend\n\tend\n\treturn res;\nend\n\nstead.player_go = function(self, where) -- cmd iface\n\tlocal w = stead.ref(self.where).way:srch(where);\n\tif not w then\n\t\treturn nil,false\n\tend\n\treturn self:walk(w);\nend\n\nstead.player_walk = function(self, where, ...) -- real work\n\tlocal v, r, vv;\n\tvv, r = onevent('onwalk', stead.ref(where), ...);\n\tif vv == false then\n\t\treturn\n\tend\n\tif r == false then \n\t\treturn vv \n\tend\n\tv, r = stead.go(self, where, ...);\n\tif stead.type(vv) == 'string' then\n\t\tv = stead.par(stead.space_delim, vv, v);\n\tend\n\treturn v, r;\nend\n\nstead.player_back = function(self) -- deprecated\n\terror (\"Do not use stead.me():back(). It's deprecated.\", 2)\nend\n\nstead.back = function(w)\n\tif isDialog(stead.here()) and not isDialog(stead.from()) then\n\t\treturn stead.walkout(w);\n\tend\n\treturn stead.walkback(w);\nend\nback = stead.back\n\nstead.walkback = function(w)\n\tif isRoom(stead.ref(w)) then\n\t\treturn stead.me():walk(w, true);\n\tend\n\treturn stead.me():walk(stead.from(), true);\nend\nwalkback = stead.walkback\n\nstead.walk = function(what, back, noenter, noexit, nodsc, ...)\n\treturn stead.me():walk(what, back, noenter, noexit, nodsc, ...);\nend\nwalk = stead.walk\n\nstead.walkin = function(what)\n\treturn stead.me():walk(what, false, false, true);\nend\nwalkin = stead.walkin\n\nstead.walkout = function(what)\n\tif isRoom(stead.ref(what)) then\n\t\treturn stead.me():walk(what, true, true, false, true);\n\tend\n\treturn stead.me():walk(stead.from(), true, true, false, true);\nend\nwalkout = stead.walkout\n\nfunction visited(w)\n\tif not w then w = stead.here() end\n\tw = stead.ref(w)\n\tif w == nil then\n\t\treturn nil;\n\tend\n\tif not isRoom(w) then\n\t\terror (\"Wrong parameter to visited.\", 2);\n\tend\n\treturn w.__visited\nend\nstead.visited = visited\n\nfunction visits(w)\n\tlocal n = stead.visited(w)\n\tif not n then n = 0 end\n\treturn n\nend\nstead.visits = visits\n\niface.fmt = function(self, cmd, st, moved, r, av, objs, pv) -- st -- changed state (main win), move -- loc changed\n\tlocal l, vv\n\tif st then\n\t\tav = txtem(av);\n\t\tpv = txtem(pv);\n--\t\tif not PLAYER_MOVED then\n\t\t\tr = txtem(r)\n--\t\tend\n\t\tif isForcedsc(stead.here()) or NEED_SCENE then\n\t\t\tl = stead.here():scene();\n\t\tend\n\tend\n\tif moved then\n\t\tvv = stead.fmt(stead.cat(stead.par(stead.scene_delim, r, l, av, objs, pv), '^'));\n\telse\n\t\tvv = stead.fmt(stead.cat(stead.par(stead.scene_delim, l, r, av, objs, pv), '^'));\n\tend\n\treturn vv\nend\n\nstead.go = function(...)\n\tlocal r,v = go(...)\n\tif stead.type(r) == 'string' and stead.cctx() then \n\t\tstead.pr (r)\n\tend\n--\tif stead.in_life_call then\n--\t\tACTION_TEXT = nil\n--\tend\n\tif r == nil and v == nil then\n\t\tif stead.cctx() then\n\t\t\tstead.cctx().action = true\n\t\telse\n\t\t\tr = true\n\t\tend\n\tend\n\treturn r,v\nend\n\niface.cmd = stead.hook(iface.cmd, function(f, ...)\n\tNEED_SCENE = nil\n\treturn f(...)\nend)\n\nplayer  = stead.inherit(player, function(v)\n\tv.look = function(s)\n\t\tif not stead.started then\n\t\t\tgame:start()\n\t\t\tstead.started = true\n\t\tend\n\t\tif game._time == 0 then\n\t\t\treturn stead.walk(stead.here(), false, false, true);\n\t\tend\n\t\tNEED_SCENE = true\n\t\tif stead.api_atleast(1, 3, 5) then\n\t\t\treturn true -- force action\n\t\tend\n\tend\n\treturn v\nend)\n\npl = player(pl) -- reinit\n-- vim:ts=4\n","wroom.lua":"stead.wroom_enter = function(self, ...)\n\tlocal w = self.where\n\tif stead.type(w) ~= 'table' then\n\t\tw = stead.call(self, 'where')\n\tend\n\tlocal r, v = stead.walk(w);\n\tif v ~= false then\n\t\tself._toggle = true\n\tend\n\treturn r, v\nend\n\nstead.wroom_save = function(self, name, h, need)\n\tif need then\n\t\tlocal a = stead.tostring(self.oldname);\n\t\tlocal b = stead.tostring(self.newname);\n\t\tlocal c = stead.tostring(self.where);\n\n\t\tif a == nil or b == nil or c == nil then\n\t\t\terror (\"Can not save wroom \"..name..\"\\nFunctions can not be saved, use code [[ ]]\");\n\t\tend\n\t\tlocal t = stead.string.format(\"%s = wroom(%s, %s, %s);\\n\",\n\t\t\tname, a, b, c);\n\t\th:write(t);\n\tend\n\tstead.savemembers(h, self, name, false);\nend\n\nfunction wroom(a, b, c)\n\tlocal v = room { vroom_type = true, nam = a, where = c, enter = stead.wroom_enter, save = stead.wroom_save };\n\tv.newname = b;\n\tv.oldname = a;\n\tv._toggle = false\n\tif c == nil then -- only two parameters\n\t\tv.newname = nil\n\t\tv.where = b\n\tend\n\tv.nam = function(s)\n\t\tif s._toggle and s.newname then\n\t\t\treturn stead.call(s, 'newname')\n\t\telse\n\t\t\treturn stead.call(s, 'oldname');\n\t\tend\n\tend\n\treturn v\nend\n","xact.lua":"xact = function(n, f) -- just simple action!\n\tlocal v = {};\n\n\tif f == nil and stead.type(n) == 'table' then\n\t\tf = n[2];\n\t\tn = n[1];\n\tend\n\n\tif stead.type(n) ~= 'string' then\n\t\terror (\"Wrong parameter to xact.\", 2)\n\tend\n\tv.xaction_type = true\n\tv.nam = n\n\tif stead.api_atleast(1, 6, 3) then\n\t\tv.disp = false\n\tend\n\tv.act = f;\n\tv = obj(v);\n\tv.save = function(self, name, h, need)\n\t\tif need then\n\t\t\tlocal f = self.act;\n\t\t\tf = stead.tostring(f);\n\t\t\tif f == nil then\n\t\t\t\terror(\"Can not save xact: \"..name);\n\t\t\tend\n\t\t\th:write(stead.string.format(\"%s = xact(%q, %s);\\n\", name, self.nam, f))\n\t\tend\n\t\tstead.savemembers(h, self, name, false);\n\tend\n\treturn v\nend\n\nlocal __do_xact = function(str, self)\n\tlocal aarg = {}\n\tlocal function parg(v)\n\t\tstead.table.insert(aarg, v);\n\t\treturn ''\n\tend\n\tlocal xrefrep = function(str)\n\t\tlocal s = stead.string.gsub(str,'[\\001\\002]','');\n\t\tlocal o,d,a, oo;\n\t\tlocal delim = ':'\n\n\t\tif stead.api_atleast(1, 2, 2) then\n\t\t\tdelim = stead.delim;\n\t\tend\n\t\ts = s:gsub('\\\\?[\\\\'..delim..']', { [ delim ] = '\\001', [ '\\\\'..delim ] = delim });\n\t\tlocal i = s:find('\\001', 1, true);\n\t\taarg = {}\n\t\tif i then\n\t\t\to = s:sub(1, i - 1);\n\t\t\td = s:sub(i + 1);\n\t\t\ti = o:find(\"(\", 1, true);\n\t\t\tif i then\n\t\t\t\ta = o:sub(i);\n\t\t\t\to = o:sub(1, i - 1);\n\t\t\t\ta:gsub('[^,()]+', parg);\n\t\t\tend\n\t\t\tif o == '' then \n\t\t\t\tif isObject(self) then\n\t\t\t\t\too = self\n\t\t\t\telse\n\t\t\t\t\terror(\"Empty link: \"..s, 3);\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif stead.api_atleast(1, 6, 3) then\n\t\t\t\t\too = stead.here():srch(o)\n\t\t\t\telse\n\t\t\t\t\too = objs():srch(o)\n\t\t\t\tend\n\t\t\t\tif not oo then\n\t\t\t\t\too = stead.ref(o, true)\n\t\t\t\tend\n\t\t\tend\n\t\telseif isObject(self) then\n\t\t\too = self\n\t\t\td = s;\n\t\telse\n\t\t\terror(\"Wrong link: \"..s, 3);\n\t\tend\n\t\td = d:gsub(\"\\001\", delim);\n\t\treturn stead.xref(d, stead.ref(oo, true), stead.unpack(aarg));\n\tend\n\tif stead.type(str) ~= 'string' then return end\n\tlocal s = stead.string.gsub(str, '\\\\?[\\\\{}]', \n\t\t{ ['{'] = '\\001', ['}'] = '\\002' }):gsub('\\001([^\\002]+)\\002', xrefrep):gsub('[\\001\\002]', { ['\\001'] = '{', ['\\002'] = '}' });\t\n\treturn s;\nend\n\nstead.fmt = stead.hook(stead.fmt, function(f, ...)\n\tlocal i, res, s\n\tlocal a = {...}\n\tfor i=1,stead.table.maxn(a) do\n\t\tif stead.type(a[i]) == 'string' then\n\t\t\ts = __do_xact(a[i]);\n\t\t\tres = stead.par('', res, s):gsub('\\\\?[\\\\{}]', { [ '\\\\{' ] = '{', [ '\\\\}' ] = '}' });\n\t\tend\n\tend\n\treturn f(res);\nend)\n\nobj = stead.inherit(obj, function(v)\n\tv.xref = function(s, str)\n\t\treturn __do_xact(str, s);\n\tend\n\treturn v\nend)\n\nfunction xdsc(n)\n\tlocal v = {}\n\tv.nam = true\n\tif n == nil then\n\t\tv.disp = 'xdsc'\n\telseif stead.type(n) == 'string' then\n\t\tv.disp = n;\n\telse\n\t\terror(\"Wrong parameter to xdsc.\", 2);\n\tend\n\tv.dsc = function(s)\n\t\treturn stead.call(stead.here(), s.disp);\n\tend\n\tv.save = function(self, name, h, need)\n\t\tif need then\n\t\t\th:write(stead.string.format(\"%s = xdsc(%q);\\n\", name, self.disp))\n\t\tend\n\t\tstead.savemembers(h, self, name, false);\n\tend\n\treturn obj(v)\nend\n\nxroom = stead.inherit(room, function(v)\n\tv.look = stead.hook(v.look, function(f, s,...)\n\t\tlocal xdsc = stead.call(s, 'xdsc');\n\t\treturn stead.par(stead.space_delim, xdsc, f(s, ...));\n\tend)\n\treturn v\nend)\n\nif stead.api_atleast(1, 6, 3) then\n\txwalk = xact('xwalk', code [[ stead.walk(arg1) ]]);\n\txwalk.system_type = true\nend\n\n-- vim:ts=4\n"}