{"click.lua":"require \"theme\"\nclick = {\nnam = 'click';\nobject_type = true;\nsystem_type = true;\nbg = false;\npress = false;\nbutton = false;\nsave = function(self, name, h, need)\nlocal s = stead.tostring(self.bg)\nh:write(stead.string.format(\"click[%q] = %s;\\n\", 'bg', s))\ns = stead.tostring(self.press)\nh:write(stead.string.format(\"click[%q] = %s;\\n\", 'press', s))\ns = stead.tostring(self.button)\nh:write(stead.string.format(\"click[%q] = %s;\\n\", 'button', s))\nend;\n}\nstead.module_init(function()\ninput.click = stead.hook(input.click, \nfunction(f, s, press, mb, x, y, px, py, ...)\nlocal cmd = 'click '\nlocal act = false\nif ( press or click.press ) and ( mb == 1 or click.button ) then\ncmd = cmd..stead.tostr(press)..','..stead.tostr(mb);\nif click.bg or theme.get 'scr.gfx.mode' == 'direct' then\nact = true\ncmd = cmd .. ',' .. x .. ','.. y\nend\nif px then\nact = true\ncmd = cmd .. ',' .. px .. ',' .. py\nend\nif act then\nreturn cmd\nend\nend\nreturn f(s, press, mb, x, y, px, py, ...)\nend)\nend)\ngame.action = stead.hook(game.action, \nfunction(f, s, cmd, press, mb, x, y, px, py, ...)\nif cmd == 'click' then\nlocal r,v\nlocal x2 = px\nlocal y2 = py\nif stead.tonum(mb) then\nmb = stead.tonum(mb)\nend\nif stead.tonum(px) then\nx2 = stead.tonum(px)\nend\nif stead.tonum(py) then\ny2 = stead.tonum(py)\nend\nif stead.here().click then\ns = stead.here()\nend\nif press == 'true' then\npress = true\nelse\npress = false\nend\nif s.click then\nif click.press then\nif click.button then\nr,v = stead.call(s, 'click', press, mb, stead.tonum(x), stead.tonum(y), x2, y2, ...);\nelse\nr,v = stead.call(s, 'click', press, stead.tonum(x), stead.tonum(y), x2, y2, ...);\nend\nelse\nif click.button then\nr,v = stead.call(s, 'click', mb, stead.tonum(x), stead.tonum(y), x2, y2, ...);\nelse\nr,v = stead.call(s, 'click', stead.tonum(x), stead.tonum(y), x2, y2, ...);\nend\nend\nend\nif r == nil and v == nil and not stead.api_atleast(1, 3, 5) then\nreturn nil, true\nend\nreturn r,v\nend\nreturn f(s, cmd, press, mb, x, y, px, py, ...)\nend)\n-- vim:ts=4\n","counters.lua":"if not stead.api_atleast(1, 6, 3) then\nerror (\"Counters module can not run with api version < 1.6.3\", 3)\nend\nlocal function inc_nr(v, n)\nlocal name = '__'..n..'_nr'\nif not v[name] then\nv[name] = 0\nend\nv[name] = v[name] + 1\nend\nlocal function read_nr(v, n, set)\nlocal name = '__'..n..'_nr'\nv = stead.ref(v)\nif stead.type(v) ~= 'table' then\nreturn v\nend\nif not v[name] then\nif stead.type(set) == 'number' then v[name] = set end\nreturn 0\nend\nn = v[name]\nif stead.type(set) == 'number' then v[name] = set end\nreturn n\nend\ngame.onact = stead.hook(game.onact, function(f, v, w, ...)\ninc_nr(v, 'act');\ninc_nr(w, 'act');\nreturn f(v, w, ...)\nend)\ngame.onuse = stead.hook(game.onuse, \nfunction(f, v, w, ...)\ninc_nr(v, 'use');\ninc_nr(w, 'use');\nreturn f(v, w, ...)\nend)\ngame.oninv = stead.hook(game.oninv, \nfunction(f, v, w, ...)\ninc_nr(v, 'inv');\ninc_nr(w, 'inv');\nreturn f(v, w, ...)\nend)\ngame.onwalk = stead.hook(game.onwalk, \nfunction(f, v, w, ...)\ninc_nr(v, 'walk');\ninc_nr(w, 'walk');\nreturn f(v, w, ...)\nend)\nfunction act_count(s, v)\nif not s and not v then\ns = game\nv = nil\nelseif stead.tonum(s) then\nv = s\ns = game\nend\nreturn read_nr(s, 'act', v)\nend\nfunction inv_count(s, v)\nif not s and not v then\ns = game\nv = nil\nelseif stead.tonum(s) then\nv = s\ns = game\nend\nreturn read_nr(s, 'inv', v)\nend\nfunction use_count(s, v)\nif not s and not v then\ns = game\nv = nil\nelseif stead.tonum(s) then\nv = s\ns = game\nend\nreturn read_nr(s, 'use', v)\nend\nfunction walk_count(s, v)\nif not s and not v then\ns = game\nv = nil\nelseif stead.tonum(s) then\nv = s\ns = game\nend\nreturn read_nr(s, 'walk', v)\nend\n","dash.lua":"require \"format\"\nformat.dash = true\n","dbg.lua":"-- add this: reuire \"dbg\"\n-- in your project\n-- for debug tools\nrequire \"input\"\nlocal function _xref_escape(n)\nlocal delim = ':'\nif stead.api_atleast(1, 2, 2) then\ndelim = stead.delim;\nend\nif xact then\nn = n:gsub(\"\\\\?[\\\\\"..delim..\"]\", { [delim] = \"\\\\\"..delim } )\nend\nreturn n\nend\nlocal function ordered_n(t)\nlocal ordered = {};\nlocal i,v, max;\nmax = 0;\nfor i,v in stead.pairs(t) do\nlocal o = { k = i; v = v };\nstead.table.insert(ordered, o);\nmax = max + 1;\nend\nstead.table.sort(ordered, function(a, b)\nif isObject(a.v) and not isObject(b.v) then\nreturn true\nend\nif not isObject(a.v) and isObject(b.v) then\nreturn false\nend\nif isObject(a.v) and isObject(b.v) then\nlocal n = stead.call(a.v, 'nam');\nlocal m = stead.call(b.v, 'nam');\nif stead.type(n) ~= 'string' and stead.type(m) ~= 'string' then\nreturn false\nend\nif stead.type(n) ~= 'string' then\nreturn true\nend\nif stead.type(m) ~= 'string' then\nreturn false\nend\nif n == m then\nlocal o1, o2\no1 = stead.deref(a.v)\no2 = stead.deref(b.v)\nif stead.type(o1) == 'string' and stead.type(o2) == 'string' then\nreturn o1 < o2\nend\nend\nreturn n < m;\nend\nreturn false\nend)\nordered.i = 1;\nordered.max = max;\nreturn ordered;\nend\nlocal function snext(t, k)\nlocal v\nif not k then\nk = ordered_n(t);\nend\nif k.i > k.max then\nreturn nil\nend\nv = k[k.i]\nk.i = k.i + 1\nreturn k, v.v, v.k;\nend\nlocal function spairs(s, var)\nreturn snext, s, nil;\nend\nfunction dbg_disp_obj()\nlocal v = obj {\nnam = 'disp',\nact = true,\ndsc = function(s)\nlocal r = s._txt\ns._txt = nil;\nreturn r\nend;\nsave = function(self, name, h, need)\nif need then\nh:write(stead.string.format(\"%s  = dbg_disp_obj();\\n\", name));\nend\nstead.savemembers(h, self, name, false);\nend\n}\nreturn v;\nend\ndbg_dump_obj = function(w)\nw = stead.ref(w)\nif stead.type(w) ~= 'table' then\nseen('disp')._txt = '^^No such object.';\nreturn true\nend\nlocal i,o,n\nlocal rc = ''\nfor i,o in stead.pairs(w) do\nlocal t = stead.tostring(o);\nif t == i then\nt = stead.tostr(o);\nend\nif t then\nif rc ~='' then rc = rc..'^' end\nlocal n = '';\nif isObject(o) then\nn = stead.call(o, 'nam');\nif stead.type(n) ~= 'string' then n = '' else n = ' : '..n; end\nend\nrc = stead.cat(rc, stead.par(' ', stead.tostr(i)..' : '..t..n));\nend\nend\nseen('disp')._txt = stead.cat('^^', rc)\nreturn true;\nend\ndbg_dump_globals = function()\nlocal i,o\nlocal rc=''\nif stead.type(variables) ~= 'table' then\nreturn\nend\nfor i,o in stead.ipairs(variables) do\nlocal v = _G[o];\nlocal t = stead.tostring(v);\nif t then\nif rc ~='' then rc = rc..'^' end\nrc = stead.cat(rc, stead.par(' ', stead.tostr(o)..' : '..t));\nend\nend\nseen('disp')._txt = stead.cat('^^', rc)\nreturn true;\nend\ndbg_here = function()\nreturn debug_tool._here\nend\ndbg_list_objects = function()\nlocal i,o\nlocal dis = function(o)\nif isDisabled(o) then\nreturn \", disabled\"\nend\nreturn ''\nend\nlocal rc = stead.par(' ', 'Room:'..stead.tostr(stead.deref(dbg_here())), \n'Nam:'..stead.tostr(stead.call(dbg_here(),'nam')));\nfor i,o in stead.opairs(objs(dbg_here())) do\nrc = rc..'^';\no = stead.ref(o)\nrc = stead.cat(rc, stead.par(' ', 'Id: '..stead.tostr(o.id)..', '..\nstead.tostr(stead.deref(o))..': '..stead.tostr(stead.call(o, 'nam'))..dis(o)));\nend\n--seen('disp')._txt = rc\nreturn rc\nend\ndbg_list_inv = function()\nlocal i,o\nlocal rc=''\nlocal dis = function(o)\nif isDisabled(o) then\nreturn \", disabled\"\nend\nreturn ''\nend\nlocal tak = function(o)\nif taken(o) then\nreturn \", taken\"\nend\nreturn ''\nend\nfor i,o in stead.opairs(inv()) do\nif rc ~='' then rc = rc..'^' end\no = stead.ref(o)\nrc = stead.cat(rc, stead.par(' ', 'Id: '..stead.tostr(o.id)..', '..\nstead.tostr(stead.deref(o))..': '..stead.tostr(stead.call(o, 'nam'))..dis(o)..tak(o)));\nend\nif rc == '' then return end\n--seen('disp')._txt = rc\nreturn rc\nend\ndbg_execute_cmd = room {\nnam = \"Execute Lua code\",\ndebug = true,\npic = true,\nsystem_type = true, \nforcedsc = true,\ndsc = \"Enter Lua code here to exec.\",\ninp_enter = function(s)\nif stead.type(s.obj[1]._txt) == 'string' then\nlocal f = stead.eval(s.obj[1]._txt);\nif f then\nseen('disp')._txt = stead.cat('^^', f());\nreturn true\nend\nseen('disp')._txt = \"^^Error in exec.\";\nreturn true\nend\nreturn stead.back();\nend,\nobj = { inp('inp', '{Enter cmd}: ', 'return \"Hello World!\"'), \nobj { nam = 'Back', dsc = '^{Back}', act = code [[ stead.back() ]] },\ndbg_disp_obj(),\n},\nexit = function(s)\ns.obj[1]:state(false)\nend;\n}\ndbg_dump_object = room {\nnam = \"Dump object\",\ndebug = true,\npic = true,\nsystem_type = true, \nforcedsc = true,\ndsc = \"Enter object name here to dump.\",\ninp_enter = function(s)\nlocal w = s.obj[1]._txt\nif stead.type(w) == 'string' then\nif not stead.ref(w) then w = objs(dbg_here()):srch(w); end\nreturn dbg_dump_obj(w);\nend\nreturn stead.back();\nend,\nobj = { inp('inp', '{Enter object}: ', 'main'), \nobj{nam = 'Here', dsc = '^{Dump here}', act = code[[ return dbg_dump_obj(dbg_here())]]},\nobj{nam = 'Player',dsc =  '^{Dump player}', act = code[[ return dbg_dump_obj(stead.me())]]},\nobj{nam = 'Lifes', dsc = '^{Dump lifes}', act = code[[ return dbg_dump_obj(debug_tool.lifes)]]},\nobj{nam = 'Ways', dsc = '^{Dump ways}', act = code[[ return dbg_dump_obj(ways(dbg_here()))]]},\nobj{nam = 'Globals', dsc = '^{Dump globals}', act = code [[return dbg_dump_globals()]] },\nobj{nam = 'Back', dsc = '^{Back}', act = code [[ return stead.back() ]] },\ndbg_disp_obj() },\nexit = function(s)\ns.obj[1]:state(false)\nend;\n}\ndbg_choose_location = dlg {\ndebug = true,\npic = true,\nsystem_type = true, \nforcedsc = true,\nnam = 'Go to',\ndsc = 'Select location.',\ngen = function(s)\nlocal k,v,kk\nobjs(s):zap();\nfor k,v,kk in spairs(_G) do\nif isRoom(v) and not v.debug then\nlocal n = stead.tostr(stead.call(v, 'nam'));\nlocal o = kk;\nif stead.type(o) == 'string' then\nn = n..' : '..o;\nn = _xref_escape(n);\nput(phr(n, true, [[timer:set(debug_tool._timer); game.lifes:cat(debug_tool.lifes); return stead.walk(]]..o..[[)]]), s);\nend\nend\nend\nput (phr('Back',true, 'return stead.back()'), s)\nend\n}\ndbg_choose_object = dlg {\ndebug = true,\npic = true,\nsystem_type = true, \nforcedsc = true,\nnam = 'Get object',\ndsc = 'Select object to get.',\ngen = function(s)\nlocal k,v,kk\nobjs(s):zap();\nfor k,v,kk in spairs(_G) do\nif isObject(v) and not isPhrase(v) and not isRoom(v) and not isPlayer(v) and not v.debug and not have(v) and not isStatus(v) then\nlocal n = stead.tostr(stead.call(v, 'nam'));\nlocal o = kk;\nif stead.type(o) == 'string' then\nn = n..' : '..o;\nn = _xref_escape(n);\nput(phr(n, true, o..':enable(); return take('..o..')'), s);\nend\nend\nend\nput (phr('Back',true, 'return stead.back()'), s)\nend\n}\ndbg_drop_object = dlg {\ndebug = true,\npic = true,\nforcedsc = true,\nsystem_type = true, \nnam = 'Drop object',\ndsc = 'Select object to drop.',\ngen = function(s)\nlocal k,v\nobjs(s):zap();\nfor k,v in stead.ipairs(inv()) do\nv = stead.ref(v);\nif not v.debug then\nlocal n = stead.tostr(stead.call(v, 'nam'));\nlocal o = stead.deref(v);\nif stead.type(o) == 'string' then\nn = n..' : '..o;\nn = _xref_escape(n);\nput (phr(n, true, o..':enable(); drop('..o..','..stead.deref(dbg_here())..')'), s)\nend\nend\nend\nput (phr('Back', true, 'return stead.back()'), s)\nend\n}\nfunction dbg_exit()\nlocal r\nif not stead.api_atleast(1, 2, 0) then\nr = stead.call(dbg_here(), 'dsc');\nend\ngame.lifes:cat(debug_tool.lifes);\ntimer:set(debug_tool._timer);\nreturn stead.par ('^^', stead.back(), r);\nend\ndebug_dlg = dlg {\ndebug = true,\npic = true,\nsystem_type = true, \nforcedsc = true,\nnam = 'Debug Tool',\ndsc = 'Select tool.',\nobj = {\nphr('Go to location...', true, [[pon(); dbg_choose_location:gen(); return stead.walk('dbg_choose_location')]]),\nphr('Get object...', true, [[pon(); dbg_choose_object:gen(); return stead.walk('dbg_choose_object')]]),\nphr('Put object...', true, [[pon(); dbg_drop_object:gen(); return stead.walk('dbg_drop_object')]]),\nphr('Current scene...', true, [[pon(); return dbg_list_objects();]]),\nphr('Inventory...', true, [[pon(); return dbg_list_inv();]]),\nphr('Dump object...', true, [[pon(); return stead.walk(dbg_dump_object);]]),\nphr('Exec Lua string...', true, [[pon(); return stead.walk('dbg_execute_cmd')]]),\nphr('Exit',true , [[pon(); return dbg_exit()]]),\n},\n};\ndebug_tool = menu {\ndebug = true,\nsystem_type = true,\nforcedsc = true,\nnam = txtb('debug'),\nlifes = list {},\ninv = function(s)\nif stead.here().debug then\nreturn nil, true --nothing todo\nend\ndebug_dlg.__from__ = stead.here();\ns._timer = timer:get();\ntimer:stop();\ns.lifes:zap();\ns.lifes:cat(game.lifes);\ngame.lifes:zap();\ns._here = stead.here();\nstead.me().where = 'debug_dlg'; -- force to go\nreturn stead.walk(self.where);\nend,\n};\ngame.action = stead.hook(game.action, \nfunction (f, s, cmd, ...)\nif cmd == 'use_debug' then\nreturn debug_tool:inv()\nelseif cmd == 'exit_debug' then\nstead.me().where = 'debug_dlg';\ndbg_execute_cmd.obj[1]:state(false)\ndbg_dump_object.obj[1]:state(false)\nreturn dbg_exit()\nend\nreturn f(s, cmd, ...)\nend)\nstead.module_init(function()\ninput.key = stead.hook(input.key,\nfunction(f, s, down, key, ...)\nif down and key == 'f7' then \nif stead.here().debug then\nreturn 'exit_debug'\nelse\nreturn 'use_debug'\nend\nend\nreturn f(s, down, key, ...)\nend)\nputf('debug_tool', stead.me());\nend)\n-- vim:ts=4\n","dlg.lua":"-- stead.phrase_prefix = '--'\nlocal function isValid(p)\nreturn isPhrase(p) and p.dsc and (p.ans or p.code)\nend\nlocal function isDelimiter(p)\nreturn isPhrase(p) and not isDisabled(p) and (p.dsc == nil and p.ans == nil and p.code == nil)\nend\nlocal tagpnext = function(a, k)\nif not k then\nif isPhrase(a.tag) then\nreturn 1, a.tag\nend\nif stead.type(a.tag) == 'number' then\nlocal r = a.s:phrase(a.tag)\nif r then return 1, r end\nreturn\nend\nk = {}\nlocal r,v \nfor r,v in stead.opairs(a.s.obj) do\nv = stead.ref(v)\nif isPhrase(v) and v.tag == a.tag then\nstead.table.insert(k, v)\nend\nend\nk.i = 0\nk.n = stead.table.maxn(k)\nend\nif k == 1 or k.i >= k.n then\nreturn nil\nend\nk.i = k.i + 1\nreturn k, k[k.i]\nend\nlocal function phrases(s, tag)\nlocal a = { s = s, tag = tag }\nreturn tagpnext, a, nil;\nend\nstead.phrase_seen = function(s, enb, ...)\nlocal i, ph, k\nlocal a = {...}\nif stead.table.maxn(a) == 0 then\nstead.table.insert(a, stead.cctx().self);\nend\nfor i=1,stead.table.maxn(a) do\nlocal r\nfor k, ph in phrases(s, a[i]) do\nr = isPhrase(ph) and not isRemoved(ph) and not ph:disabled();\nif r then \nbreak \nend\nend\nif enb then r = not r end\nif r then return false end\nend\nreturn true\nend\nlocal function ponoff(s, on, ...)\nlocal i, ph, k\nlocal a = {...}\nif stead.table.maxn(a) == 0 then\nstead.table.insert(a, stead.cctx().self)\nend\nfor i=1,stead.table.maxn(a) do\nfor k, ph in phrases(s, a[i]) do\nif isPhrase(ph) and not isRemoved(ph) then\nif on then\nph:enable();\nelse \nph:disable();\nend\nend\nend\nend\nend\nstead.dialog_prem = function(s, ...)\nlocal i, ph, k\nlocal a = {...}\nif stead.table.maxn(a) == 0 then\nstead.table.insert(a, stead.cctx().self);\nend\nfor i=1,stead.table.maxn(a) do\nfor k, ph in phrases(s, a[i]) do\nif isPhrase(ph) then\nph:remove();\nend\nend\nend\nend\nstead.dialog_pon = function(self,...)\nreturn ponoff(self, true, ...);\nend\nstead.dialog_poff = function(self,...)\nreturn ponoff(self, false, ...);\nend\nlocal function phr_get(self)\nlocal n = #self.__phr_stack;\nif n == 0 then return 1 end\nreturn self.__phr_stack[n];\nend\nlocal function phr_pop(self)\nlocal n = #self.__phr_stack;\nif n <= 1 then return false end\nstead.table.remove(stead.here().__phr_stack, n)\nreturn true\nend\nlocal function call_empty(self)\nlocal ph = self:phrase(phr_get(self))\nlocal r \nif not isPhrase(ph) or isDisabled(ph) or not ph.empty then\nself:pret()\nreturn\nend\nr = stead.call(ph, \"empty\")\nif stead.type(r) == 'string' then\nstead.p(r)\nend\nreturn r\nend\nlocal function call_enter(ph)\nlocal r, n\nif not isPhrase(ph) or isDisabled(ph) then\nreturn\nend\nif isValid(ph) then\nreturn\nend\nr = stead.call(ph, 'dsc')\nif stead.type(r) == 'string' then\nstead.p(r)\nend\nend\nlocal function dialog_reset(self)\nlocal i,ph\nfor i,ph in stead.pairs(self.obj) do\nif isPhrase(ph) then\nph.nam = ''\nend\nend\nend\nstead.dialog_look = function(self)\nlocal i,n,v,ph,ii\nn = 1\nlocal start = phr_get(self)\ndialog_reset(self)\nfor i,ph,ii in stead.opairs(self.obj) do\nif ii >= start then\nif ii ~= start and isDelimiter(ph) then\nbreak\nend\nif isPhrase(ph) and not isDisabled(ph) and isValid(ph) then\nph.nam = stead.tostr(n)\nif stead.type(stead.phrase_prefix) == 'string' then\nv = stead.par('^', v, stead.cat(stead.phrase_prefix, ph:look()));\nelse\nv = stead.par('^', v, txtnm(n, ph:look()))\nend\nn = n + 1\nend\nend\nend\nreturn v;\nend\nstead.dialog_rescan = function(self, naming, from)\nlocal i,k,ph,ii, start\nk = 0\nif stead.type(from) == 'number' then\nstart = from\nelseif stead.type(from) == 'string' then\nph, start = self:phrase(from)\nelse\nstart = phr_get(self)\nend\nfor i,ph,ii in stead.opairs(self.obj) do\nif ii >= start then\nif ii ~= start and isDelimiter(ph) then\nbreak\nend\nif isPhrase(ph) and not isDisabled(ph) and isValid(ph) then\nk = k + 1;\nif naming then\nph.nam = stead.tostr(k)\nend\nend\nend\nend\nif k == 0 then\nreturn false\nend\nreturn k\nend\nstead.dialog_enter = function(self)\nif self:empty(self) then\nreturn nil, false\nend\nreturn nil, true\nend\nstead.dialog_current = function(self, w, ...)\nlocal r = phr_get(self)\nif w then\nlocal ph, i = self:phrase(w)\nif ph then\nself.__phr_stack = { i }\nend\nend\nreturn r\nend\nstead.dialog_curtag = function(self, w, ...)\nlocal p = self:phrase(phr_get(self))\nif w then\nself:current(w)\nend\nif not isPhrase(p) then\nreturn\nend\nreturn p.tag\nend\nstead.dialog_empty = function(self, from)\nreturn (stead.dialog_rescan(self, false, from) == false)\nend\nstead.dialog_visible = function(self, from)\nlocal r = stead.dialog_rescan(self, false, from);\nif not r then r = 0 end\nreturn r\nend\nstead.dialog_pjump = function(self, w)\nlocal ph, i = self:phrase(w)\nif not ph then\nreturn\nend\nlocal n = #self.__phr_stack;\nif n == 0 then\nstead.table.insert(self.__phr_stack, i);\nelse\nself.__phr_stack[n] = i\nend\ncall_enter(ph)\nstead.cctx().action = true\nreturn\nend\nfunction pjump(w)\nif not isDialog(stead.here()) then\nreturn false\nend\nreturn stead.here():pjump(w)\nend\nstead.dialog_pstart = function(self, w)\nif not w then \nw = 1 \nend\nlocal ph, i = self:phrase(w)\nif not ph then\nreturn\nend\nself.__phr_stack = { i }\ncall_enter(ph)\nstead.cctx().action = true\nreturn\nend\nfunction pstart(w)\nif not isDialog(stead.here()) then\nreturn\nend\nstead.here():pstart(w)\nend\nstead.dialog_psub = function(self, w)\nlocal ph, i = self:phrase(w)\nif not ph then\nreturn\nend\nstead.table.insert(self.__phr_stack, i);\ncall_enter(ph)\nstead.cctx().action = true\nreturn\nend\nfunction psub(w)\nif not isDialog(stead.here()) then\nreturn false\nend\nreturn stead.here():psub(w)\nend\nstead.dialog_pret = function(self)\nif not phr_pop(self) then\nreturn\nend\nstead.cctx().action = true\nif not self:empty() then\nreturn\nend\ncall_empty(self)\nreturn\nend\nfunction pret()\nif not isDialog(stead.here()) then\nreturn\nend\nreturn stead.here():pret()\nend\nfunction phr(ask, answ, act)\nlocal i = 1\nlocal dis = false\nif stead.type(ask) ~= 'table' then -- old style\nlocal p = phrase ( { dsc = ask, ans = answ, code = act });\nreturn p\nend\nlocal v = ask\nif stead.type(v[1]) == 'number' then -- just skip number\ni = i + 1\nend\nif stead.type(v[i]) == 'boolean' then\ndis = not v[i]\ni = i + 1\nend\nif v.dsc == nil then\nv.dsc = v[i];\ni = i + 1\nend\nif v.ans == nil then\nv.ans = v[i];\ni = i + 1\nend\nif v.code == nil and (stead.type(v[i]) == 'function' or stead.type(v[i]) == 'string') then\nv.code = v[i];\nend\nv = phrase(v)\nif dis then\nv = v:disable()\nend\nreturn v;\nend\nfunction _phr(ask, answ, act) -- compat only?\nlocal p = phr(ask, answ, act);\np:disable()\nreturn p\nend\nstead.phr = phr\nstead.phrase_save = function(self, name, h, need)\nif need then\nlocal m = \" = phrase {\"\nlocal post = '}\\n'\nif isDisabled(self) then\npost = \"}:disable()\\n\"\nend\nm = stead.string.format(\"%s%s\", name, m);\nif self.dsc then\nm = m..stead.string.format(\"dsc = %s, \", stead.tostring(self.dsc));\nend\nif self.ans then\nm = m..stead.string.format(\"ans = %s, \", stead.tostring(self.ans));\nend\nif self.code then\nm = m..stead.string.format(\"code = %s, \", stead.tostring(self.code));\nend\nif self.tag then\nm = m..stead.string.format(\"tag = %s, \", stead.tostring(self.tag));\nend\nif self.always then\nm = m..stead.string.format(\"always = %s, \", stead.tostring(self.always));\nend\nif self.empty then\nm = m..stead.string.format(\"empty = %s, \", stead.tostring(self.empty));\nend\nh:write(m..post);\nend\nstead.savemembers(h, self, name, false);\nend\nlocal function dialog_phr2obj(self)\nlocal k, v, n\nlocal aliases = {}\nif stead.type(self.phr) ~= 'table' then\nreturn\nend\nn = 0\nfor k, v in ipairs(self.phr) do\nif stead.type(v) == 'table' then\nif stead.type(v[1]) == 'number' then\nn = v[1]\nelse\nn = n + 1\nend\nlocal p = stead.phr(v)\nif self.obj[n] then\nerror (\"Error in phr structure (numbering).\", 4);\nend\nif v.alias then\np.alias = v.alias\nstead.table.insert(aliases, n);\nend\nself.obj[n] = p\nelse\nerror (\"Error in phr structure (wrong item).\", 4);\nend\nend\nfor k, v in ipairs(aliases) do\nlocal ph = self:phrase(self.obj[v].alias)\nif not ph then\nerror (\"Wrong alias in dlg.\", 3);\nend\nself.obj[v] = ph\nend\nend\nstead.dialog_phrase = function(self, num)\nif not num then\nreturn\nend\nif isPhrase(num) then\nreturn num\nend\nif stead.type(num) ~= 'number' then\nlocal k,v,i\nfor k,v,i in stead.opairs(self.obj) do\nv = stead.ref(v)\nif isPhrase(v) and v.tag == num then\nreturn v, i\nend\nend\nreturn nil\nend\nreturn stead.ref(self.obj[num]), num;\nend\nstead.phrase_action = function(self)\nlocal ph = self;\nlocal r, ret;\nlocal empty\nif isDisabled(ph) then\nreturn nil, false\nend\n-- here it is\nif not ph.always then\nph:disable(); -- /* disable it!!! */\nend\nlocal last = stead.call(ph, 'ans');\nif stead.type(ph.code) == 'string' then\nlocal f = stead.eval(ph.code);\nif f ~= nil then\nret = f();\nelse\nerror (\"Error while eval phrase action:\"..ph.code);\nend\nelseif stead.type(ph.code) == 'function' then\nret = ph.code(self);\nend\nif ret == nil then ret = stead.pget(); end\nif last == true or ret == true then\nr = true;\nend\nif isDialog(stead.here()) and stead.here():empty() then\nempty = call_empty(stead.here());\nend\nlocal wh = stead.here();\nwhile isDialog(wh) and wh:empty() and stead.from(wh) ~= wh do\nwh = stead.from(wh)\nend\nif wh ~= stead.here() then\nret = stead.par(stead.scene_delim, ret, stead.back(wh));\nend\nret = stead.par(stead.space_delim, last, empty, ret);\nif ret == nil then\nreturn r -- hack?\nend\nreturn ret\nend\nfunction dlg(v) --constructor\nv.dialog_type = true;\nif v.ini == nil then\nv.ini = function(s)\nstead.dialog_rescan(s, true);\nend\nend\nif v.enter == nil then\nv.enter = stead.dialog_enter;\nend\nif v.look == nil then\nv.look = stead.dialog_look;\nend\nif v.scene == nil then\nv.scene = stead.dialog_scene;\nend\nif v.pon == nil then\nv.pon = stead.dialog_pon;\nend\nif v.poff == nil then\nv.poff = stead.dialog_poff;\nend\nif v.prem == nil then\nv.prem = stead.dialog_prem;\nend\nif v.pseen == nil then\nv.pseen = stead.dialog_pseen;\nend\nif v.punseen == nil then\nv.punseen = stead.dialog_punseen;\nend\nif v.empty == nil then\nv.empty = stead.dialog_empty;\nend\nif v.visible == nil then\nv.visible = stead.dialog_visible;\nend\nif v.current == nil then\nv.current = stead.dialog_current\nend\nif v.curtag == nil then\nv.curtag = stead.dialog_curtag\nend\nif v.pstart == nil then\nv.pstart = stead.dialog_pstart\nend\nif v.pjump == nil then\nv.pjump = stead.dialog_pjump\nend\nif v.pret == nil then\nv.pret = stead.dialog_pret\nend\nif v.psub == nil then\nv.psub = stead.dialog_psub\nend\nif v.phrase == nil then\nv.phrase = stead.dialog_phrase\nend\nif v.dsc == nil then\nv.dsc = function(s)\nif stead.player_moved() then\nstead.last_act(false)\nelseif stead.type(ACTION_TEXT) ~= 'string' and stead.last_act() then\nstead.p(stead.last_act())\nend\nend\nend\nv = room(v);\nv.__phr_stack = { 1 }\ndialog_phr2obj(v);\nreturn v;\nend\n","events.lua":"game.action = stead.hook(game.action, function(f, s, cmd, ...)\nif cmd == 'user_event' then\nlocal r,v;\nr, v = stead.call(stead, 'event', ... );\nreturn r,v\nend\nreturn f(s, cmd, ...);\nend)\nstead.module_init(function()\ninput.event = stead.hook(input.event, function(f, s, ev, ...)\nif type(stead.event) == 'function' then\nreturn 'user_event,'..tostring(ev)\nend\nreturn f(s, ev, ...)\nend)\nend)\n-- vim:ts=4\n","finger.lua":"require \"theme\"\nfinger = {\nnam = 'finger';\nobject_type = true;\nsystem_type = true;\nfingers_list = { };\nadd = function(s, press, fid, x, y, px, py)\nif press then\nlocal v = s:lookup(fid)\nif v then\nv.x, v.y, v.px, v.py = x, y, px, py\nelse\nstead.table.insert(s.fingers_list, \n{ id = fid, x = x, y = y, px = px, py = py })\nend\nreturn\nend\nlocal v, k\nv, k = s:lookup(fid)\nif k then\nstead.table.remove(s.fingers_list, k)\nreturn\nend \nend;\nlist = function(s)\nlocal k,v\nlocal new = {}\nfor k,v in stead.ipairs(s.fingers_list) do\nlocal x, y, pressure\nx, y, pressure = stead.finger_pos(v.id)\nif x then\nv.x, v.y, v.pressure = x, y, pressure\nstead.table.insert(new, v)\nend\nend\ns.fingers_list = new\nreturn new\nend;\nget = function(s, fid)\nlocal v,k\nlocal x, y, pressure\nx, y, pressure = stead.finger_pos(fid)\nif not x then\nv, k = s:lookup(fid)\nif k then\nstead.table.remove(s.fingers_list, k)\nend\nreturn\nend\nreturn x, y, pressure\nend;\nlookup = function(s, fid)\nlocal k,v\nfor k,v in stead.ipairs(s.fingers_list) do\nif v.id == fid then\nreturn v, k\nend\nend\nend;\n}\nstead.module_init(function()\ninput.finger = function(s, press, fid, x, y, px, py, ...)\nfinger:add(press, fid, x, y, px, py, ...)\nlocal cmd = 'finger '\ncmd = cmd..stead.tostr(press)..','..stead.tostr(fid)..',' .. x .. ','.. y;\nif px then\ncmd = cmd .. ',' .. px .. ',' .. py\nend\nreturn cmd\nend\nend)\ngame.action = stead.hook(game.action, \nfunction(f, s, cmd, press, fid, x, y, px, py, ...)\nif cmd == 'finger' then\nlocal r,v\nlocal x2 = px\nlocal y2 = py\nif stead.here().finger then\ns = stead.here()\nend\nif not s.finger then\nreturn\nend\nif stead.tonum(px) then\nx2 = stead.tonum(px)\nend\nif stead.tonum(py) then\ny2 = stead.tonum(py)\nend\nif press == 'true' then\npress = true\nelse\npress = false\nend\nr,v = stead.call(s, 'finger', press, fid, stead.tonum(x), stead.tonum(y), x2, y2, ...);\nreturn r,v\nend\nreturn f(s, cmd, press, fid, x, y, px, py, ...)\nend)\n-- vim:ts=4\n","format.lua":"format = {\nnam = 'format';\nobject_type = true;\nsystem_type = true;\npara = false;\npara_space = '    ';\nquotes = false;\ndash = false;\nfilter = nil;\nnopara = '_';\nsave = function(self, name, h, need)\nlocal k,v\nfor k,v in stead.pairs(self) do\nif k == 'para' or k == 'para_space' or k == 'quotes' or\n    k == 'dash' or k == 'nopara' then\nlocal s = stead.tostring(v)\nh:write(stead.string.format(\"format[%q] = %s;\\n\", k, s))\nend\nend\nend;\n}\nstead.fmt = stead.hook(stead.fmt, function(f, ...)\nlocal utf8\nlocal r = f(...)\nif game.codepage == 'UTF-8' or game.codepage == 'utf-8' then\nutf8 = true\nend\nif stead.type(r) == 'string' and stead.state then\nif stead.type(format.filter) == 'function' and stead.state then\nr = format.filter(r);\nend\nif stead.call_bool(format, 'dash') and utf8 then\nr = r:gsub('([^-])%-%-([^-])', '%1—%2');\nr = r:gsub('^%-%-([^-])', '—%1');\nend\nif stead.call_bool(format, 'quotes') and utf8 then\nr = r:gsub('_\"','«'):gsub('\"_',\"»\");\nr = r:gsub('\"([^\"]*)\"','«%1»');\nr = r:gsub(',,','„'):gsub(\"''\",'”');\nend\nif stead.call_bool(format, 'para') then\nr = r:gsub('\\n([^\\n])', '<&para;>%1'):gsub('<&para;>[ \\t]*'..format.nopara,'\\n'):gsub('<&para;>[ \\t]*', '\\n'..txtnb(format.para_space));\nr = r:gsub('^[ \\t]*', '<&para;>'):gsub('<&para;>[ \\t]*'..format.nopara,''):gsub('<&para;>[ \\t]*', txtnb(format.para_space));\nend\nend\nreturn r;\nend)\n-- vim:ts=4\n","gui.lua":"game.hinting = true;\ngame.showlast = true;\ngame.gui = { \nfading = 4; \nways_delim = ' | ';\ninv_delim = '\\n';\nhinv_delim = ' | ';\nhideways = false;\nhideinv = false;\nhidetitle = false;\n}\niface.xref = function(self, str, obj, ...)\nlocal o = stead.ref(obj);\nlocal cmd=''\nif not isObject(o) or isStatus(o) or (not o.id and not isXaction(o)) then\nreturn str;\nend\nif stead.ref(ways():srch(obj)) then\ncmd = 'go ';\nelseif isMenu(o) then\ncmd = 'act ';\nelseif isSceneUse(o) then\ncmd = 'use ';\nelseif isXaction(o) and not o.id then\ncmd = 'act ';\nend\nlocal a = ''\nlocal i\nlocal varg = {...}\nfor i = 1, stead.table.maxn(varg) do\na = a..','..varg[i]\nend\nif isXaction(o) and not o.id then\nreturn stead.cat('<a:'..cmd..stead.deref(obj)..a..'>',str,'</a>');\nend\nreturn stead.cat('<a:'..cmd..'0'..stead.tostr(o.id)..a..'>',str,'</a>');\nend;\niface.anchor = function(self)\nreturn '<a:#>'\nend\niface.enum = function(self, n, str)\nif str == nil or n == nil then return nil; end;\nreturn n..self:nb(' - ')..str;\nend\niface.title = function(self, str)\nreturn nil\nend;\niface.img = function(self, str)\nif str == nil then return nil; end;\nreturn \"<g:\"..str..\">\";\nend;\niface.imgl = function(self, str)\nif str == nil then return nil; end;\nreturn \"<g:\"..str..\"\\\\|left>\";\nend;\niface.imgr = function(self, str)\nif str == nil then return nil; end;\nreturn \"<g:\"..str..\"\\\\|right>\";\nend;\niface.nb = function(self, str)\nif stead.type(str) ~= 'string' then return nil end\nreturn \"<w:\"..str:gsub(\"\\\\\", \"\\\\\\\\\\\\\\\\\"):gsub(\">\",\"\\\\>\"):gsub(\"%^\",\"\\\\^\")..\">\";\nend;\niface.under = function(self, str)\nif str == nil then return nil; end; \nreturn stead.cat('<u>',str,'</u>');\nend;\niface.em = function(self, str)\nif str == nil then return nil; end;\nreturn stead.cat('<i>',str,'</i>');\nend;\niface.st = function(self, str)\nif str == nil then return nil; end;\nreturn stead.cat('<s>',str,'</s>');\nend;\niface.right = function(self, str)\nif str == nil then return nil; end; \nreturn stead.cat('<r>',str,'</r>');\nend;\niface.left = function(self, str)\nif str == nil then return nil; end;\nreturn stead.cat('<l>',str,'</l>');\nend;\niface.center = function(self, str)\nif str == nil then return nil; end;\nreturn stead.cat('<c>',str,'</c>');\nend;\niface.just = function(self, str)\nif str == nil then return nil; end;\nreturn stead.cat('<j>',str,'</j>');\nend;\niface.tab = function(self, str, al)\nif stead.tonum(str) then\nstr = stead.tostr(str)\nend\nif stead.type(str) ~= 'string' then\nreturn nil;\nend\nif al == 'right' then\nstr = str .. \",right\"\nelseif al == 'center' then\nstr = str .. \",center\"\nend\nreturn '<x:'..str..'>'\nend;\niface.y = function(self, str, al)\nif stead.tonum(str) then\nstr = stead.tostr(str)\nend\nif stead.type(str) ~= 'string' then\nreturn nil;\nend\nif al == 'middle' then\nstr = str .. \",middle\"\nelseif al == 'top' then\nstr = str .. \",top\"\nend\nreturn '<y:'..str..'>'\nend;\niface.bold = function(self, str)\nif str == nil then return nil; end;\nreturn stead.cat('<b>',str,'</b>');\nend;\niface.top = function(self, str)\nif str == nil then return nil; end;\nreturn stead.cat('<t>',str,'</t>');\nend;\niface.bottom = function(self, str)\nif str == nil then return nil; end;\nreturn stead.cat('<d>',str,'</d>');\nend;\niface.middle = function(self, str)\nif str == nil then return nil; end;\nreturn stead.cat('<m>',str,'</m>');\nend;\niface.inv = function(self, str)\nreturn str\nend;\niface.ways = function(self, str)\nreturn str\nend;\ninstead.get_inv = function(horiz)\nlocal r = stead.call_value(game.gui, 'hideinv');\nif r then\nreturn\nend\nlocal str = iface:cmd(\"inv\");\nif str then\nstr = stead.string.gsub(str, '\\n$','');\nif not horiz then\nstr = stead.string.gsub(str, '\\\\?['.. stead.delim ..']', \n{ [stead.delim] = game.gui.inv_delim, ['\\\\'..stead.delim] = stead.delim });\nelse\nstr = stead.string.gsub(str, '\\\\?['.. stead.delim ..']', \n{ [stead.delim] = game.gui.hinv_delim, ['\\\\'..stead.delim] = stead.delim });\nend\nend\nreturn str\nend\ninstead.get_ways = function()\nlocal r = stead.call_value(game.gui, 'hideways');\nif r then\nreturn\nend\nlocal str = iface:cmd(\"way\");\nif str and str ~= '' then\nstr = stead.string.gsub(str, '\\n$','');\nstr = stead.string.gsub(str, '\\\\?['..stead.delim ..']', \n{ [stead.delim] = game.gui.ways_delim, [ '\\\\'..stead.delim ] = stead.delim });\nreturn iface:center(str);\nend\nreturn str\nend\ninstead.get_title = function()\nlocal r = stead.call_value(game.gui, 'hidetitle');\nif r then\nreturn\nend\nlocal s\nif stead.api_atleast(1, 2, 0) then\ns = stead.dispof(stead.here());\nelse\ns = stead.call(stead.here(), 'nam');\nend\nif stead.type(s) == 'string' and s ~= '' then\nstead.state = false\ns = \"<c><b>\"..stead.fmt(s)..\"</b></c>\";\ns = stead.string.gsub(s, '\\\\'..stead.delim, stead.delim);\nend\nreturn s\nend\ninstead.finish_music = function()\nif instead.get_music_loop() == 0 then\nreturn false\nend\nlocal n = stead.get_music()\nstead.set_music(n, -1);\nreturn true\nend\ninstead.isEnableSave = isEnableSave;\ninstead.isEnableAutosave = isEnableAutosave;\n-- here is gui staff only\nfunction stat(v)\nv.status_type = true\nreturn obj(v);\nend\nfunction isStatus(v)\nif stead.type(v) ~= 'table' then\nreturn false\nend\nif v.status_type then\nreturn true\nend\nreturn false\nend\nstead.menu_save = function(self, name, h, need)\nlocal dsc;\nif need then\nprint (\"Warning: menu \"..name..\" can not be saved!\");\nreturn\nend\nstead.savemembers(h, self, name, need);\nend\nMENU_TAG_ID = 1000000\nfunction menu(v)\nv.menu_type = true\nif v.inv == nil then\nv.inv = function(s)\nlocal r,v\nr,v = stead.call(s, 'menu');\nif v == nil then v = true end\nif r == nil then\nstead.obj_tag(stead.me(), MENU_TAG_ID); -- retag menu field\nend\nreturn r, v\nend\nend\nif v.act == nil then\nv.act = function(s)\nlocal r,v\nr,v = stead.call(s, 'menu');\nif v == nil then v = true end\nif r == nil then\nstead.obj_tag(stead.me(), MENU_TAG_ID); -- retag menu field\nend\nreturn r, v\nend\nend\nif v.save == nil then\nv.save = stead.menu_save;\nend\nreturn obj(v);\nend\nfunction isMenu(v)\nif stead.type(v) ~= 'table' then\nreturn false\nend\nif v.menu_type then\nreturn true\nend\nreturn false\nend\nstead.fmt = function(...)\nlocal i, res\nlocal a={...}\nfor i=1,stead.table.maxn(a) do\nif stead.type(a[i]) == 'string' then\nlocal s = stead.string.gsub(a[i],'\\t', stead.space_delim):gsub('[\\n]+', stead.space_delim);\ns = stead.string.gsub(s, '\\\\?[\\\\^]', { ['^'] = '\\n', ['\\\\^'] = '^',\n['\\\\\\\\'] = '\\\\' });\nres = stead.par('', res, s);\nend\nend\nreturn res\nend\ngame.fading = function(s)\nlocal rc = false\nlocal p = stead.call(stead.here(), 'pic');\nif stead.cmd == 'load' then\ngame.lastpic = p;\nreturn true\nend\nif not stead.state then --only for states!!!\nreturn false\nend\nif game._time == 1 then -- first cmd\ngame.lastpic = p;\nreturn true\nend\nif PLAYER_MOVED or game.lastpic ~= p then\nrc = true\nend\ngame.lastpic = p\nreturn rc\nend\ngame.gui.is_fading = function() --to check fading from sdl gui\nlocal r,g,v\nlocal h = stead.here()\nif not isRoom(h) then\nreturn false\nend\nr,v = stead.call_value(h, 'fading');\nif r then\nif stead.tonum(r) and v == nil then\nreturn true, stead.tonum(r)\nend\nreturn r, v\nend\ng,v = stead.call_value(game, 'fading');\nif stead.tonum(g) and v == nil then\nreturn true, stead.tonum(g)\nend\nreturn g, v\nend\ninstead.get_fading = function()\nlocal r, v\nr, v = stead.call_value(game.gui, 'is_fading')\nif v == nil and r then v = game.gui.fading end\nreturn r,v\nend\n-- vim:ts=4\n","hideinv.lua":"local attr = \"hideinv\"\nif stead.api_atleast(1, 6, 3) then\ngame.gui.hideinv = function(s)\nif stead.call_bool(stead.here(), 'hideinv') then\nreturn true\nend\nend\nattr = \"noinv\"\nend\nroom = stead.inherit(room, function(v)\nv.entered = stead.hook(v.entered, function(f, s, ...)\nif stead.call_bool(s, attr) then\nme():disable_all();\nend\nreturn f(s, ...)\nend)\nv.left = stead.hook(v.left, function(f, s, ...)\nif stead.call_bool(s, attr) then\nme():enable_all();\nend\nreturn f(s, ...)\nend)\nreturn v\nend)\n","hotkeys.lua":"require 'kbd'\nstead.module_init(function()\nhook_keys('1','2','3','4','5','6','7','8','9','0');\nend)\ngame.kbd = stead.hook(game.kbd, function(f, s, down, key, ...)\nif down and key >= '0' and key <= '9' then\nif isDialog(stead.here()) then\nif key == '0' then key = '10' end\nlocal p = stead.here():srch(key);\nif p and stead.nameof(p) == key then\nreturn stead.call(p, 'act');\nend\nend\nreturn\nend\nreturn f(s, down, key, ...);\nend)\n-- vim:ts=4\n","input.lua":"local kbden = {\nshifted = {\n[\"1\"] = \"!\",\n[\"2\"] = \"@\",\n[\"3\"] = \"#\",\n[\"4\"] = \"$\",\n[\"5\"] = \"%\",\n[\"6\"] = \"^\",\n[\"7\"] = \"&\",\n[\"8\"] = \"*\",\n[\"9\"] = \"(\",\n[\"0\"] = \")\",\n[\"-\"] = \"_\",\n[\"=\"] = \"+\",\n[\"[\"] = \"{\",\n[\"]\"] = \"}\",\n[\"\\\\\"] = \"|\",\n[\";\"] = \":\",\n[\"'\"] = \"\\\"\",\n[\",\"] = \"<\",\n[\".\"] = \">\",\n[\"/\"] = \"?\",\n}\n}\nlocal kbdru = {\n[\"q\"] = \"й\",\n[\"w\"] = \"ц\",\n[\"e\"] = \"у\",\n[\"r\"] = \"к\",\n[\"t\"] = \"е\",\n[\"y\"] = \"н\",\n[\"u\"] = \"г\",\n[\"i\"] = \"ш\",\n[\"o\"] = \"щ\",\n[\"p\"] = \"з\",\n[\"[\"] = \"х\",\n[\"]\"] = \"ъ\",\n[\"a\"] = \"ф\",\n[\"s\"] = \"ы\",\n[\"d\"] = \"в\",\n[\"f\"] = \"а\",\n[\"g\"] = \"п\",\n[\"h\"] = \"р\",\n[\"j\"] = \"о\",\n[\"k\"] = \"л\",\n[\"l\"] = \"д\",\n[\";\"] = \"ж\",\n[\"'\"] = \"э\",\n[\"z\"] = \"я\",\n[\"x\"] = \"ч\",\n[\"c\"] = \"с\",\n[\"v\"] = \"м\",\n[\"b\"] = \"и\",\n[\"n\"] = \"т\",\n[\"m\"] = \"ь\",\n[\",\"] = \"б\",\n[\".\"] = \"ю\",\n[\"`\"] = \"ё\",\nshifted = {\n[\"q\"] = \"Й\",\n[\"w\"] = \"Ц\",\n[\"e\"] = \"У\",\n[\"r\"] = \"К\",\n[\"t\"] = \"Е\",\n[\"y\"] = \"Н\",\n[\"u\"] = \"Г\",\n[\"i\"] = \"Ш\",\n[\"o\"] = \"Щ\",\n[\"p\"] = \"З\",\n[\"[\"] = \"Х\",\n[\"]\"] = \"Ъ\",\n[\"a\"] = \"Ф\",\n[\"s\"] = \"Ы\",\n[\"d\"] = \"В\",\n[\"f\"] = \"А\",\n[\"g\"] = \"П\",\n[\"h\"] = \"Р\",\n[\"j\"] = \"О\",\n[\"k\"] = \"Л\",\n[\"l\"] = \"Д\",\n[\";\"] = \"Ж\",\n[\"'\"] = \"Э\",\n[\"z\"] = \"Я\",\n[\"x\"] = \"Ч\",\n[\"c\"] = \"С\",\n[\"v\"] = \"М\",\n[\"b\"] = \"И\",\n[\"n\"] = \"Т\",\n[\"m\"] = \"Ь\",\n[\",\"] = \"Б\",\n[\".\"] = \"Ю\",\n[\"`\"] = \"Ё\",\n[\"1\"] = \"!\",\n[\"2\"] = \"@\",\n[\"3\"] = \"#\",\n[\"4\"] = \";\",\n[\"5\"] = \"%\",\n[\"6\"] = \":\",\n[\"7\"] = \"?\",\n[\"8\"] = \"*\",\n[\"9\"] = \"(\",\n[\"0\"] = \")\",\n[\"-\"] = \"_\",\n[\"=\"] = \"+\",\n}\n}\nlocal kbdlower = {\n['А'] = 'а',\n['Б'] = 'б',\n['В'] = 'в',\n['Г'] = 'г',\n['Д'] = 'д',\n['Е'] = 'е',\n['Ё'] = 'ё',\n['Ж'] = 'ж',\n['З'] = 'з',\n['И'] = 'и',\n['Й'] = 'й',\n['К'] = 'к',\n['Л'] = 'л',\n['М'] = 'м',\n['Н'] = 'н',\n['О'] = 'о',\n['П'] = 'п',\n['Р'] = 'р',\n['С'] = 'с',\n['Т'] = 'т',\n['У'] = 'у',\n['Ф'] = 'ф',\n['Х'] = 'х',\n['Ц'] = 'ц',\n['Ч'] = 'ч',\n['Ш'] = 'ш',\n['Щ'] = 'щ',\n['Ъ'] = 'ъ',\n['Э'] = 'э',\n['Ь'] = 'ь',\n['Ю'] = 'ю',\n['Я'] = 'я',\n}\nlocal function tolow(s)\nif not s then\nreturn\nend\ns = s:lower();\nlocal xlat = kbdlower\nif xlat then\nlocal k,v\nfor k,v in stead.pairs(xlat) do\ns = s:gsub(k,v);\nend\nend\nreturn s;\nend\nlocal function kbdxlat(s)\nlocal kbd\nif s == 'space' then\nreturn ' '\nend\nif s == 'return' then\nreturn '\\n'\nend\nif s:len() > 1 then\nreturn\nend\nif input.kbd_alt_xlat and \n(game.codepage == 'UTF-8' or game.codepage == 'utf-8') then\nkbd = kbdru;\nelse\nkbd = kbden\nend\nif kbd and input.kbd_shift then\nkbd = kbd.shifted;\nend\nif not kbd[s] then\nif input.kbd_shift then\nreturn s:upper();\nend\nreturn s;\nend\nreturn kbd[s]\nend\ngame.action = stead.hook(game.action, function (f, s, cmd, ...)\nif cmd == 'kbd_enter' then\nlocal r,v\nif stead.here().inp_enter then\nr,v = stead.call(stead.here(), 'inp_enter');\nelseif s.inp_enter then\nr,v = stead.call(s, 'inp_enter');\nend\nreturn r,v -- nothing todo\nend\nreturn f(s, cmd, ...)\nend)\nlocal lookup_inp = function()\nlocal i,o \nfor i,o in stead.opairs(objs()) do\no = stead.ref(o)\nif o._edit then\nreturn o\nend\nend\nend\nlocal input_kbd = function(s, down, key)\nif not input._txt then\nreturn\nend\nif key:find(\"shift\") then\ninput.kbd_shift = down\nelseif key:find(\"alt\") then\nif down and input.inp_xlat then\ninput.kbd_alt_xlat = not input.kbd_alt_xlat;\nend\ninput.kbd_alt = down\nelseif down then\nlocal o = lookup_inp();\nif not o then\nreturn\nend\nif input.kbd_alt then\nreturn\nend\nif key == \"return\" then\nif o then\no._edit = false\no._txt = input._txt\ninput._txt = false\nreturn \"kbd_enter\"\nend\nreturn\nend\nif key == \"backspace\" then\nif input._txt == '' then\nreturn\nend\nif input._txt:byte(input._txt:len()) >= 128 then\ninput._txt = input._txt:sub(1, input._txt:len() - 2);\nelse\ninput._txt = input._txt:sub(1, input._txt:len() - 1);\nend\nreturn \"wait\"\nend\nlocal c = kbdxlat(key);\nif not c then return end\nif o and stead.type(o.filter) == 'function' then\nc = o:filter(c);\nif not c then return end\nend\ninput._txt = input._txt..c;\nreturn \"wait\"\nend\nend\nstead.module_init(function()\ninput.cursor = '_'\ninput.inp_xlat = true\ninput.key = stead.hook(input.key,\nfunction(f, ...)\nlocal r = input_kbd(...)\nif r then return r end\nreturn f(...)\nend)\nend)\nlocal function input_esc(s)\nlocal rep = function(s)\nreturn txtnb(s)\nend\nif not s then return end\n--return s:gsub(\"\\\\\",\"\\\\\\\\\\\\\\\\\"):gsub(\">\",\"\\\\\\\\>\"):gsub(\"%^\",\"\\\\%^\"):\nlocal r = s:gsub(\"[^ ]+\", rep):gsub(\"[ \\t]\", rep):gsub(\"{\",\"\\\\{\"):gsub(\"}\",\"\\\\}\");\nreturn r\nend\nfunction inp(n, info, txt)\nif stead.type(n) ~= 'string' or stead.type(info) ~= 'string' then\nerror (\"Wrong parameter to inp.\", 2);\nend\nlocal v = { nam = n, _txt = '', info = info }\nif txt then\nv._txt = txt\nend\nv.dsc = function(s)\nif s._edit then\nreturn s.info..input_esc(input._txt)..input.cursor\nend\nreturn s.info..input_esc(s._txt)\nend\nv.text = function(s, text)\nlocal t\nif s._edit then \nt = input._txt \nelse\nt = s._txt\nend\nif text then\nif s._edit then\ninput._txt = text\nelse\ns._txt = text\nend\nreturn\nend\nreturn t\nend\nv.match = function(s, str)\nlocal aa = tolow(tostring(str)):gsub(\"[*]\",\".*\"):gsub(\"[?]\",\".?\");\nlocal bb = tolow(tostring(s:text()));\nif bb:find(\"^\"..aa..\"$\") then\nreturn true\nend\nend\nv.state = function(s, t)\nlocal os = s._edit\nif t == nil then\nreturn os\nend\ns._edit = t\nif os and  t or (not os and not t) then\nreturn os\nend\nif s._edit then\ninput._txt = s._txt;\nelse\ns._txt = input._txt\ninput._txt = false\nend\nreturn os\nend;\nv.act = function(s)\nif input._txt and not s._edit then return true end -- somewhere else\ns:state(not s._edit)\nreturn true\nend\nv.save = function(self, name, h, need)\nif need then\nh:write(stead.string.format(\"%s = inp (%q, %q, %q);\\n\", \nname, self.nam, self.info, self._txt))\nend\nstead.savemembers(h, self, name, false);\nend\nreturn obj(v)\nend\n-- vim:ts=4\n","kbd.lua":"game.action = stead.hook(game.action, function(f, s, cmd, ...)\nif cmd == 'user_kbd' then\nlocal r,v;\nif stead.here().kbd then\nr,v = stead.call(stead.here(), 'kbd', \ninput.key_event.down, input.key_event.key);\nelseif s.kbd then\nr,v = stead.call(s, 'kbd', \ninput.key_event.down, input.key_event.key);\nend\nif r == nil and v == nil and not stead.api_atleast(1, 3, 5) then\nreturn nil, true\nend\nreturn r,v\nend\nreturn f(s, cmd, ...);\nend)\nstead.module_init(function()\ninput.key = stead.hook(input.key, function(f, s, down, key, ...)\nif input._key_hooks[key] then\ninput.key_event = { key = key, down = down };\nreturn 'user_kbd'\nend\nreturn f(s, down, key, ...)\nend)\ninput._key_hooks = {}\nend)\nstead.hook_keys = function(...)\nlocal i\nlocal a = {...};\nfor i = 1, stead.table.maxn(a) do\ninput._key_hooks[tostring(a[i])] = true;\nend\nend\nstead.unhook_keys = function(...)\nlocal i\nlocal a = {...};\nfor i = 1, stead.table.maxn(a) do\ninput._key_hooks[tostring(a[i])] = nil;\nend\nend\nhook_keys = stead.hook_keys\nunhook_keys = stead.unhook_keys\n-- vim:ts=4\n","nolife.lua":"game.life = stead.hook(game.life, function(f, ...)\nif stead.call_bool(stead.here(), 'nolife') then\nreturn\nend\nreturn f(...)\nend)\n","nouse.lua":"game.use = function(s, w, o)\nlocal r, v\nr, v = stead.call(w, 'nouse', o);\nif not r and not v then\nr, v = stead.call(o, 'noused', w);\nend\nif not r and not v then\nr, v = stead.call(s, 'nouse', w, o)\nend\nreturn r, v\nend\n","object.lua":"local function onevent(ev, ...)\nlocal vv, r\nif stead.api_atleast(1, 6, 3) then\nvv, r = stead.call(game, ev, ...);\nif r == false then\nreturn vv, false\nend\nif vv == false then\nreturn nil, false\nend\nreturn vv\nend\nend\nstead.player_action = function(self, what, ...)\nlocal v,r,obj,vv\nif isXaction(what) then -- already xact\nobj = what\nelse\nobj = _G[what];\nend\nif not isXaction(obj) then\nobj = stead.ref(self.where):srch(what);\nend\nif not obj then\nreturn stead.call(game, 'action', what, ...); --player_do(self, what, ...);\nend\nvv, r = onevent('onact', obj, ...);\nif vv == false then\nreturn\nend\nif r == false then \nreturn vv\nend\nv, r = stead.player_take(self, what, ...);\nif not v and not r then\nv, r = stead.call(obj, 'act', ...);\nif stead.type(vv) == 'string' then\nv = stead.par(stead.space_delim, vv, v);\nend\nif not v and not r then\nv, r = stead.call(game, 'act', obj, ...);\nend\nelseif stead.type(vv) == 'string' then\nv = stead.par(stead.space_delim, vv, v);\nend\nreturn v, r;\nend\nstead.player_use = function(self, what, onwhat, ...)\nlocal obj, obj2, v, vv, r;\nlocal scene_use_mode = false\nobj = _G[what];\nif isXaction(obj) then -- use xact is act\nreturn self:action(obj, onwhat, ...)\nend\nobj = self:srch(what); -- in inv?\nif not obj then -- no\nobj = stead.ref(self.where):srch(what); -- in scene?\nif not obj then -- no!\nreturn game.err, false;\nend\nscene_use_mode = true -- scene_use_mode!\nend\nobj = stead.ref(obj);\nif onwhat == nil then -- only one?\nif scene_use_mode then\nreturn self:action(what, ...); -- call act\nend\nvv, r = onevent('oninv', obj, ...);\nif vv == false then\nreturn\nend\nif r == false then\nreturn vv\nend\nv, r = stead.call(obj, 'inv', ...); -- call inv\nif stead.type(vv) == 'string' then\nv = stead.par(stead.space_delim, vv, v);\nend\nif not v and not r then\nv, r = stead.call(game, 'inv', obj, ...);\nend\nreturn v, r;\nend\nobj2 = stead.ref(self.where):srch(onwhat); -- in scene?\nif not obj2 then\nobj2 = self:srch(onwhat); -- in inv?\nend\nif not obj2 then\nreturn game.err, false;\nend\nobj2 = stead.ref(obj2)\nif not scene_use_mode or isSceneUse(obj) then\nvv, r = onevent('onuse', obj, obj2, ...);\nif vv == false then\nreturn\nend\nif r == false then \nreturn vv \nend\nv, r = stead.call(obj, 'use', obj2, ...);\nif stead.type(vv) == 'string' then\nv = stead.par(stead.space_delim, vv, v);\nend\nif r ~= false then\nvv = stead.call(obj2, 'used', obj, ...);\nif stead.type(vv) == 'string' then\nv = stead.par(stead.space_delim, v, vv);\nend\nend\nend\nif v == nil and vv == true and stead.api_atleast(1, 7, 1) then\nv = true\nend\nif not v then\nv, r = stead.call(game, 'use', obj, obj2, ...);\nend\n--if v == nil and stead.api_version >= \"1.3.5\" then\n--return true\n--end\nreturn v\nend\nstead.vobj_save = function(self, name, h, need)\nlocal w = stead.deref(self.where)\nlocal dsc = self.dsc\nif need then\nh:write(stead.string.format(\"%s  = vobj(%s,%s,%s);\\n\",\nname, \nstead.tostring(self.nam), \nstead.tostring(dsc), \nstead.tostring(w)));\nend\nstead.savemembers(h, self, name, false);\nend\nstead.vobj_act = function(self, ...)\nlocal o, r = stead.here():srch(self); -- self.nam\nif stead.ref(o) and stead.ref(o).where then\nreturn stead.walk(stead.ref(o).where);\nend\nreturn stead.call(stead.ref(r),'act', self.nam, ...);\nend\nstead.vobj_used = function(self, ...)\nlocal o, r = stead.here():srch(self.nam);\nreturn stead.call(stead.ref(r),'used', self.nam, ...);\nend\nstead.vobj_use = function(self, ...)\nlocal o, r = stead.here():srch(self.nam);\nreturn stead.call(stead.ref(r),'use', self.nam, ...);\nend\nfunction vobj(name, dsc, w)\nreturn obj{ nam = stead.tostr(name), \nvobject_type = true,\ndsc = dsc, \nwhere = stead.deref(w), \nact = stead.vobj_act, \nused = stead.vobj_used, \nuse = stead.vobj_use,\nsave = stead.vobj_save };\nend\nfunction vway(name, dsc, w)\n--o.object_type = true;\nreturn  obj{ nam = stead.tostr(name), \nvobject_type = true,\ndsc = dsc, \nact = stead.vobj_act, \nwhere = stead.deref(w), \nused = stead.vobj_used,\nuse = stead.vobj_use, \nsave = stead.vobj_save };\nend\nfunction isVobject(v)\nreturn (stead.type(v) == 'table') and (v.vobject_type)\nend\nstead.list_check = function(self, name) -- force using of objects, instead refs\nlocal i, v, ii;\nfor i,v,ii in stead.opairs(self) do\nlocal o = stead.ref(v);\nif not isObject(o) then \nerror (stead.string.format(\"Wrong object: %q (%s) at %s\", \nstead.tostr(v), stead.tostr(stead.type(v)),\nname ..\"[\"..stead.tostr(ii)..\"]\"));\nreturn false\nend\nif (v.auto_allocated and not stead.ref(v.key_name)) -- renew\nor (isObject(stead.deref(v)) and not v._dynamic_type) then -- no named object!\nlocal n = stead.string.format(\"%s[%d]\", name, ii);\nv = allocator:new(n, n);\nself[ii] = v;\nv.auto_allocated = true;\nfor_each(v, n, stead.check_list, isList, stead.deref(v));\nelse\nself[ii] = o;\nend\nend\nreturn true; \nend\nstead.list_add = function(self, name, pos)\nlocal nam = name\nif stead.initialized then\nnam = stead.ref(name);\nend\nif not nam then\nerror (\"Add wrong object to list: \"..stead.tostr(name), 2);\nend\nif self:look(nam) then\nreturn nil\nend\nself.__modified__ = true;\nif isObject(stead.deref(nam)) then\nnam._dynamic_type = true\nend\nif stead.tonum(pos) then\npos = stead.tonum(pos)\nif pos <= #self then\nstead.table.insert(self, pos, nam);\nelse\nself[pos] = nam; -- for spare lists\nend\nelse\nstead.table.insert(self, nam);\nend\nreturn true\nend\nstead.list_set = function(self, name, pos)\nlocal nam = name\nlocal i = stead.tonum(pos);\nif not i then\nreturn nil\nend\nif stead.initialized then\nnam = stead.ref(name);\nend\nif not nam then\nerror (\"Set wrong object in list: \"..stead.tostr(name), 2);\nend\nif isObject(stead.deref(nam)) then\nnam._dynamic_type = true\nend\nself.__modified__ = true;\nself[i] = nam; -- for spare lists\nreturn true\nend\nstead.list_concat = function(self, other, pos)\nlocal n,o,ii\nfor n,o,ii in stead.opairs(other) do\no = stead.ref(o);\nif pos == nil then\nself:add(o);\nelse \nself:add(o, pos);\npos = pos + 1;\nend\nend\nend\nstead.delim = '|'\nstead.list_str = function(self)\nlocal i, v, vv, o;\nfor i,o in stead.opairs(self) do\no = stead.ref(o);\nif isObject(o) and not isDisabled(o) then\nvv = stead.dispof(o)\nvv = stead.xref(vv, o);\nv = stead.par(stead.delim, v, vv);\nend\nend\nreturn v;\nend\nstead.obj_str = function(self)\nlocal i, v, vv, o;\nif not isObject(self) then\nreturn\nend\nif isDisabled(self) then\nreturn \nend\nfor i,o in stead.opairs(self.obj) do\no = stead.ref(o);\nif isObject(o) and not isDisabled(o) then\nvv = stead.dispof(o)\nvv = stead.xref(vv, o);\nv = stead.par(stead.delim, v, vv, stead.obj_str(o));\nend\nend\nreturn v;\nend\nfunction path(w, wh) -- search in way, disabled too\nif not wh then\nwh = stead.here();\nelse\nwh = stead.ref(wh);\nend\nlocal o = ways(wh):srch(w, true);\no = stead.ref(o);\nif isRoom(o) then\nreturn o\nend\nreturn nil\nend\ngame.lifes = list(game.lifes)\nstead:init(); -- reinit ob\n-- vim:ts=4\n","para.lua":"require \"format\"\nformat.para = true\n","prefs.lua":"prefs = obj {\nnam = 'preferences',\nsystem_type = true,\nload = function(s)\nlocal name = instead_savepath() .. '/prefs';\nlocal f, err = loadfile(name);\nif not f then return nil end\nf();\nend,\nini = function(s)\nreturn s:load()\nend,\nstore = function(s)\ns:save()\nstead.clearvar(s);\nend,\nsave = function(s) -- save prefs on every save\nlocal name = instead_savepath() .. '/prefs';\nlocal name_tmp = name..'.tmp'\nlocal h = stead.io.open(name_tmp, \"wb\");\nif not h then return false end\nstead.savemembers(h, s, 'prefs', true);\nh:flush();\nh:close();\nstead.os.remove(name);\nstead.os.rename(name_tmp, name);\nend,\npurge = function(s)\nlocal name = instead_savepath() .. '/prefs';\nlocal k,v\nfor k,v in stead.pairs(s) do\nif stead.type(v) ~= 'function' and k ~= 'nam' and k ~= 'system_type' then\ns[k] = nil\nend\nend\nreturn stead.os.remove(name);\nend\n};\n-- vim:ts=4\n","proxymenu.lua":"stead.menu_prefix = '   '\nlocal mpar = function(v, vv, rc) \nif stead.type(v) == 'string' or stead.type(vv) == 'string' then\nreturn stead.par(stead.space_delim, v, vv);\nelseif v == true or vv == true then\nreturn true\nend\nreturn rc\nend\nlocal call = function(o, m, ...)\nlocal rc = nil\nlocal v, r = stead.call(o, m, ...); \nif r == false or v == false then\nrc = false\nelseif r or v then \nrc = true \nend\nreturn v, r, rc\nend\nstead.obj_proxy = function(o, act, use_mode, used_act, useit_act)\nlocal v = {};\nv.proxy_type = true;\nlocal d = stead.dispof(o);\nif stead.type(d) == 'string' then\nv.nam = stead.menu_prefix..d;\nend\nif inv():srch(o) then\nv.nam = txtem(v.nam);\nend\nif not v.nam then\nv.nam = true\nend\nv.pobj = o;\nv.pact = act;\nv.use_mode = use_mode;\nv.used_act = used_act;\nv.useit_act = useit_act;\nv.save = function(self, name, h, need)\nif need then\nh:write(stead.string.format(name..\" = stead.obj_proxy(%s, %s, %s, %s, %s);\\n\", \nstead.tostring(self.pobj), \nstead.tostring(self.pact),  \nstead.tostring(self.use_mode),\nstead.tostring(self.used_act),\nstead.tostring(self.useit_act)));\nend\nstead.savemembers(h, self, name, false);\nend\nif use_mode then\nv.use = function(s, w)\nif w.proxy_type then\nlocal v, r, vv, rr, rc = false, ri\nlocal act = s.pact\nv, r, ri = call(game, 'before_'..act, s.pobj, w.pobj);\nrc = ri or rc\nif ri == false then \nreturn v, false \nend\nvv, r, ri = call(s.pobj, act, w.pobj);\nrc = ri or rc\nv = mpar(v, vv, rc);\nif ri == false then\nreturn v, false\nend\nif stead.type(s.used_act) == 'string' \nand ri == nil then -- used only if use did nothing\nvv, r, ri = call(w.pobj, s.used_act, s.pobj);\nrc = ri or rc\nv = mpar(v, vv, rc);\nif ri == false then\nreturn v, false\nend\nend\nif ri then\nvv, rr, ri = call(game, 'after_'..act, s.pobj, w.pobj);\nrc = rc or ri\nv = mpar(v, vv, rc);\nif ri == false then\nreturn v, false\nend\nend\nif v == nil then\nv = stead.call(game, act, s.pobj, w.pobj);\nend\nreturn v, false;\nend\nend\nend\nv.inv = function(s)\nlocal v, r, vv, rr, rc = false, ri\nlocal act = s.pact\nif s.use_mode then\nact = s.useit_act\nif stead.type(act) ~= 'string' then\nreturn nil\nend\nend\nv, r, ri = call(game, 'before_'..act, s.pobj); \nrc = rc or ri\nif ri == false then\nreturn v\nend\nvv, r, ri = call(s.pobj, act); \nrc = rc or ri\nv = mpar(v, vv, rc)\nif ri == false then\nreturn v\nend\nif ri then\nvv, rr, ri = call(game, 'after_'..act, s.pobj); \nrc = rc or ri\nv = mpar(v, vv, rc);\nend\nif v == nil then\nv = stead.call(game, act, s.pobj);\nend\nreturn v, rc;\nend\nif use_mode then\nreturn obj(v)\nend\nreturn menu(v)\nend\nstead.proxy_fill_objs = function(s, w, act, use_mode, used_act, useit_act)\nlocal ii,i,o\nlocal rc = false\nfor i,o,ii in stead.opairs(w) do\no = stead.ref(o);\nif isObject(o) and not isDisabled(o) and o ~= s and not isPhrase(o) \nand not o.proxy_type and not isStatus(o) then\ns.obj:add(stead.obj_proxy(o, act, use_mode, used_act, useit_act));\nif not isRoom(o) then\nstead.proxy_fill_objs(s, o.obj, act, use_mode, used_act, useit_act);\nend\nrc = true\nend\nend\nreturn rc\nend \nlocal select_only = function(s)\nlocal k, o, i\nfor k,o in stead.opairs(stead.me().obj) do\no = stead.ref(o)\nif o.action_type and o._state and o ~= s then\no:inv();\nend\nend\nstead.obj_tag(stead.me(), MENU_TAG_ID);\nend\nlocal proxy_menu = function(nam, act, _scene, _inv, _way, use_mode, used_act, useit_act, _ifhave)\nlocal v = { };\nif stead.type(act) ~= 'string' then\nerror(\"Wrong parameter to proxy_menu.\", 3)\nend\nif null[act] then\nerror(stead.tostring(act)..\"is a reserved handler. Do not use it.\", 3)\nend\nif used_act and null[used_act] then\nerror(stead.tostring(used_act)..\"is a reserved handler. Do not use it.\", 3)\nend\nif useit_act and null[useit_act] then\nerror(stead.tostring(useit_act)..\"is a reserved handler. Do not use it.\", 3)\nend\nv.action_type = true;\nv._state = false;\nv.nam = nam;\nv.disp = function(s)\nlocal n = stead.call(s, 'nam')\nif s._state then\nreturn txtu(txtnb(n));\nend\nreturn txtnb(n);\nend\nv.fill_scene = _scene;\nv.fill_inv = _inv;\nv.fill_ifhave = _ifhave;\nv.fill_way = _way;\nv.gen = function(s)\nlocal k,o,i\nlocal rc = false\ns.obj:zap();\nif s.fill_inv then\nrc = stead.proxy_fill_objs(s, inv(), act, use_mode, used_act, useit_act);\nend\nif not s.fill_ifhave or rc then\nif s.fill_scene then\nstead.proxy_fill_objs(s, stead.here().obj, act, use_mode, used_act, useit_act);\nend\nend\nif s.fill_way then\nstead.proxy_fill_objs(s, stead.here().way, act, use_mode, used_act, useit_act);\nend\nselect_only(s);\nend\nv.inv = function(s)\nlocal i,o\nlocal k,v\ns._state = not s._state \nif s._state then\ns:gen();\nelse\ns.obj:zap();\nend\nreturn nil, true -- to say instead, do not redraw scene, only inv ;)\nend\nreturn menu(v);\nend\nlocal function gen_actions(s)\nlocal k, o\nfor k, o in stead.opairs(stead.me().obj) do\no = stead.ref(o)\nif o.action_type and o._state then\no:gen();\nend\nend\nend\nact_menu = function(nam, act)\nlocal v = { };\nv.action_type = true;\nv.nam = nam;\nv.gen = function(s)\nend\nv.inv = function(s)\nlocal v, r \nv, r = stead.call(game, act);\nreturn v, r\nend\nreturn menu(v);\nend\nobj_menu = function(nam, act, _scene, _inv, _way)\nreturn proxy_menu(nam, act, _scene, _inv, _way)\nend\nuse_menu = function(nam, act, used_act, useit_act, _scene, _inv, _ifhave)\nreturn proxy_menu(nam, act, _scene, _inv, false, true, used_act, useit_act, _ifhave)\nend\ninv = function(s)\n    return stead.me().inventory;\nend\ngame.onuse = function(s, v, w) -- do not let use on non proxy obj\nif not v.proxy_type and not w.proxy_type then\nreturn\nend\nif not v.proxy_type or not w.proxy_type then\nreturn false\nend\nend\nplayer = stead.inherit(player, function(v)\nv.inv = function(s)\ngen_actions(s);\nreturn stead.player_inv(s);\nend\nv.inventory = list {}\nreturn v\nend)\npl = player(pl) -- reinit\n-- vim:ts=4\n","quotes.lua":"require \"format\"\nformat.quotes = true\n","snapshots.lua":"game._snapshots = {}\nstead.make_snapshot = function(nr)\nif not stead.tonum(nr) then nr = 0 end\nlocal h = { };\nh.txt = ''\nh.write = function(s, ...)\nlocal i\nlocal a = {...};\nfor i = 1, stead.table.maxn(a) do\ns.txt = s.txt .. stead.tostr(a[i]);\nend\nend\nlocal old = game._snapshots; game._snapshots = nil\nstead.do_savegame(game, h);\ngame._snapshots = old\ngame._snapshots[nr] = h.txt;\nend\nfunction isSnapshot(nr)\nif not stead.tonum(nr) then nr = 0 end\nreturn (game._snapshots[nr] ~= nil)\nend\nstead.restore_snapshot = function (nr)\nif not stead.tonum(nr) then nr = 0 end\nlocal ss = game._snapshots\nif not ss[nr] then return nil, true end -- nothing todo\nlocal i,v\nif stead.api_atleast(1, 7, 1) then\nstead.gamereset(\"main.lua\", true);\nelse\nstead.gamefile(\"main.lua\", true);\nend\nlocal f, err = stead.eval(ss[nr]..' ');\nif not f then return end\nlocal i,r = f();\ngame._snapshots = ss\nif r then\nreturn nil, false\nend\ni = stead.do_ini(game, true);\nif stead.api_atleast(1, 7, 1) then\ngame:start()\nstead.started = true\nPLAYER_MOVED = true -- force fading\nend\nRAW_TEXT = true\n--delete_snapshot(nr);\nif stead.cctx() then\nstead.pr(i)\nend\nreturn i;\nend\nstead.delete_snapshot = function(nr)\nif not stead.tonum(nr) then nr = 0 end\ngame._snapshots[nr] = nil\nend\nfunction make_snapshot(nr)\nif stead.type(nr) ~= 'number' then\nnr = 0\nend\nMAKE_SNAPSHOT = nr\nend\nfunction restore_snapshot(nr)\nreturn stead.restore_snapshot(nr)\nend\nfunction delete_snapshot(nr)\nreturn stead.delete_snapshot(nr);\nend\niface.cmd = stead.hook(iface.cmd, function(f, ...)\nlocal r,v = f(...);\nif MAKE_SNAPSHOT ~= nil then\nstead.make_snapshot(MAKE_SNAPSHOT);\nMAKE_SNAPSHOT = nil\nend\nreturn r,v\nend)\n-- vim:ts=4\n","sound.lua":"stead.sound_load = instead_sound_load\nstead.sound_free = instead_sound_free\nstead.sounds_free = instead_sounds_free\nstead.sound_channel = instead_sound_channel\nstead.sound_volume = instead_sound_volume\nstead.sound_panning = instead_sound_panning\nsound = {\nnam = 'sound';\nobject_type = true;\nsystem_type = true;\nload = function(fname)\nreturn stead.sound_load(fname);\nend;\nfree = function(key)\nreturn stead.sound_free(key);\nend;\nplay = function(key, ...)\nreturn stead.add_sound(key, ...)\nend;\nstop = function(...)\nstead.stop_sound(...);\nend;\nplaying = function(s,...)\nif stead.type(s) ~= 'number' then\nreturn stead.is_sound()\nend\nreturn stead.sound_channel(s,...)\nend;\npan = function(c, l, r, ...)\nreturn stead.sound_panning(c, l, r, ...)\nend;\nvol = function(v, ...)\nreturn stead.sound_volume(v, ...)\nend\n}\nstead.module_init(function()\nstead.sounds_free();\nend)\n","sprites.lua":"require \"theme\"\nstead.font_load = instead_font_load\nstead.font_free = instead_font_free\nstead.font_scaled_size = instead_font_scaled_size\nstead.sprite_alpha = instead_sprite_alpha\nstead.sprite_dup = instead_sprite_dup\nstead.sprite_scale = instead_sprite_scale\nstead.sprite_rotate = instead_sprite_rotate\nstead.sprite_text = instead_sprite_text\nstead.sprite_text_size = instead_sprite_text_size\nstead.sprite_draw = instead_sprite_draw\nstead.sprite_copy = instead_sprite_copy\nstead.sprite_compose = instead_sprite_compose\nstead.sprite_fill = instead_sprite_fill\nstead.sprite_pixel = instead_sprite_pixel\nstead.sprite_load = instead_sprite_load\nstead.sprite_free = instead_sprite_free\nstead.sprite_size = instead_sprite_size\nstead.sprites_free = instead_sprites_free\nstead.sprite_colorkey = instead_sprite_colorkey\nsprite = {\nnam = 'sprites';\nobject_type = true;\nsystem_type = true;\nscreen = function(s)\nif theme.get 'scr.gfx.mode' ~= 'direct' then\nreturn\nend\nreturn 'screen'\nend;\nfont_scaled_size = function(size)\nreturn stead.font_scaled_size(size);\nend;\nfont = function(font, size, ...)\nreturn stead.font_load(font, size, ...);\nend;\nfree_font = function(font)\nreturn stead.font_free(font);\nend;\nfont_height = function(font)\nlocal w,h = stead.sprite_text_size(font)\nreturn h\nend;\nalpha = function(name, alpha, ...)\nreturn stead.sprite_alpha(name, alpha, ...);\nend;\ncolorkey = function(name, color, ...)\nreturn stead.sprite_colorkey(name, color, ...);\nend;\ndup = function(name, ...)\nreturn stead.sprite_dup(name, ...);\nend;\nscale = function(name, xs, ys, smooth, ...)\nif smooth == nil then\nsmooth = true -- default is on\nend\nreturn stead.sprite_scale(name, xs, ys, smooth,...);\nend;\nrotate = function(name, angle, smooth, ...)\nif smooth == nil then\nsmooth = true -- default is on\nend\nreturn stead.sprite_rotate(name, angle, smooth, ...);\nend;\ntext = function(font, text, col, style, ...)\nreturn stead.sprite_text(font, text, col, style, ...);\nend;\nsize = function(spr)\nreturn stead.sprite_size(spr);\nend;\ntext_size = function(fnt, spr)\nreturn stead.sprite_text_size(fnt, spr);\nend;\ndraw = function(s, fx, fy, fw, fh, d, x, y, alpha)\nif d == nil and x == nil and y == nil then\nreturn stead.sprite_draw(s, 0, 0, -1, -1, fx, fy, fw, fh);\nend\nreturn stead.sprite_draw(s, fx, fy, fw, fh, d, x, y, alpha);\nend;\ncopy = function(s, fx, fy, fw, fh, d, x, y, alpha)\nif d == nil and x == nil and y == nil then\nreturn stead.sprite_copy(s, 0, 0, -1, -1, fx, fy, fw, fh);\nend\nreturn stead.sprite_copy(s, fx, fy, fw, fh, d, x, y, alpha);\nend;\ncompose = function(s, fx, fy, fw, fh, d, x, y, alpha)\nif d == nil and x == nil and y == nil then\nreturn stead.sprite_compose(s, 0, 0, -1, -1, fx, fy, fw, fh);\nend\nreturn stead.sprite_compose(s, fx, fy, fw, fh, d, x, y, alpha);\nend;\nfill = function(d, x, y, w, h, col)\nif h == nil and col == nil then\nreturn stead.sprite_fill(d, 0, 0, -1, -1, x);\nend \nreturn stead.sprite_fill(d, x, y, w, h, col);\nend;\npixel = function(d, x, y, col, alpha)\nreturn stead.sprite_pixel(d, x, y, col, alpha)\nend;\nload = function(fname, ...)\nreturn stead.sprite_load(fname, ...);\nend;\nblank = function(w, h, ...)\nlocal t = 'blank:'..stead.tostr(w)..'x'..stead.tostr(h)\nreturn stead.sprite_load(t, ...)\nend;\nbox = function(w, h, col, alpha, ...)\nlocal t = 'box:'..stead.tostr(w)..'x'..stead.tostr(h)\nif col then\nt = t..','..stead.tostr(col)\nend\nif alpha then\nt = t..','..stead.tostr(alpha)\nend\nreturn stead.sprite_load(t, ...)\nend;\nfree = function(key)\nreturn stead.sprite_free(key);\nend;\n}\nstead.module_init(function()\nstead.sprites_free();\nend)\n","stead.lua":"stead = {\nversion = \"2.4.1\",\napi_version = \"1.1.6\", -- last version before 1.2.0\ntable = table,\ndelim = ',',\nbusy = instead_busy,\nscene_delim = \"^^\",\nspace_delim = ' ',\nstring = string,\ntostr = tostring,\ntonum = tonumber,\ntype = type,\nipairs = ipairs,\npairs = pairs, \nmath = math,\nticks = instead_ticks,\nmouse_pos = instead_mouse_pos,\nmouse_show = instead_mouse_show,\nfinger_pos = instead_finger_pos,\nmouse_filter = instead_mouse_filter, \nset_timer = instead_timer,\nrandom = instead_random,\nrandomseed = instead_srandom,\nnext = next,\nmath = math,\nio = io,\nos = os,\nreaddir = instead_readdir,\ncall_top = 0,\ncall_ctx = { txt = nil, self = nil },\n--functions = {}, -- code blocks\ntimer = function()\nif stead.type(timer) == 'table' and stead.type(timer.callback) == 'function' then\nreturn timer:callback();\nend\nreturn\nend,\ninput = function(event, ...)\nif stead.type(input) ~= 'table' then\nreturn\nend\nif event == 'kbd' then\nif stead.type(input.key) == 'function' then\nreturn input:key(...); -- pressed, event\nend\nelseif event == 'mouse' then\nif stead.type(input.click) == 'function' then\nreturn input:click(...); -- pressed, x, y, mb\nend\nelseif event == 'finger' then\nif stead.type(input.finger) == 'function' then\nreturn input:finger(...); -- pressed, x, y, finger\nend\nelseif event == 'event' then\nif stead.type(input.event) == 'function' then\nreturn input:event(...);\nend\nend\nreturn\nend,\nmodules_ini = {},\nmodule_init = function(f, ...)\nif stead.type(f) ~= 'function' then\nerror (\"Wrong parameter to mod_init.\", 2);\nend\nstead.table.insert(stead.modules_ini, f);\nf();\nend\n}\nfunction instead_menu_toggle(n)\nif n == nil then\nn = 'main'\nelseif type(n) ~= 'string' then\nn = 'toggle'\nend\nstead.need_menu = n\nend\nstead.menu_toggle = instead_menu_toggle\nstead.api_atleast = function(...)\nlocal k\nlocal v\nfor k, v in stead.ipairs {...} do\nif stead.type(k) ~= 'number' then\nreturn false\nend\nif v > (stead.api_version_table[k] or 0) then\nreturn false\nend\nif v < (stead.api_version_table[k] or 0) then\nreturn true\nend\nend\nreturn true\nend;\nstead.atleast = function(...)\nlocal k\nlocal v\nfor k, v in stead.ipairs {...} do\nif stead.type(k) ~= 'number' then\nreturn false\nend\nif v > (stead.version_table[k] or 0) then\nreturn false\nend\nif v < (stead.version_table[k] or 0) then\nreturn true\nend\nend\nreturn true\nend;\nstead.last_act = function(s)\nlocal r = game.__last_act\nif s ~= nil and s ~= true then\ngame.__last_act = s\nend\nreturn r\nend\nstead.last_disp = function(s)\nlocal r = game._lastdisp\nif s ~= nil then\nif not s then\ngame._lastdisp = nil\nelse\ngame._lastdisp = s\nend\nend\nreturn r\nend\nstead.nop = function(s) -- to refresh entry scene w/o time tick\nRAW_TEXT = true\nreturn stead.last_disp() or ''\nend\nstead.need_scene = function(s)\nif s == nil then\nNEED_SCENE = true\nelse\nNEED_SCENE = s\nend\nend\nif not stead.busy then\nstead.busy = function(v)\nend\nend\nif _VERSION == \"Lua 5.1\" then\nstead.eval = loadstring\nstead.unpack = unpack\nelse\nstead.eval = load\nstead.unpack = table.unpack\nstead.table.maxn = table_get_maxn\nstring.gfind = string.gmatch\nmath.mod = math.fmod\nmath.log10 = function(a)\nreturn stead.math.log(a, 10)\nend\nend\ninstead = stead;\nfunction stead.getcmd(str)\nlocal a = {}\nlocal n = 1\nlocal cmd;\nlocal i,k = stead.string.find(str, '[a-zA-Z0-9_]+');\nif not i or not k then\ncmd = str;\nelse\ncmd = stead.string.sub(str, i, k);\nend\nstead.cmd = cmd\nif cmd == 'load' or cmd == 'save' then\na[1] = stead.strip(stead.string.sub(str, k + 1));\nstead.args = a;\nreturn cmd, a\nend\nwhile i do\nk = k + 1;\ni,k = stead.string.find(str,'[^,]+', k);\nif not i then\nbreak\nend\na[n] = stead.strip(stead.string.sub(str, i, k));\nn = n + 1;\nend\nstead.args = a;\nreturn cmd, a\nend\nstead.tostring = function(v)\nif isCode(v) then\nv = stead.string.format(\"code %q\", stead.functions[v].code);\nelseif stead.type(v) == 'string' then\nv = stead.string.format(\"%q\", v);\nelseif v == nil or stead.type(v) == 'boolean' or stead.type(v) == 'number' then\nv = stead.tostr(v);\nelseif stead.type(v) == 'table' and stead.type(stead.deref(v)) == 'string' then\nv = stead.deref(v);\nelse\nv = nil\nend\nreturn v\nend\nstead.cctx = function()\nreturn stead.call_ctx[stead.call_top];\nend\nstead.callpush = function(v, ...)\nstead.call_top = stead.call_top + 1;\nstead.call_ctx[stead.call_top] = { txt = nil, self = v, action = false };\nargs = {...};\narg1 = args[1]\narg2 = args[2]\narg3 = args[3]\narg4 = args[4]\narg5 = args[5]\narg6 = args[6]\narg7 = args[7]\narg8 = args[8]\narg9 = args[9]\n-- dirty but clean and fast :)\nself = v\nend\nstead.clearargs = function()\narg1 = nil\narg2 = nil\narg3 = nil\narg4 = nil\narg5 = nil\narg6 = nil\narg7 = nil\narg8 = nil\narg9 = nil\nself = nil\nend\nstead.callpop = function()\nstead.call_ctx[stead.call_top] = nil;\nstead.call_top = stead.call_top - 1;\nif stead.call_top < 0 then\nerror (\"callpush/callpop mismatch\")\nend \nstead.clearargs()\nend\nstead.pclr = function()\nstead.cctx().txt = nil\nend\nstead.pget = function()\nreturn stead.cctx().txt;\nend\nstead.p = function(...)\nlocal i\nlocal a = {...}\nif stead.cctx() == nil then\nerror (\"Call from global context.\", 2);\nend\nfor i = 1, stead.table.maxn(a) do\nstead.cctx().txt = stead.par('', stead.cctx().txt, stead.tostr(a[i]));\nend\nstead.cctx().txt = stead.cat(stead.cctx().txt, stead.space_delim);\nend\nstead.pr = function(...)\nlocal i\nlocal a = {...}\nif stead.cctx() == nil then\nerror (\"Call from global context.\", 2);\nend\nfor i = 1, stead.table.maxn(a) do\nstead.cctx().txt = stead.par('', stead.cctx().txt, stead.tostr(a[i]));\nend\nend\nstead.pn = function(...)\nif stead.cctx() == nil then\nerror (\"Call from global context.\", 2);\nend\np(...);\nstead.cctx().txt = stead.par('', stead.cctx().txt,'^');\nend\n-- merge strings with \"space\" as separator\nstead.par = function(space,...)\nlocal i, res\nlocal a = {...};\nfor i = 1, stead.table.maxn(a) do\nif stead.type(a[i]) == 'string' then\nif res == nil then\nres = \"\"\nelse\nres = res..space;\nend\nres = res..a[i];\nend \nend\nreturn res;\nend\n-- add to not nill string any string\nstead.cat = function(v,...)\nlocal i, res\nif not v then\nreturn nil\nend\nres = v;\nlocal a = {...}\nfor i = 1, stead.table.maxn(a) do\nif stead.type(a[i]) == 'string' then\nres = res..a[i];\nend \nend\nreturn res;\nend\nfunction txtnb(v)\nif stead.type(v) ~= 'string' then return nil; end\nreturn iface:nb(v);\nend\nfunction img(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:img(v);\nend\nfunction imgl(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:imgl(v);\nend\nfunction imgr(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:imgr(v);\nend\nfunction txtem(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:em(v)\nend\nfunction txtst(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:st(v)\nend\nfunction txtr(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:right(v)\nend\nfunction txtl(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:left(v)\nend\nfunction txtc(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:center(v)\nend\nfunction txttab(v,a)\nreturn iface:tab(v, a)\nend\nfunction txty(v, a)\nreturn iface:y(v, a)\nend\nfunction txtj(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:just(v)\nend\nfunction txtb(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:bold(v)\nend\nfunction txtu(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:under(v)\nend\nfunction txtnm(n, v)\nif stead.type(v) ~= 'string' or not stead.tonum(n) then return nil; end\nreturn iface:enum(n, v);\nend\nfunction txttop(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:top(v)\nend\nfunction txtbottom(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:bottom(v)\nend\nfunction txtmiddle(v)\nif stead.type(v) ~= 'string' then return nil; end; \nreturn iface:middle(v)\nend\nstead.fmt = function(...)\nlocal i, res\nlocal a = {...};\nfor i=1,stead.table.maxn(a) do\nif stead.type(a[i]) == 'string' then\nlocal s = stead.string.gsub(a[i],'[\\t ]+', stead.space_delim);\ns = stead.string.gsub(s, '[\\n]+', stead.space_delim);\ns = stead.string.gsub(s, '\\\\?[\\\\^]', { ['^'] = '\\n', ['\\\\^'] = '^', ['\\\\\\\\'] = '\\\\'} );\nres = stead.par('', res, s);\nend\nend\nreturn res\nend\n-- integer lists\nlocal inext = function(t, k)\nlocal v\nk, v = stead.next(t, k);\nwhile k and not stead.tonum(k) do\nk, v = stead.next(t, k);\nend\nif not stead.tonum(k) then\nreturn nil\nend\nreturn k, v\nend\nlocal ilist = function(s, var)\nreturn inext, s, nil;\nend\nlocal ordered_i = function(t)\nlocal ordered = {};\nlocal i,v, max;\nmax = 0;\nfor i,v in ilist(t) do\nstead.table.insert(ordered, i);\nmax = max + 1;\nend\nstead.table.sort(ordered);\nordered.i = 1;\nordered.max = max;\nreturn ordered;\nend\nlocal onext = function(t, k)\nlocal v\nif not k then\nk = ordered_i(t);\nend\nif k.i > k.max then\nreturn nil\nend\nv = k[k.i]\nk.i = k.i + 1\nreturn k, t[v], v;\nend\nfunction opairs(s)\nreturn onext, s, nil;\nend\nstead.opairs = opairs\nfunction isPlayer(v)\nreturn (stead.type(v) == 'table') and (v.player_type)\nend\nfunction isRoom(v)\nreturn (stead.type(v) == 'table') and (v.location_type)\nend\nfunction isPhrase(v)\nreturn (stead.type(v) == 'table') and (v.phrase_type)\nend\nfunction isDialog(v)\nreturn (stead.type(v) == 'table') and (v.dialog_type)\nend\nfunction isDisabled(v)\nreturn (stead.type(v) == 'table') and (v._disabled)\nend\nfunction isRemoved(v)\nreturn (stead.type(v) == 'table') and (v._disabled == -1)\nend\nfunction isObject(v)\nreturn (stead.type(v) == 'table') and (v.object_type)\nend\nfunction isXaction(v)\nreturn (stead.type(v) == 'table') and (v.xaction_type)\nend\nstead.obj_xref = function(self,str)\nfunction xrefrep(str)\nlocal s = stead.string.gsub(str,'[\\001\\002]','');\nreturn stead.xref(s, self);\nend\nif not str then\nreturn\nend\nif not isObject(self) then\nreturn str;\nend\nlocal s = stead.string.gsub(str, '\\\\?[\\\\{}]', \n{ ['{'] = '\\001', ['}'] = '\\002', [ '\\\\{' ] = '{', [ '\\\\}' ] = '}' }):gsub('\\001([^\\002]+)\\002', xrefrep):gsub('[\\001\\002]', { ['\\001'] = '{', ['\\002'] = '}' });\nreturn s;\nend\nstead.obj_look = function(self)\nlocal i, vv, o\nif isDisabled(self) then\nreturn\nend\nlocal v = stead.call(self,'dsc');\nif game.hinting then\nv = self:xref(v);\nelseif v then\nv = stead.string.gsub(v, '[{}]','');\nend\nfor i,o in stead.opairs(self.obj) do\no = stead.ref(o);\nif isObject(o) then\nvv = stead.obj_look(o);\nv = stead.par(stead.space_delim, v, vv); \nend\nend\nreturn v;\nend\nstead.obj_remove = function(self)\nself._disabled = -1;\nreturn self\nend\nstead.obj_disable = function(self)\nself._disabled = true;\nreturn self\nend\nstead.obj_enable = function(self)\nself._disabled = false;\nreturn self\nend\nstead.obj_disabled = function(self)\nreturn (self._disabled == true);\nend\nstead.obj_enable_all = function(s)\nif not isObject(s) then\nreturn\nend\nobjs(s):enable_all();\nend\nstead.obj_disable_all = function(s)\nif not isObject(s) then\nreturn\nend\nobjs(s):disable_all();\nend\nstead.obj_save = function(self, name, h, need)\nlocal dsc;\nif need then\nprint (\"Warning: object \"..name..\" can not be saved!\");\nreturn\nend\nstead.savemembers(h, self, name, need);\nend\nstead.obj_str = function(self)\nlocal i, v, vv, o;\nif not isObject(self) then\nreturn\nend\nif isDisabled(self) then\nreturn \nend\nfor i,o in stead.opairs(self.obj) do\no = stead.ref(o);\nif o~= nil and not isDisabled(o) then -- isObject is better, but compat layer must be ok\nvv = stead.call(o, 'nam');\nvv = stead.xref(vv, o);\nv = stead.par(',', v, vv, stead.obj_str(o));\nend\nend\nreturn v;\nend\nfunction obj(v)\nif v.nam == nil then\nif isRoom(v) then\nif isDialog(v) then\nerror (\"No dialog name in constructor.\", 3);\nend\nerror (\"No room name in constructor.\", 3);\nend\nerror (\"No object name in constructor.\", 2);\nend\nv.object_type = true;\nif v.xref == nil then\nv.xref = stead.obj_xref;\nend\nif v.look == nil then\nv.look = stead.obj_look;\nend\nif v.enable == nil then\nv.enable = stead.obj_enable;\nend\nif v.disable == nil then\nv.disable = stead.obj_disable;\nend\nif v.disabled == nil then\nv.disabled = stead.obj_disabled;\nend\nif v.enable_all == nil then\nv.enable_all = stead.obj_enable_all;\nend\nif v.disable_all == nil then\nv.disable_all = stead.obj_disable_all;\nend\nif v.remove == nil then\nv.remove = stead.obj_remove;\nend\nif v.obj == nil then\nv.obj = {};\nend\nif v.srch == nil then\nv.srch = stead.obj_search;\nend\nif v.str == nil then\nv.str = stead.obj_str;\nend\nv.obj = list(v.obj);\nif v.save == nil then\nv.save = stead.obj_save;\nend\nreturn v\nend\nfunction stead.ref(n, nofunc) -- ref object by name\nif stead.type(n) == 'string' then\nif stead.type(_G[n]) == 'table' then -- fastest path\nreturn _G[n];\nend\nlocal f = stead.eval('return '..n);\nif f then\nreturn stead.ref(f(), nofunc);\nend\nreturn nil;\nend\nif stead.type(n) == 'table' then\nreturn n;\nend\nif stead.type(n) == 'function' and not nofunc then\nlocal r,v = pcall(n);\nif not r then\nreturn nil\nend\nreturn stead.ref(v);\nend\nreturn nil\nend\nfunction stead.deref(n)\nif stead.type(n) == 'string' then\nreturn n\nend\nif stead.type(n) == 'table' and stead.type(n.key_name) == 'string' then\nreturn n.key_name\nend\nreturn n\nend\nstead.list_check = function(self, name)\nlocal i, v, ii;\nfor i,v,ii in stead.opairs(self) do\nlocal o = stead.ref(v);\nif not o then -- isObject(o) then -- compat\nerror (\"No object: \"..name..\"[\"..stead.tostr(ii)..\"]\"..\" (\"..stead.tostr(stead.type(v))..\")\")\nreturn false\nend\nif stead.deref(v) then\nself[ii] = stead.deref(v);\nend\nend\nreturn true; \nend\nstead.list_str = function(self)\nlocal i, v, vv, o;\nfor i,o in stead.opairs(self) do\no = stead.ref(o);\nif o~= nil and not isDisabled(o) then\nvv = stead.call(o, 'nam');\nvv = stead.xref(vv, o);\nv = stead.par(',', v, vv);\nend\nend\nreturn v;\nend\nstead.list_add = function(self, name, pos)\nlocal nam\nnam = stead.deref(name);\nif self:look(nam) then\nreturn nil\nend\nself.__modified__ = true;\nif stead.tonum(pos) then\npos = stead.tonum(pos)\nif pos <= #self then\nstead.table.insert(self, pos, nam);\nelse\nself[pos] = nam; -- for spare lists\nend\nelse\nstead.table.insert(self, nam);\nend\nreturn true\nend\nstead.list_set = function(self, name, pos)\nlocal nam\nlocal i = stead.tonum(pos);\nif not i then\nreturn nil\nend\nnam = stead.deref(name);\nself.__modified__ = true;\nself[i] = nam; -- for spare lists\nreturn true\nend\nstead.list_find = function(self, name)\nlocal n, v, ii\nlocal o = stead.ref(name, true)\nfor n,v,ii in stead.opairs(self) do \nif stead.ref(v) == o then -- do not call func while search\nreturn ii; \nend\nend\nreturn nil\nend\nstead.list_disable_all = function(s)\nlocal k,v\nfor k,v in stead.opairs(s) do\nlocal o = stead.ref(v);\nif isObject(o) then\no:disable()\nend\nend\nend\nstead.list_enable_all = function(s)\nlocal k,v\nfor k,v in stead.opairs(s) do\nlocal o = stead.ref(v);\nif isObject(o) then\no:enable()\nend\nend\nend\nstead.list_enable = function(s, w)\nlocal o, i = stead.list_search(s, w, true);\no = stead.ref(o);\nif isObject(o) then\no:enable()\nreturn o\nend\nend\nstead.list_disable = function(s, w)\nlocal o, i = stead.list_search(s, w, true);\no = stead.ref(o);\nif isObject(o) then\no:disable()\nreturn o\nend\nend\nstead.list_save = function(self, name, h, need)\nif self.__modifyed__ or self.__modified__ then -- compat\nh:write(name..\" = list({});\\n\");\nneed = true;\nend\nstead.savemembers(h, self, name, need);\nend\nstead.list_name = function(self, name, dis)\nlocal n, o, ii\nfor n,o,ii in stead.opairs(self) do\no = stead.ref(o);\nif isObject(o) then\nlocal nam = stead.call(o,'nam') ;\nif ( not isDisabled(o) or dis ) and name == stead.tostr(nam) then\nreturn ii;\nend\nend\nend\nreturn nil\nend\nstead.list_id = function(self, id, dis)\nlocal n,o,ii\nfor n,o,ii in stead.opairs(self) do\no = stead.ref(o);\nif dis or not isDisabled(o) then\nif isObject(o) and id == o.id then\nreturn ii;\nend\nend\nend\nend\nstead.list_search = function(self, n, dis)\nlocal i;\ni = self:look(n);\nif not i then\ni = self:name(n, dis);\nend\nif not i and stead.tonum(n) then\ni = self:byid(stead.tonum(n), dis);\nif not i then\nreturn nil\nend\nend\nif not dis and isDisabled(stead.ref(self[i])) then\nreturn nil;\nend\nreturn self[i], i;\nend\nstead.list_zap = function(self)\nlocal n,o,ii\nfor n,o,ii in stead.opairs(self) do\nself[ii] = nil;\nend\nself.__modified__ = true\nreturn self\nend\nstead.list_concat = function(self, other, pos)\nlocal n,o,ii\nfor n,o,ii in stead.opairs(other) do\no = stead.ref(o);\nif pos == nil then\nself:add(stead.deref(o));\nelse \nself:add(stead.deref(o), pos);\npos = pos + 1;\nend\nend\nend\nstead.list_del = function(self, name)\nlocal v,n\nv, n = self:srch(name);\nif n == nil then\nreturn nil;\nend\nself.__modified__ = true\nif n <= #self then\nv = stead.table.remove(self, n);\nelse\nv = self[n];\nself[n] = nil -- for spare lists\nend\nreturn v\nend\nstead.list_purge = function(self, name)\nlocal v,n\nv, n = self:srch(name, true);\nif n == nil then\nreturn nil;\nend\nself.__modified__ = true\nv = stead.table.remove(self, n);\nif not v then\nv = self[n];\nself[n] = nil -- for spare lists\nend\nreturn v\nend\nstead.list_replace = function(self, name, name2)\nlocal o, ii\no, ii = self:srch(name);\nif ii then\nself:set(name2, ii);\nelse\nself:add(name2);\nend\nreturn ii;\nend\nfunction list(v)\nv.list_type = true;\nv.add = stead.list_add;\nv.set = stead.list_set;\nv.cat = stead.list_concat;\nv.zap = stead.list_zap;\nv.del = stead.list_del;\nv.purge = stead.list_purge;\nv.replace = stead.list_replace;\nv.look = stead.list_find;\nv.name = stead.list_name;\nv.byid = stead.list_id;\nv.srch = stead.list_search;\nv.str = stead.list_str;\nv.check = stead.list_check;\nv.save = stead.list_save;\nv.enable = stead.list_enable;\nv.disable = stead.list_disable;\nv.enable_all = stead.list_enable_all;\nv.disable_all = stead.list_disable_all;\nreturn v;\nend\nfunction isList(v)\nreturn (stead.type(v) == 'table') and (v.list_type == true)\nend\nstead.call = function(v, n, ...)\nif stead.type(v) ~= 'table' then\nerror (\"Call on non table object:\"..stead.tostr(n), 2);\nend\nif v[n] == nil then\nreturn nil,nil;\nend\nif stead.type(v[n]) == 'string' then\nreturn v[n];\nend\nif stead.type(v[n]) == 'function' then\nstead.callpush(v, ...)\nlocal a,b = v[n](v, ...);\n-- boolean, nil\nif stead.type(a) == 'boolean' and b == nil then\nb, a = a, stead.pget()\nif a == nil then\nif stead.cctx().action then\na = true\nelse\na = b\nb = nil\nend\nend \nelseif a == nil and b == nil then\na = stead.pget()\nb = nil\nend\nif a == nil and b == nil and stead.cctx().action then\na = true\nend\nstead.callpop()\nreturn a,b\nend\nif stead.type(v[n]) == 'boolean' then\nreturn v[n]\nend\nerror (\"Method not string nor function:\"..stead.tostr(n), 2);\nend\nstead.call_bool = function(v, n, ...)\nif stead.type(v) ~= 'table' then\nerror (\"Call bool on non table object:\"..n, 2);\nend\nif v[n] == nil then\nreturn nil\nend\nif v[n] == false then\nreturn false;\nend\nif stead.type(v[n]) == 'function' then\nstead.callpush(v, ...)\nlocal r,v = v[n](v, ...);\nstead.callpop();\nreturn r,v;\nend\nreturn true; -- not nil\nend\nstead.call_value = function(v, n, ...)\nif stead.type(v) ~= 'table' then\nerror (\"Call value on non table object:\"..n, 2);\nend\nif v[n] == nil then\nreturn nil\nend\nif stead.type(v[n]) ~= 'function' then\nreturn v[n];\nend\nstead.callpush(v, ...)\nlocal r,v = v[n](v, ...);\nstead.callpop();\nreturn r,v;\nend\nstead.room_scene = function(self)\nlocal v;\nv = iface:title(stead.call(self,'nam'));\nv = stead.par(stead.scene_delim, v, stead.call(self,'dsc')); --obj_look(self));\nreturn stead.cat(v, stead.space_delim);\nend\nstead.room_look = function(self)\nlocal i, vv, o;\nfor i,o in stead.opairs(self.obj) do\no = stead.ref(o);\nif isObject(o) then\nvv = stead.par(stead.space_delim, vv, o:look());\nend\nend\nreturn stead.cat(vv, stead.space_delim);\nend\nstead.obj_search = function(v, n, dis)\nlocal i;\nlocal o;\nif not dis and isDisabled(v) then\nreturn\nend\no = v.obj:srch(n, dis);\nif o then\nreturn o, v;\nend\nfor i,o in stead.opairs(v.obj) do\no = stead.ref(o);\nif isObject(o) then\nlocal r,rr = stead.obj_search(o, n, dis);\nif r then\nreturn r, rr;\nend\nend\nend\nreturn;\nend\nstead.room_save = function(self, name, h, need)\nlocal dsc;\nif need then\nprint (\"Warning: room \"..name..\" can not be saved!\");\nreturn\nend\nstead.savemembers(h, self, name, need);\nend\nfunction room(v) --constructor\n--if v.nam == nil then\n--error (\"No room name in constructor.\", 2);\n--end\nif v.scene == nil then\nv.scene = stead.room_scene;\nend\nif v.look == nil then\nv.look = stead.room_look;\nend\nif v.save == nil then\nv.save = stead.room_save;\nend\nv.location_type = true;\nif v.way == nil then\nv.way = { };\nend\nv.way = list(v.way);\nv = obj(v);\nreturn v;\nend\nstead.dialog_enter = function(self)\nif not stead.dialog_rescan(self) then\nreturn nil, false\nend\nreturn nil, true\nend\nstead.dialog_scene = function(self)\nlocal v\nv = iface:title(stead.call(self,'nam'));\nv = stead.par(stead.scene_delim, v, stead.call(self, 'dsc')); --obj_look(self));\nreturn v;\nend\nstead.dialog_look = function(self)\nlocal i,n,v,ph\nn = 1\nfor i,ph in stead.opairs(self.obj) do\nph = stead.ref(ph);\nif isPhrase(ph) and not isDisabled(ph) then\nv = stead.par('^', v, txtnm(n, ph:look()));\nn = n + 1\nend\nend\nreturn v;\nend\nstead.dialog_rescan = function(self)\nlocal i,k,ph\nk = 1\nfor i,ph in stead.opairs(self.obj) do\nph = stead.ref(ph);\nif isPhrase(ph) and not isDisabled(ph) then\nph.nam = stead.tostr(k);\nk = k + 1;\nend\nend\nif k == 1 then\nreturn false\nend\nreturn true\nend\nstead.dialog_empty = function(self)\nreturn not stead.dialog_rescan(self);\nend\nstead.dialog_phrase = function(self, num)\nif not stead.tonum(num) then\nif isPhrase(stead.ref(num)) then\nreturn stead.ref(num);\nend\nreturn nil\nend\nreturn stead.ref(self.obj[stead.tonum(num)]);\nend\nstead.phrase_seen = function(s, enb, ...)\nlocal i, ph\nlocal a = {...}\nif stead.table.maxn(a) == 0 then\nstead.table.insert(a, stead.cctx().self);\nend\nfor i=1,stead.table.maxn(a) do\nph = stead.dialog_phrase(s, a[i]);\nlocal r = not isPhrase(ph) or isRemoved(ph) or ph:disabled();\nif not enb then r = not r end\nif r then return false end\nend\nreturn true\nend\nstead.dialog_pseen = function(s, ...)\nreturn stead.phrase_seen(s, true, ...);\nend\nstead.dialog_punseen = function(s, ...)\nreturn stead.phrase_seen(s, false, ...);\nend\nlocal function ponoff(s, on, ...)\nlocal i, ph\nlocal a = {...}\nif stead.table.maxn(a) == 0 then\nstead.table.insert(a, stead.cctx().self)\nend\nfor i=1,stead.table.maxn(a) do\nph = stead.dialog_phrase(s, a[i]);\nif isPhrase(ph) and not isRemoved(ph) then\nif on then\nph:enable();\nelse \nph:disable();\nend\nend\nend\nend\nstead.dialog_prem = function(s, ...)\nlocal i, ph\nlocal a = {...}\nif stead.table.maxn(a) == 0 then\nstead.table.insert(a, stead.cctx().self);\nend\nfor i=1,stead.table.maxn(a) do\nph = stead.dialog_phrase(s, a[i]);\nif isPhrase(ph) then\nph:remove();\nend\nend\nend\nstead.dialog_pon = function(self,...)\nreturn ponoff(self, true, ...);\nend\nstead.dialog_poff = function(self,...)\nreturn ponoff(self, false, ...);\nend\nfunction dlg(v) --constructor\nv.dialog_type = true;\nif v.ini == nil then\nv.ini = stead.dialog_enter;\nend\nif v.enter == nil then\nv.enter = stead.dialog_enter;\nend\nif v.look == nil then\nv.look = stead.dialog_look;\nend\nif v.scene == nil then\nv.scene = stead.dialog_scene;\nend\nif v.pon == nil then\nv.pon = stead.dialog_pon;\nend\nif v.poff == nil then\nv.poff = stead.dialog_poff;\nend\nif v.prem == nil then\nv.prem = stead.dialog_prem;\nend\nif v.pseen == nil then\nv.pseen = stead.dialog_pseen;\nend\nif v.punseen == nil then\nv.punseen = stead.dialog_punseen;\nend\nif v.empty == nil then\nv.empty = stead.dialog_empty;\nend\nv = room(v);\nreturn v;\nend\nstead.phrase_action = function(self)\nlocal ph = self;\nlocal r, ret;\nif isDisabled(ph) then\nreturn nil, false\nend\n-- here it is\nph:disable(); -- /* disable it!!! */\nlocal last = stead.call(ph, 'ans');\nif stead.type(ph.do_act) == 'string' then\nlocal f = stead.eval(ph.do_act);\nif f ~= nil then\nret = f();\nelse\nerror (\"Error while eval phrase action.\");\nend\nelseif stead.type(ph.do_act) == 'function' then\nret = ph.do_act(self);\nend\nif ret == nil then ret = stead.pget(); end\nif last == true or ret == true then\nr = true;\nend\nlocal wh = stead.here();\nwhile isDialog(wh) and not stead.dialog_rescan(wh) and stead.from(wh) ~= wh do\nwh = stead.from(wh)\nend\nif wh ~= stead.here() then\nret = stead.par(stead.space_delim, ret, stead.back(wh));\nend\nret = stead.par(stead.scene_delim, last, ret);\nif ret == nil then\nreturn r -- hack?\nend\nreturn ret\nend\nstead.phrase_save = function(self, name, h, need)\nif need then\nlocal m = \" = phr(\"\nif isDisabled(self) then\nm = \" = _phr(\"\nend\nh:write(stead.string.format(\"%s%s%s,%s,%s);\\n\", \nname, m, \nstead.tostring(self.dsc), \nstead.tostring(self.ans), \nstead.tostring(self.do_act)));\nend\nstead.savemembers(h, self, name, false);\nend\nstead.phrase_look = function(self, n)\nif isDisabled(self) then\nreturn\nend\nlocal v = stead.call(self, 'dsc');\nif stead.type(v) ~= 'string' then return; end\nif game.hinting then\nreturn self:xref('{'..v..'}');\nend\nreturn v;\nend\nfunction phrase(o) --constructor\nlocal ret = o;\nret.look = stead.phrase_look;\nret.nam = ''; -- for start\nret.phrase_type = true;\nret.act = stead.phrase_action;\nret.save = stead.phrase_save;\nret = obj(ret);\nreturn ret;\nend\nfunction _phr(ask, answ, act)\nlocal p = phrase ({ dsc = ask, ans = answ, do_act = act });\np:disable();\nreturn p;\nend\nfunction phr(ask, answ, act)\nlocal p = phrase ({ dsc = ask, ans = answ, do_act = act });\n--p:enable();\nreturn p;\nend\nstead.player_inv = function(self)\nreturn iface:inv(stead.cat(self:str()));\nend\nstead.player_ways = function(self)\nreturn iface:ways(stead.cat(stead.ref(self.where).way:str()));\nend\nstead.player_objs = function(self)\nreturn iface:objs(stead.cat(stead.ref(self.where):str()));\nend\nstead.player_look = function(self)\nreturn stead.ref(self.where):scene();\nend\nstead.obj_tag = function(self, id)\nlocal k,v\nif isDisabled(self) then\nreturn id\nend\nfor k,v in stead.opairs(self.obj) do\nv = stead.ref(v);\nif isObject(v) and not isDisabled(v) then\nid = id + 1;\nv.id = id;\nid = stead.obj_tag(v, id);\nend\nend\nreturn id;\nend\nstead.player_tagall = function(self)\nlocal id, k, v;\nid = 0;\nid = stead.obj_tag(stead.here(), id);\nid = stead.obj_tag(stead.me(), id);\nfor k,v in stead.opairs(ways()) do\nv = stead.ref(v);\nif isRoom(v) and not isDisabled(v) then\nid = id + 1;\nv.id = id;\nend\nend\nend\nstead.player_action = function(self, what, ...)\nlocal v,r,obj\nobj = stead.ref(self.where):srch(what);\nif not obj then\nreturn stead.call(stead.ref(game), 'action', what, ...); --player_do(self, what, ...);\nend\nv, r = stead.player_take(self, what, ...);\nif not v then\nv, r = stead.call(stead.ref(obj), 'act', ...);\nif not v and r ~= true then\nv, r = stead.call(stead.ref(game), 'act', obj, ...);\nend\nend\nreturn v, r;\nend\nstead.player_take = function(self, what, ...)\nlocal v,r,obj,w\nobj,w = stead.ref(self.where):srch(what);\nif not obj then\nreturn nil, false;\nend\nv,r = stead.call(stead.ref(obj), 'tak', ...);\nif v and r ~= false then\ntake(obj, w);\nend\nreturn v;\nend\nstead.player_use = function(self, what, onwhat, ...)\nlocal obj, obj2, v, vv, r;\nlocal scene_use_mode = false\nobj = self:srch(what); -- in inv?\nif not obj then -- no\nobj = stead.ref(self.where):srch(what); -- in scene?\nif not obj then -- no!\nreturn game.err, false;\nend\nscene_use_mode = true -- scene_use_mode!\nend\nif onwhat == nil then -- only one?\nif scene_use_mode then\nreturn self:action(what, ...); -- call act\nelse\nv, r = stead.call(stead.ref(obj),'inv', ...); -- call inv\nend\nif not v and r ~= true then\nv, r = stead.call(game, 'inv', obj, ...);\nend\nreturn v, r;\nend\nobj2 = stead.ref(self.where):srch(onwhat); -- in scene?\nif not obj2 then\nobj2 = self:srch(onwhat); -- in inv?\nend\nif not obj2 or obj2 == obj then\nreturn game.err, false;\nend\nif not scene_use_mode or isSceneUse(stead.ref(obj)) then\nv, r = stead.call(stead.ref(obj), 'use', obj2, ...);\nif r ~= false then\nvv = stead.call(stead.ref(obj2), 'used', obj, ...);\nend\nend\nif not v and not vv then\nv, r = stead.call(game, 'use', obj, obj2, ...);\nend\nreturn stead.par(stead.space_delim, v, vv);\nend\nstead.player_back = function(self)\nlocal where = stead.ref(self.where);\nif where == nil then\nreturn nil,false\nend\nreturn stead.go(self, where.__from__, true);\nend\nstead.go = function(self, where, back)\nlocal was = self.where;\nlocal need_scene = false;\nlocal ret\nif not stead.in_walk_call then\nret = function(rc) stead.in_walk_call = false return nil end\nelse\nret = function(rc) return rc end\nend\nstead.in_walk_call = true\nif where == nil then\nreturn nil,ret(false)\nend\nif not isRoom(stead.ref(where)) then\nerror (\"Trying to go nowhere: \"..where, 2);\nend\nif not isRoom(stead.ref(self.where)) then\nerror (\"Trying to go from nowhere: \"..self.where, 2);\nend\nif stead.in_entered_call or stead.in_onexit_call then\nerror (\"Do not use walk from onexit/entered action! Use exit/enter action instead:\" .. self.where, 2);\nend\nlocal v, r;\nif not isVroom(stead.ref(where)) and not stead.in_exit_call then\nstead.in_exit_call = true -- to break recurse\nv,r = stead.call(stead.ref(self.where), 'exit', where);\nstead.in_exit_call = nil\nif r == false then\nreturn v, ret(r)\nend\nend\nlocal res = v;\nv = nil;\nif not back or not isDialog(stead.ref(self.where)) or isDialog(stead.ref(where)) then\nv, r = stead.call(stead.ref(where), 'enter', self.where);\nif r == false then\nreturn v, ret(r)\nend\nneed_scene = true;\nif stead.ref(was) ~= stead.ref(self.where) then -- jump !!!\nwhere = stead.deref(self.where);\nneed_scene = false;\nend\nend\nres = stead.par(stead.scene_delim, res, v);\nif not back then\nstead.ref(where).__from__ = stead.deref(self.where);\nend\nself.where = stead.deref(where);\nret();\nPLAYER_MOVED = true\nif need_scene then -- or isForcedsc(stead.ref(where)) then -- i'am not sure...\nreturn stead.par(stead.scene_delim, res, stead.ref(where):scene());\nend\nreturn res;\nend\nstead.player_walk = function(self, where, ...)\nlocal v, r = stead.go(self, where, ...);\nreturn v, r;\nend\nstead.player_go = function(self, where)\nlocal w = stead.ref(self.where).way:srch(where);\nif not w then\nreturn nil,false\nend\nlocal v, r = stead.go(self, w, false);\nreturn v, r;\nend\nstead.player_save = function(self, name, h)\nh:write(stead.string.format('%s.where = %q;\\n', stead.tostr(name), stead.deref(self.where)));\nstead.savemembers(h, self, name, false);\nend\nfunction player(v)\nif v.nam == nil then\nerror (\"No player name in constructor.\", 2);\nend\nif v.where == nil then\nv.where = 'main';\nend\nif v.tag == nil then\nv.tag = stead.player_tagall;\nend\nif v.walk == nil then\nv.walk = stead.player_walk;\nend\nif v.go == nil then\nv.go = stead.player_go;\nend\nif v.ways == nil then\nv.ways = stead.player_ways;\nend\nif v.back == nil then\nv.back = stead.player_back;\nend\nif v.look == nil then\nv.look = stead.player_look;\nend\nif v.inv == nil then\nv.inv = stead.player_inv;\nend\nif v.use == nil then\nv.use = stead.player_use;\nend\nif v.action == nil then\nv.action = stead.player_action;\nend\nif v.save == nil then\nv.save = stead.player_save;\nend\nif v.objs == nil then\nv.objs = stead.player_objs;\nend\nv.player_type = true;\nreturn obj(v);\nend\nstead.game_life = function(self)\nlocal i,o\nlocal av,v\nstead.in_life_call = true;\nstead.in_life_move = false\nstead.lifes_op = {}; -- lifes to on/off\nstead.PLAYER_MOVED = PLAYER_MOVED\nfor i,o in stead.opairs(self.lifes) do\nlocal vv\nlocal pre\no = stead.ref(o);\nif not isDisabled(o) then\nPLAYER_MOVED = false\nvv,pre = stead.call(o, 'life');\nif PLAYER_MOVED then -- clear life output, but not current\nav = nil\nv = nil\nstead.in_life_move = true\nACTION_TEXT = vv;\nelseif pre then\nav = stead.par(stead.space_delim, av, vv);\nelse\nv = stead.par(stead.space_delim, v, vv);\nend\nend\nend\nPLAYER_MOVED = stead.in_life_move\nif not PLAYER_MOVED then PLAYER_MOVED = stead.PLAYER_MOVED end\nstead.PLAYER_MOVED = nil\nstead.in_life_call = false;\nfor i,o in stead.ipairs(stead.lifes_op) do\nif o[1] then\nstead.lifeon(o[2], o[3]);\nelse\nstead.lifeoff(o[2]);\nend\nend\nstead.lifes_op = nil;\nreturn v, av;\nend\nstead.player_moved = function()\nreturn PLAYER_MOVED or stead.PLAYER_MOVED\nend\nstead.life_moved = function()\nreturn stead.in_life_move\nend\nstead.check_list = function(k, v, p)\nif v.check == nil or not v:check(stead.string.format(\"%s[%q]\", p, k)) then\nerror (\"error in list: \"..stead.object..'.'..k);\nend\nend\nstead.check_room = function(k, v)\nif v.obj == nil then\nerror(\"no obj in room:\"..k);\nend\nif v.way == nil then\nerror(\"no way in room:\"..k);\nend\nend\nstead.check_player = function(k, v)\nv.where = stead.deref(v.where);\nend\nstead.check_object = function(k, v)\nif not v.nam then\nerror (\"No name in \"..k);\nend\nif isRoom(v) then\nstead.check_room(k, v);\nend\nif isPlayer(v) then\nstead.check_player(k, v);\nend\nfor_each(v, k, stead.check_list, isList, stead.deref(v))\nend\nfunction for_everything(f, ...)\nlocal is_ok = function(s)\nreturn true\nend\nfor_each(_G, '_G', f, is_ok, ...)\nend\nlocal compat_api = function()\nif stead.compat_api then\nreturn\nend\nif not stead.api_atleast(1, 6, 0) then\nif not go then\ngo = stead.go\nend\nif not goin then\ngoin = walkin\nend\nif not goout then\ngoout = walkout\nend\nif not goback then\ngoback = walkback\nend\nif not _G[\"goto\"] then\nif _VERSION == \"Lua 5.1\" then -- 5.1 lua\n_G[\"goto\"] = walk\nend\nend\nend\nif not stead.api_atleast(1, 7, 1) then\nif not goin then\ngoin = function() error (\"Please use 'walkin' instead 'goin'.\", 2) end\nend\nif not goout then\ngoout = function() error (\"Please use 'walkout' instead 'goout'.\", 2) end\nend\nif not goback then\ngoback = function() error (\"Please use 'walkback' instead 'goback'.\", 2) end\nend\nif not _G[\"goto\"] then\nif _VERSION == \"Lua 5.1\" then -- 5.1 lua\n_G[\"goto\"] = function() error (\"Please use 'walk' instead 'goto'.\", 2) end\nend\nend\nget_savepath = instead_savepath\nget_gamepath = instead_gamepath\nget_steadpath = instead_steadpath\nget_themespath = instead_themespath\nget_gamespath = instead_gamespath\ntheme_var = instead_themevar\ntheme_name = instead_theme_name\nis_sound = instead_sound\nset_timer = instead_timer\nmenu_toggle = instead_menu_toggle\nstead_busy = instead_busy\nreaddir = instead_readdir\nsound_load = instead_sound_load\nsound_free = instead_sound_free\nsounds_free = instead_sounds_free\nsound_channel = instead_sound_channel\nsound_volume = instead_sound_volume\nsound_panning = instead_sound_panning\nfont_load = instead_font_load\nfont_free = instead_font_free\nfont_scaled_size = instead_font_scaled_size\nsprite_alpha = instead_sprite_alpha\nsprite_dup = instead_sprite_dup\nsprite_scale = instead_sprite_scale\nsprite_rotate = instead_sprite_rotate\nsprite_text = instead_sprite_text\nsprite_text_size = instead_sprite_text_size\nsprite_draw = instead_sprite_draw\nsprite_copy = instead_sprite_copy\nsprite_compose = instead_sprite_compose\nsprite_fill = instead_sprite_fill\nsprite_pixel = instead_sprite_pixel\nsprite_load = instead_sprite_load\nsprite_free = instead_sprite_free\nsprite_size = instead_sprite_size\nsprites_free = instead_sprites_free\ncall = stead.call\ncall_bool = stead.call_bool\ncall_value = stead.call_value\nget_title = stead.get_title\nget_picture = stead.get_picture\nget_inv = stead.get_inv\nget_ways = stead.get_ways\nget_autosave = stead.get_autosave\nfmt = stead.fmt\nobj_tag = stead.obj_tag\nmodule_init = stead.module_init\nplayer_inv = stead.player_inv\ndialog_enter = stead.dialog_enter\nend\nif not stead.api_atleast(1, 4, 5) then\nstead.xref = function(...)\nreturn xref(...);\nend\n-- internals of call\ncctx = stead.cctx\ncallpush = stead.callpush\ncallpop = stead.callpop\nclearargs = stead.clearargs\n-- saving\nsavemembers = stead.savemembers;\nsavevar = stead.savevar\nclearvar = stead.clearvar\n--do_ini = stead.do_ini\n--do_savegame = stead.do_savegame\nend\nstead.compat_api = true\nend\nstead.do_ini = function(self, load)\nlocal v='',vv\nlocal function call_key(k, o)\no.key_name = k;\nend\nlocal function call_codekey(k, o)\nstead.functions[o].key_name = k;\nend\nlocal function call_ini(k, o, ...)\nv = stead.par('', v, stead.call(o, 'ini', ...));\nend\nstead.math.randomseed(stead.os.time(stead.os.date(\"*t\")))\nstead.rnd(1); stead.rnd(2); stead.rnd(3); -- Lua bug?\nif stead.type(game) ~= 'table' then\nerror (\"No valid 'game' object.\");\nend\nif not isPlayer(stead.me()) then\nerror (\"No valid player.\");\nend\nif not isRoom(stead.here()) then\nerror (\"No valid room.\");\nend\ngame.pl = stead.deref(game.pl);\nstead.me().where = stead.deref(stead.me().where);\n--game.where = stead.deref(game.where);\nif not load then \ncompat_api()\nfor_everything(function(k, s)\nif isObject(s) then\ncall_key(k, s)\nelseif isCode(s) then\ncall_codekey(k, s)\nend\nend)\nfor_each_object(stead.check_object);\ncall_key(\"game\", game);\nfor_each(game, \"game\", stead.check_list, isList, stead.deref(game))\nend\nfor_each_object(call_ini, load);\nstead.me():tag();\nif not self.showlast then\nstead.last_disp(false)\nend\nstead.initialized = true\nreturn stead.par('',v, stead.last_disp()); --stead.par('^^',v);\nend\nstead.game_ini = function(self)\nlocal v,vv\nv = stead.do_ini(self);\nvv = iface:title(stead.call(self,'nam'));\nvv = stead.par(stead.scene_delim, vv, stead.call(self,'dsc'));\nif stead.type(init) == 'function' then\ninit();\nend\n--if stead.type(hooks) == 'function' then\n--hooks();\n--end\nreturn stead.par(stead.scene_delim, vv, v);\nend\nstead.game_start = function(s)\nif stead.type(start) == 'function' then\nstart() -- start function\nend\nend\nfunction game(v)\nif v.nam == nil then\nerror (\"No game name in constructor.\", 2);\nend\nif v.pl == nil then\nv.pl = 'player';\nend\nif v.ini == nil then\nv.ini = stead.game_ini;\nend\nif v.start == nil then\nv.start = stead.game_start\nend\nif v.save == nil then\nv.save = stead.game_save;\nend\nif v.load == nil then\nv.load = stead.game_load;\nend\nif v.life == nil then\nv.life = stead.game_life;\nend\nif v.step == nil then\nv.step = stead.game_step;\nend\nif v.lifes == nil then\nv.lifes = {};\nend\nv.lifes = list(v.lifes);\nv._time = 0;\nv._running = true;\nv.game_type = true;\nreturn v;\nend\nfunction live(v)\nreturn stead.ref(game.lifes:srch(v));\nend\nfunction isEnableSave()\nif game.enable_save == nil or stead.get_autosave() then\nreturn true\nend\nreturn stead.call_bool(game, 'enable_save');\nend\nfunction isEnableAutosave()\nif game.enable_autosave == nil then\nreturn true\nend\nreturn stead.call_bool(game, 'enable_autosave');\nend\nfunction for_each(o, n, f, fv, ...)\nlocal call_list = {}\nlocal k,v\nif stead.type(o) ~= 'table' then\nreturn\nend\nstead.object = n;\nfor k,v in stead.pairs(o) do\nif fv(v) then\nstead.table.insert(call_list, { k = k, v = v });\nend\nend\nfor k, v in stead.ipairs(call_list) do\nf(v.k, v.v, ...);\nend\nend\nfunction isCode(s)\nreturn stead.type(s) == 'function' and stead.type(stead.functions[s]) == 'table'\nend\nfunction for_each_codeblock(f,...)\nfor_each(_G, '_G', f, isCode, ...)\nend\nfunction for_each_object(f,...)\nfor_each(_G, '_G', f, isObject, ...)\nend\nfunction for_each_player(f,...)\nfor_each(_G, '_G', f, isPlayer, ...)\nend\nfunction for_each_room(f,...)\nfor_each(_G, '_G', f, isRoom, ...)\nend\nfunction for_each_list(f,...)\nfor_each(_G, '_G', f, isList, ...)\nend\nstead.clearvar = function(v)\nlocal k,o\nfor k,o in stead.pairs(v) do\nif stead.type(o) == 'table' and o.__visited__ ~= nil then\no.__visited__ = nil\no.auto_saved = nil\nstead.clearvar(o)\nend\nend\nend\nstead.savemembers = function(h, self, name, need)\nlocal k,v\nfor k,v in stead.pairs(self) do\nlocal need2\nif k ~= \"__visited__\" then\nneed2 = false\nif isForSave(k, v, self) then\nneed2 = true;\nend\nif stead.type(k) == 'string' then\nstead.savevar(h, v, name..'['..stead.string.format(\"%q\",k)..']', need or need2);\nelseif stead.type(k) == 'number' then\nstead.savevar(h, v, name..\"[\"..k..\"]\", need or need2)\nelseif stead.type(k) == 'table' and stead.type(k.key_name) == 'string' then\nstead.savevar(h, v, name..\"[\"..k.key_name..\"]\", need or need2)\nend\nend\nend\nend\n-- savemembers = stead.savemembers;\nstead.savevar = function(h, v, n, need)\nlocal r,f\nif v == nil or stead.type(v) == \"userdata\" or\n stead.type(v) == \"function\" then\nif isCode(v) and need then\nif stead.type(stead.functions[v].key_name) == 'string' \nand stead.functions[v].key_name ~= n then\nh:write(stead.string.format(\"%s=%s\\n\", n, stead.functions[v].key_name))\nelse\nh:write(stead.string.format(\"%s=code %q\\n\", n, stead.functions[v].code))\nend\nend\n--if need then\n--error (\"Variable \"..n..\" can not be saved!\");\n--end \nreturn \nend\n--if stead.string.find(n, '_') ==  1 or stead.string.match(n,'^%u') then\n--need = true;\n--end\nif stead.type(v) == \"string\" then\nif not need then \nreturn\nend\nh:write(stead.string.format(\"%s=%q\\n\",n,v))\nreturn;\nend\n \nif stead.type(v) == \"table\" then\nif v == _G then return end\nif stead.type(v.key_name) == 'string' and v.key_name ~= n then -- just xref\nif v.auto_allocated and not v.auto_saved then\nv:save(v.key_name, h, false, true); -- here todo\nend\nif need then\nif stead.ref(v.key_name) == nil then\nv.key_name = 'null'\nend\nh:write(stead.string.format(\"%s = %s\\n\", n, v.key_name));\nend\nreturn\nend\nif v.__visited__ ~= nil then\nreturn\nend\nv.__visited__ = n;\nif stead.type(v.save) == 'function' then\nv:save(n, h, need);\nreturn;\nend\nif need then\nh:write(n..\" = {};\\n\");\nend\nstead.savemembers(h, v, n, need);\nreturn;\nend\nif not need then\nreturn\nend\nh:write(n, \" = \",tostring(v))\nh:write(\"\\n\") \nend\n-- savevar = stead.savevar\nstead.gamereset = function(file, forget)\nstead.clearargs()\nif stead.api_atleast(2, 2, 0) then\ninit = function() -- init called only once\nend\nend\nif forget then\nstead.stop_music();\nstead.stop_sound();\ntimer:stop();\nif stead.type(variables) == 'table' then\nlocal k,v\nfor k,v in stead.ipairs(variables) do\n_G[v] = nil\nend\nvariables = nil\nvariables_save = nil\nend\ninit = function() -- null init function\nend\nstart = function() -- null start function\nend\nfor_each_object(function(k, o) -- destroy all objects\nif o.system_type then\nreturn\nend\n_G[k] = nil\nend);\ngame._scripts = { }\ngame.lifes:zap()\ngame.scriptsforget = true\n-- anything else?\nstead:init();\nend\ndofile(file);\ngame:ini();\nif #game._scripts == 0 or file ~= game._scripts[#game._scripts] then\nif #game._scripts ~= 0 or file ~= 'main.lua' then\nstead.table.insert(game._scripts, file);\nend\nend\nend\nstead.gamefile = function(file, forget)\nstead.gamereset(file, forget)\nif forget then\ngame:start()\nstead.started = true\nreturn stead.walk(stead.here(), false, false, true);\nend\nend\nstead.do_savegame = function(s, h)\nstead.busy(true)\nlocal function save_object(key, value, h)\nstead.busy(true)\nstead.savevar(h, value, key, false);\nend\nlocal function save_var(key, value, h)\nstead.busy(true)\nstead.savevar(h, value, key, isForSave(key, value, _G))\nend\nlocal forget = game.scriptsforget\nlocal i,v\nfor i,v in stead.ipairs(s._scripts) do\nh:write(stead.string.format(\"stead.gamereset(%q,%s)\\n\", \nv, stead.tostr(forget)))\nforget = nil\nend\nsave_object('allocator', allocator, h); -- always first!\nfor_each_object(save_object, h);\nsave_object('game', s, h);\nfor_everything(save_var, h);\n--save_object('_G', _G, h);\nstead.clearvar(_G);\nstead.busy(false)\nend\nstead.savename = function()\nreturn stead.call(stead.here(), 'nam');\nend\nstead.game_save = function(self, name, file) \nlocal h;\nif file ~= nil then\nfile:write(stead.string.format(\"%s.pl = %q\\n\", name, stead.deref(self.pl)));\nstead.savemembers(file, self, name, false);\nreturn nil, true\nend\nif not isEnableSave() then\nreturn nil, false\nend\nif name == nil then\nreturn nil, false\nend\nh = stead.io.open(name,\"wb\");\nif not h then\nreturn nil, false\nend\nlocal n\nif stead.type(stead.savename) == 'function' then\nn = stead.savename()\nend\nif stead.type(n) == 'string' and n ~= \"\" then\nh:write(\"-- $Name: \"..n:gsub(\"\\n\",\"\\\\n\")..\"$\\n\");\nend\nstead.do_savegame(self, h);\nh:flush();\nh:close();\ngame.autosave = false; -- we have only one try for autosave\nstead.restart_game = false\nreturn nil;\nend\nstead.game_load = function(self, name) \nif name == nil then\nreturn nil, false\nend\nlocal f, err = loadfile(name);\nif f then\nlocal i,r = f();\nif r then\nreturn nil, false\nend\ni, r = stead.do_ini(self, true);\nif not stead.started then\ngame:start()\nstead.started = true\nend\nreturn i, r\nend\nreturn nil, false\nend\nstead.game_step = function(self)\nself._time = self._time + 1;\nreturn self:life(self);\nend\ngame = game {\ncodepage = \"UTF-8\",\nnam = \"INSTEAD -- Simple Text Adventure interpreter v\"..stead.version..\" '2009-2016 by Peter Kosyh\",\ndsc = [[\nCommands:^\n    look(or just enter), act <on what> (or just what), use <what> [on what], go <where>,^\n    back, inv, way, obj, quit, save <fname>, load <fname>.]],\npl ='pl',\nshowlast = true, \n_scripts = {},\n};\nstead.strip = function(s)\nlocal s = stead.tostr(s);\ns = stead.string.gsub(s, '^[ \\t]*', '');\ns = stead.string.gsub(s, '[ \\t]*$', '');\nreturn s;\nend\nfunction isForcedsc(v)\nlocal r,g\nr = stead.call_bool(v, 'forcedsc');\nif r then\nreturn true\nend\ng = stead.call_bool(game, 'forcedsc', v);\nreturn g and r ~= false\nend\nfunction isSceneUse(v)\nlocal o,g\no = stead.call_bool(v, 'scene_use');\nif o then\nreturn true\nend\ng = stead.call_bool(game, 'scene_use', v);\nreturn g and o ~= false\nend\niface = {\nanchor = function(self)\nreturn '';\nend;\nimg = function(self, str)\nreturn '';\nend,\nnb = function(self, str)\nreturn str;\nend,\nem = function(self, str)\nreturn str;\nend,\nright = function(self, str)\nreturn str;\nend,\nleft = function(self, str)\nreturn str;\nend,\ncenter = function(self, str)\nreturn str;\nend,\njust = function(self, str)\nreturn str;\nend,\ntop = function(self, str)\nreturn str;\nend,\nbottom = function(self, str)\nreturn str;\nend,\nmiddle = function(self, str)\nreturn str;\nend,\ntab = function(self, str, al)\nreturn '';\nend;\nbold = function(self, str)\nreturn str;\nend,\nunder = function(self, str)\nreturn str;\nend,\nst = function(self, str)\nreturn str;\nend,\nenum = function(self, n, str)\nreturn n..' - '..str;\nend,\nxref = function(self, str, obj)\nlocal o = stead.ref(stead.here():srch(obj));\nif not o then \no = stead.ref(ways():srch(obj));\nend\nif not o then\no = stead.ref(stead.me():srch(obj));\nend\nif not o or not o.id then\nreturn str;\nend\nreturn stead.cat(str,\"(\"..stead.tostr(o.id)..\")\");\nend,\ntitle = function(self, str)\nreturn \"[\"..str..\"]\";\nend,\nobjs = function(self, str)\nreturn str;\nend,\nways = function(self, str)\nreturn str;\nend,\ninv = function(self, str)\nreturn str;\nend,\ntext = function(self, str)\nif str then\nprint(str);\nend\nend,\nfmt = function(self, cmd, st, moved, r, av, objs, pv) -- st -- changed state (main win), move -- loc changed\nlocal l, vv\nif st and not moved then\nif cmd ~= 'look' then\nav = txtem(av);\npv = txtem(pv);\nr  = txtem(r);\nif isForcedsc(stead.here()) then\nl = stead.me():look();\nend\nend\nend\nvv = stead.fmt(stead.cat(stead.par(stead.scene_delim, l, r, av, objs, pv), '^'));\nreturn vv\nend,\ncmd = function(self, inp)\nlocal r, v;\nv = false\nstead.state = false; -- changed state (main screen)\nlocal a = { };\nlocal cmd;\nRAW_TEXT = nil\nPLAYER_MOVED = nil\nstead.set_sound(); -- empty sound\ncmd,a = stead.getcmd(inp);\nif cmd == '' then cmd = 'look' end\n--stead.me():tag();\nlocal oldloc = stead.here();\nif cmd == 'look' then\nstead.state = true\nr,v = stead.me():look();\nelseif cmd == 'obj' then\nr,v = stead.me():objs();\nelseif cmd == 'inv' then\nr,v = stead.me():inv();\nelseif cmd == 'way' then\nr,v = stead.me():ways();\nelseif cmd == 'ls' then\nr = stead.par(stead.scene_delim, stead.me():objs(), stead.me():inv(), stead.me():ways());\nv = nil;\nelseif cmd == 'go' then\nstead.state = true\nr,v = stead.me():go(stead.unpack(a));\nelseif cmd == 'back' then\nstead.state = true\nr,v = stead.me():go(stead.from());\nelseif cmd == 'act' then\nstead.state = true\nr,v = stead.me():action(stead.unpack(a));\nelseif cmd == 'use' then\nstead.state = true\nr,v = stead.me():use(stead.unpack(a));\nelseif cmd == 'save' then\nr, v = game:save(stead.unpack(a));\nelseif cmd == 'load' then\nr, v = game:load(stead.unpack(a));\nif v ~= false and game.showlast then\nreturn r;\nend\nelseif cmd == 'wait' then -- nothing todo in game, skip tick\nv = nil;\nr = true;\nstead.state = true\nelseif cmd == 'nop' then -- inv only\nv = true;\nr = nil;\nstead.state = true\nelse\nstead.state = true\nr,v = stead.me():action(cmd, stead.unpack(a));\nend\n-- here r is action result, v - ret code value\n-- state -- game state changed\nif stead.state and r == nil and v == true then -- we do nothing\nreturn nil, true; -- menu\nend\nif stead.state and r == nil and v == nil and stead.api_atleast(1, 3, 5) then -- new goto\nreturn nil, false -- really nothing\nend\nif RAW_TEXT and v ~= false then\nreturn stead.cat(r, '\\n'), true;\nend\nif v == false then\nreturn stead.cat(r, '\\n'), false;\nend\nACTION_TEXT = r; -- here, life methods can redefine this\nlocal av, pv -- av -- active lifes, pv -- background\nlocal vv\nif stead.state then\npv,av = game:step();\nstead.me():tag();\nvv = stead.here():look();\nend\nvv = self:fmt(cmd, stead.state, (oldloc ~= stead.here()) or PLAYER_MOVED, \nACTION_TEXT, av, vv, pv);\nif stead.state then\nstead.last_disp(vv or false)\nstead.last_act(ACTION_TEXT)\nend\nif vv == nil then -- nil is error\nvv = ''\nend\nreturn vv, true; -- action is here\nend, \nshell = function(self)\nlocal inp, i, k, cmd, a, n;\nstead.me():tag();\nwhile game._running do\ninp = stead.io.read(\"*l\");\nif inp == 'quit' then\nbreak;\nend\nself:text(self:cmd(inp));\nend\nend\n};\nfunction me()\nreturn stead.ref(game.pl);\nend\nstead.me = me\nfunction where(s)\nif not isObject(stead.ref(s)) then error(\"Wrong parameter to where.\", 2); end\nif isPlayer(stead.ref(s)) then\nreturn stead.ref(stead.ref(s).where);\nend\nreturn stead.ref(stead.ref(s).__where__);\nend\nfunction here()\nreturn stead.ref(stead.me().where);\nend\nstead.here = here\nfunction from(w)\nif w == nil then\nw = stead.here();\nelse\nw = stead.ref(w);\nend\nreturn stead.ref(w.__from__);\nend\nstead.from = from\nstead.time = function(s)\nlocal n = game._time;\nif stead.type(s) == 'number' then\ngame._time = s\nend\nreturn n\nend\nfunction inv()\nreturn stead.me().obj;\nend\nfunction objs(w)\nif not w then\nreturn stead.here().obj;\nelse\nreturn stead.ref(w).obj;\nend\nend\nfunction ways(w)\nif not w then\nreturn stead.here().way;\nelse\nreturn stead.ref(w).way;\nend\nend\nstead.xref = function(str, obj, ...)\nif stead.type(str) ~= 'string' then return nil; end; \nreturn iface:xref(str, obj, ...);\nend\nxref = stead.xref\nfunction pseen(...)\nif not isDialog(stead.here()) then\nreturn\nend\nreturn stead.here():pseen(...);\nend\nfunction punseen(...)\nif not isDialog(stead.here()) then\nreturn\nend\nreturn stead.here():punseen(...);\nend\nfunction pon(...)\nif not isDialog(stead.here()) then\nreturn\nend\nstead.here():pon(...);\nend\nfunction poff(...)\nif not isDialog(stead.here()) then\nreturn\nend\nstead.here():poff(...);\nend\nfunction prem(...)\nif not isDialog(stead.here()) then\nreturn\nend\nstead.here():prem(...);\nend\nfunction lifeon(what, nr)\nif stead.in_life_call then\nstead.table.insert(stead.lifes_op, { true, what, nr });\nreturn\nend\ngame.lifes:add(what, nr);\nend\nstead.lifeon = lifeon\nfunction lifeoff(what)\nif stead.in_life_call then\nstead.table.insert(stead.lifes_op, { false, what });\nreturn\nend\ngame.lifes:del(what);\nend\nstead.lifeoff = lifeoff\nstead.allocator_save = function(s, name, h, need, auto)\nif s.auto_allocated and not auto then\nreturn\nend\nif need then\nif s.auto_allocated then -- in current realization always false\nlocal m = stead.string.format(\"allocator:new(%s, %s)\\n\", \nstead.tostring(s.constructor),\nstead.tostring(s.constructor));\nh:write(m);\nelse\nlocal m = stead.string.format(\" = allocator:get(%s, %s)\\n\",\nstead.tostring(name),\nstead.tostring(s.constructor));\nh:write(name..m);\nif stead.api_atleast(1, 3, 0) then\nm = stead.string.format(\"stead.check_object(%s, %s)\\n\",\nstead.tostring(name),\nname);\nh:write(m);\nend\nend\nend\nstead.savemembers(h, s, name, false);\nif s.auto_allocated then\ns.auto_saved = true\nend\nend\nfunction new(str)\nif stead.type(str) ~= 'string' then\nerror(\"Non string constructor in new.\", 2);\nend\nreturn allocator:new(str);\nend\nfunction delete(v)\nallocator:delete(v);\nend\nstead.vobj_save = function(self, name, h, need)\nlocal dsc = self.dsc;\nlocal w = stead.deref(self.where);\nif need then\nh:write(stead.string.format(\"%s  = vobj(%s, %s, %s, %s);\\n\",\nname, \nstead.tostring(self.key), \nstead.tostring(self.nam), \nstead.tostring(dsc), \nstead.tostring(w)));\nend\nstead.savemembers(h, self, name,false);\nend\nstead.vobj_act = function(self, ...)\nlocal o, r = stead.here():srch(self); -- self.nam\nif stead.ref(o) and stead.ref(o).where then\nreturn stead.walk(stead.ref(o).where);\nend\nreturn stead.call(stead.ref(r),'act', self.key, ...);\nend\nstead.vobj_used = function(self, ...)\nlocal o, r = stead.here():srch(self.nam);\nreturn stead.call(stead.ref(r),'used', self.key, ...);\nend\nfunction vobj(key, name, dsc, w)\nif not stead.tonum(key) then\nerror (\"vobj key must be number!\", 2);\nend\nreturn obj{ key = key, nam = name, dsc = dsc, where = stead.deref(w), act = stead.vobj_act, used = stead.vobj_used, save = stead.vobj_save, obj = list({}) };\nend\nfunction vway(name, dsc, w)\nreturn  obj{ key = -1, nam = name, dsc = dsc, act = stead.vobj_act, where = stead.deref(w), used = stead.vobj_used, save = stead.vobj_save, obj = list({}), };\nend\nstead.vroom_save = function(self, name, h, need)\nif need then\nlocal t = stead.string.format(\"%s = vroom(%s, %q);\\n\",\nname, stead.tostring(self.nam), \nstead.deref(self.where))\nh:write(t);\nend\nstead.savemembers(h, self, name,false);\nend\nstead.vroom_enter = function(self, ...)\nreturn stead.walk(self.where);\nend\nfunction isVroom(v)\nreturn (stead.type(v) == 'table') and (v.vroom_type)\nend\nfunction vroom(name, w)\nif w == nil then\nerror(\"Wrong parameter to vroom.\", 2);\nend\nreturn room { vroom_type = true, nam = name, where = stead.deref(w), enter = stead.vroom_enter, save = stead.vroom_save, };\nend\nfunction walk(what)\nlocal v,r=stead.me():walk(what);\nstead.me():tag();\nreturn v,r;\nend\nstead.walk = walk;\nfunction back()\nreturn stead.me():back();\nend\nstead.back = back;\nstead.rnd = function(...)\nif stead.random then\nreturn stead.random(...)\nend\nreturn stead.math.random(...);\nend\nstead.rndseed = function(...)\nif stead.randomseed then\nreturn stead.randomseed(...)\nend\nstead.math.randomseed(...)\nend\nfunction taken(obj)\nif isObject(stead.ref(obj)) and stead.ref(obj)._taken then\nreturn true\nend\nreturn false;\nend\nfunction remove(obj, from)\nlocal o,w\nfrom = stead.ref(from)\nif from then\nif isList(from) then\nreturn from:del(obj)\nend\no,w = from:srch(obj);\nelse\no,w = stead.here():srch(obj);\nend\nif w then\nstead.ref(w).obj:del(obj);\nend\no = stead.ref(o);\nif not isObject(o) then\no = stead.ref(obj);\nend\nif isObject(o) then\no.__where__ = nil;\nend\nreturn o\nend\nstead.remove = remove\nfunction purge(obj, from)\nlocal o,w\nfrom = stead.ref(from)\nif from then\nif isList(from) then\nreturn from:purge(obj)\nend\no,w = from:srch(obj, true);\nelse\no,w = stead.here():srch(obj, true);\nend\nif w then\nstead.ref(w).obj:purge(obj);\nend\no = stead.ref(o);\nif not isObject(o) then\no = stead.ref(obj);\nend\nif isObject(o) then\no.__where__ = nil;\nend\nreturn o\nend\nstead.purge = purge\nfunction taketo(obj, wh, pos)\nlocal o = remove(obj, wh);\nif not isObject(o) then\nerror (\"Trying to take wrong object.\", 2);\nend\ninv():add(obj, pos);\no._taken = true\nwh = stead.deref(stead.me())\nif stead.type(wh) == 'string' then\no.__where__ = wh;\nend\nreturn o\nend\nfunction take(obj, wh)\nreturn taketo(obj, wh);\nend\nfunction takef(obj, wh)\nreturn taketo(obj, wh, 1);\nend\nfunction putto(obj, w, pos)\nlocal wh\nlocal o = stead.ref(obj);\nif not isObject(o) then\nerror (\"Trying to put wrong object.\", 2);\nend\nif not w then\nwh = stead.deref(stead.here());\nw = stead.here();\nelse\nwh = stead.deref(w);\nw = stead.ref(w);\nend\nif isList(w) then\nw:add(obj, pos);\nelse\nw.obj:add(obj, pos);\nend\nif stead.type(wh) == 'string' then\no.__where__ = wh;\nend\nreturn o;\nend\nfunction put(obj, w)\nreturn stead.placeto(obj, w);\nend\nfunction putf(obj, w)\nreturn stead.placeto(obj, w, 1);\nend\nplace = put\nplacef = putf\nplaceto = putto\nstead.placeto = placeto\nfunction replace(obj, obj2, from)\nlocal o,w,i\nif not isObject(stead.ref(obj2)) then\nerror (\"Wrong parameter to replace.\", 2);\nend\nfrom = stead.ref(from)\nif from then\nif isList(from) then\nfrom:replace(obj, obj2);\nreturn stead.ref(obj)\nend\no,w = from:srch(obj);\nelse\no,w = stead.here():srch(obj);\nend\nif w then\nstead.ref(w).obj:replace(o, obj2);\nstead.ref(obj2).__where__ = stead.deref(w);\nelse\nstead.placeto(obj2, from);\nend\no = stead.ref(o);\nif not isObject(o) then\no = stead.ref(obj);\nend\nif isObject(o) then\no.__where__ = nil;\nend\nreturn o;\nend\nfunction drop(obj, w)\nlocal o = put(obj, w);\nif not isObject(o) then\nerror (\"Trying to drop wrong object.\", 2);\nend\ninv():del(obj);\no._taken = false\nreturn o;\nend\nfunction dropf(obj, w)\nlocal o = putf(obj, w);\nif not isObject(o) then\nerror (\"Trying to dropf wrong object.\", 2);\nend\ninv():del(obj);\no._taken = false\nreturn o;\nend\nfunction dropto(obj, w, pos)\nlocal o = putto(obj, w, pos);\nif not isObject(o) then\nerror (\"Trying to dropto wrong object.\", 2);\nend\ninv():del(obj);\no._taken = false\nreturn o;\nend\nfunction seen(obj, wh)\nif not wh then\nwh = stead.here();\nelse\nwh = stead.ref(wh);\nend\nlocal o,w = wh:srch(obj);\no = stead.ref(o);\nif isObject(o) then\nreturn o,w\nend\nreturn nil\nend\nfunction exist(obj, wh)\nif not wh then\nwh = stead.here();\nelse\nwh = stead.ref(wh);\nend\nlocal o,w = wh:srch(obj, true);\no = stead.ref(o);\nif isObject(o) then\nreturn o,w\nend\nreturn nil\nend\nfunction have(obj)\nlocal o = inv():srch(obj);\no = stead.ref(o);\nif isObject(o) then\nreturn o\nend\nreturn nil\nend\nfunction moveto(obj, there, from, pos)\nstead.remove(obj, from);\nstead.placeto(obj, there, pos);\nreturn stead.ref(obj);\nend\nstead.moveto = moveto\nfunction move(obj, there, from)\nreturn stead.moveto(obj, there, from);\nend\nfunction movef(obj, there, from)\nreturn stead.moveto(obj, there, from, 1);\nend\nstead.get_picture = function()\nlocal s = stead.call(stead.here(),'pic');\nif not s then\ns = stead.call(game, 'pic');\nend\nreturn s;\nend\nstead.get_title = function()\nlocal s = stead.call(stead.here(),'nam');\nreturn s;\nend\nstead.get_music = function()\nreturn game._music, game._music_loop;\nend\nstead.get_music_loop = function()\nreturn game._music_loop;\nend\nstead.save_music = function(s)\nif s == nil then\ns = self\nend\ns.__old_music__ = stead.get_music();\ns.__old_loop__ = stead.get_music_loop();\nend\nstead.restore_music = function(s)\nif s == nil then\ns = self\nend\nstead.set_music(s.__old_music__, s.__old_loop__);\nend\nstead.set_music = function(s, count)\ngame._music = s;\nif not stead.tonum(count) then\ngame._music_loop = 0;\nelse\ngame._music_loop = stead.tonum(count);\nend\nend\nstead.set_music_fading = function(o, i)\nif o and o == 0 then o = -1 end\nif i and i == 0 then i = -1 end\ngame._music_fadeout = o\nif not i then\ngame._music_fadein = o\nelse\ngame._music_fadein = i\nend\nend\nstead.get_music_fading = function()\nreturn game._music_fadeout, game._music_fadein\nend\nstead.stop_music = function()\nstead.set_music(nil, -1);\nend\nstead.is_music = function()\nreturn game._music ~= nil and game._music_loop ~= -1\nend\nif instead_sound == nil then\nfunction instead_sound()\nreturn false -- sdl-instead export own function\nend\nend\nstead.is_sound = instead_sound\nif instead_savepath == nil then\nfunction instead_savepath()\nreturn \"./\"\nend\nend\nfunction autosave(slot)\ngame.autosave = true;\ngame.autosave_slot = slot;\nend\nstead.autosave = autosave;\nstead.get_restart = function()\nreturn stead.restart_game\nend\nstead.get_menu = function()\nlocal n = stead.need_menu\nstead.need_menu = nil\nreturn n\nend\nstead.restart = function()\nstead.restart_game = true\nend\nstead.get_autosave = function()\nreturn game.autosave, game.autosave_slot\nend\nstead.get_sound = function()\nreturn game._sound, game._sound_channel, game._sound_loop;\nend\nstead.get_sound_chan = function()\nreturn game._sound_channel\nend\nstead.get_sound_loop = function()\nreturn game._sound_loop\nend\nstead.stop_sound = function(chan, fo)\nif not stead.tonum(chan) then\nif stead.tonum(fo) then\nstead.set_sound('@-1,'..stead.tostr(fo));\nelse\nstead.set_sound('@-1');\nend\nreturn\nend\nif stead.tonum(fo) then\nstead.add_sound('@'..stead.tostr(chan)..','..stead.tostr(fo));\nelse\nstead.add_sound('@'..stead.tostr(chan));\nend\nend\nstead.add_sound = function(s, chan, loop)\nif stead.type(s) ~= 'string' then\nreturn\nend\nif stead.type(game._sound) == 'string' then\nif stead.tonum(chan) then\ns = s..'@'..stead.tostr(chan);\nend\nif stead.tonum(loop) then\ns = s..','..stead.tostr(loop)\nend\nstead.set_sound(game._sound..';'..s, stead.get_sound_chan(), stead.get_sound_loop());\nelse\nstead.set_sound(s, chan, loop);\nend\nend\nstead.set_sound = function(s, chan, loop)\ngame._sound = s;\nif not stead.tonum(loop) then\ngame._sound_loop = 1;\nelse\ngame._sound_loop = stead.tonum(loop);\nend\nif not stead.tonum(chan) then\ngame._sound_channel = -1;\nelse\ngame._sound_channel = stead.tonum(chan);\nend\nend\nfunction change_pl(p)\nlocal o = stead.ref(p);\nif stead.type(stead.deref(p)) ~= 'string' or not o then\nerror (\"Wrong player name in change_pl...\", 2);\nend\ngame.pl = stead.deref(p);\nreturn stead.walk(o.where, false, true, true); -- no call enter/exit\nend\nfunction disabled(o)\nreturn isDisabled(stead.ref(o))\nend\nfunction disable(o)\no = stead.ref(o)\nif isObject(o) then\no:disable()\nend\nreturn o\nend\nfunction enable(o)\no = stead.ref(o)\nif isObject(o) then\no:enable()\nend\nreturn o\nend\nfunction disable_all(o)\no = stead.ref(o)\nif isObject(o) or isList(o) then\no:disable_all()\nend\nreturn o\nend\nfunction enable_all(o)\no = stead.ref(o)\nif isObject(o) or isList(o) then\no:enable_all()\nend\nreturn o\nend\nfunction isForSave(k, v, s) -- k - key, v - value, s -- parent table\nif stead.type(k) == 'function' then\nreturn false\nend\nif stead.type(v) == 'function' or stead.type(v) == 'userdata' then\nreturn false\nend\nreturn stead.string.find(k, '_') ==  1 or stead.string.match(k,'^%u')\nend\nstead.inherit = function(o, f)\nreturn function(...)\nreturn f(o(...))\nend\nend\ninherit = stead.inherit\nstead.hook = function(o, f)\nreturn function(...)\nlocal ff\nif stead.type(o) ~= 'function' then\nff = function(s)\nreturn o;\nend\nelse\nff = o\nend\nreturn f(ff, ...)\nend\nend\nhook = stead.hook\nfunction nameof(v)\nif isObject(v) then\nlocal r = stead.call(v, 'nam');\nreturn r\nend\nend\nstead.nameof = nameof\nstead.dispof = function(v)\nif isObject(v) then\nlocal r\nif game.gui then\nr = stead.call(v, 'disp')\nend\nif r == nil then\nr = stead.call(v, 'nam');\nend\nreturn r\nend\nend\nfunction stead_version(v)\nif not stead.tostr(v) then\nreturn\nend\nlocal n\nstead.version_table = {}\nstead.api_version_table = {}\nfor n in stead.string.gmatch(stead.version, \"[0-9]+\") do\nstead.table.insert(stead.version_table, stead.tonum(n))\nend\nfor n in stead.string.gmatch(v, \"[0-9]+\") do\nstead.table.insert(stead.api_version_table, stead.tonum(n))\nend\nif not stead.atleast(stead.unpack(stead.api_version_table)) then\nerror ([[The game requires instead engine of version ]] ..v.. [[ or higher.\nhttp://instead.sourceforge.net]], 2)\nend\nstead.api_version = v\nif stead.api_atleast(1, 2, 0) then\nrequire (\"walk\")\nrequire (\"vars\")\nrequire (\"object\")\nend\nif stead.api_atleast(1, 6, 3) then\nrequire (\"dlg\")\nend\nend\ninstead_version = stead_version\nfunction code(v)\nlocal f = stead.eval(v)\nif not f then\nerror (\"Wrong script: \"..stead.tostr(v), 2);\nend\nstead.functions[f] = { f = f, code = v };\nreturn f;\nend\nstead.code = code\n--- here the game begins\nstead.objects = function(s)\nnull = obj {\nnam = 'null';\n}\ninput = obj { -- input object\nsystem_type = true,\nnam = 'input',\n--[[key = function(s, down, key)\nreturn\nend, ]]\n--[[click = function(s, down, mb, x, y, [ px, py ] )\nreturn\nend ]]\n};\ntimer = obj { -- timer calls stead.timer callback \nnam = 'timer',\nini = function(s)\nif stead.tonum(s._timer) ~= nil and stead.type(stead.set_timer) == 'function' then\nstead.set_timer(s._timer);\nend\nend,\nget = function(s)\nif stead.tonum(s._timer) == nil then\nreturn 0\nend\nreturn stead.tonum(s._timer);\nend,\nstop = function(s)\nreturn s:set(0);\nend,\ndel = function(s)\nreturn s:set(0);\nend,\nset = function(s, v)\ns._timer = stead.tonum(v);\nif stead.type(stead.set_timer) ~= 'function' then\nreturn false\nend\nstead.set_timer(v)\nreturn true\nend,\n--[[ callback = function(s)\nend, ]]\n};\nallocator = obj {\nnam = 'allocator',\nget = function(s, n, c)\nif isObject(stead.ref(n)) and stead.api_atleast(1, 3, 0) then -- static?\nreturn stead.ref(n);\nend\nlocal v = stead.ref(c);\nif not v then\nerror (\"Null object in allocator: \"..stead.tostr(c));\nend\nv.key_name = n;\nv.save = stead.allocator_save;\nv.constructor = c;\nreturn v\nend,\ndelete = function(s, w)\nw = stead.ref(w);\nif stead.type(w.key_name) ~= 'string' then\nreturn\nend\nlocal f = stead.eval(w.key_name..'= nil;');\nif f then\nf();\nend\nend,\nnew = function(s, n, key)\nlocal v = stead.ref(n);\nif stead.type(v) ~= 'table' or stead.type(n) ~= 'string' then\nerror (\"Error in new.\", 2);\nend\nv.save = stead.allocator_save;\nv.constructor = n;\nif key then\ns.objects[key] = v\nv.key_name = stead.string.format('allocator[\"objects\"][%s]', stead.tostring(key));\nelse\nlocal nm = #s.objects + 1 -- here is new index\nstead.table.insert(s.objects, v);\nv.key_name = 'allocator[\"objects\"]['..stead.tostr(nm)..']';\nend\nif stead.api_atleast(1, 3, 0) then\nstead.check_object(v.key_name, v)\nend\nreturn v\nend,\nobjects = {\nsave = function(self, name, h, need)\nstead.savemembers(h, self, name, true);\nend,\n},\n};\npl = player {\nnam = \"Incognito\",\nwhere = 'main',\nobj = { }\n};\nmain = room {\nnam = 'main',\ndsc = 'No main room defined.',\n};\nend\nstead.sandbox = function()\nif STANDALONE then\nreturn\nend\n-- sandbox --\nlocal check_path = function(realpath, type, find, gsub, savepath, gamepath, path)\nif not path then\nreturn false\nend\npath = realpath(path)\nif not path then\nreturn false\nend\nlocal spath = realpath(savepath)\nif not spath then\nreturn false\nend\nlocal s = find(path, spath..'/', 1, true)\nif s ~= 1 then\nspath = realpath(gamepath);\nif spath then\ns = find(path, spath..'/', 1, true)\nend\nend\nif s ~= 1 then\nreturn false\nend\nreturn true\nend\nlocal build_sandbox_open = function(realpath, error, type, find, gsub, savepath, gamepath)\nreturn stead.hook(io.open, function(f, path, acc, ...)\nif type(acc) ~= 'string' or not find(acc, \"[aw+]\") then -- only write access\nreturn f(path, acc, ...)\nend\nif not check_path(realpath, type, find, gsub, savepath, gamepath, path) then\nerror (\"Access denied (write): \".. path, 3);\nreturn false\nend\nreturn f(path, acc, ...)\nend)\nend\nlocal build_sandbox_remove = function(realpath, error, type, find, gsub, savepath, gamepath)\nreturn stead.hook(os.remove, function(f, path, ...)\nif type(path) ~= 'string' then\nreturn f(path, ...)\nend\nif not check_path(realpath, type, find, gsub, savepath, gamepath, path) then\nerror (\"Access denied (remove): \".. path, 3);\nreturn false\nend\nreturn f(path, ...)\nend)\nend\nlocal build_sandbox_rename = function(realpath, error, type, find, gsub, savepath, gamepath)\nreturn stead.hook(os.rename, function(f, oldname, newname, ...)\nif not check_path(realpath, type, find, gsub, savepath, gamepath, oldname) or \nnot check_path(realpath, type, find, gsub, savepath, gamepath, newname) then\nerror (\"Access denied (rename): \".. oldname .. ', '.. newname, 3);\nreturn false\nend\nreturn f(oldname, newname, ...)\nend)\nend\nlocal build_sandbox_output = function(realpath, error, type, find, gsub, savepath, gamepath)\nreturn stead.hook(io.output, function(f, path, ...)\nif not check_path(realpath, type, find, gsub, savepath, gamepath, path) then\nerror (\"Access denied (output): \".. path, 3);\nreturn false\nend\nreturn f(path, ...)\nend)\nend\nio.open = build_sandbox_open(instead_realpath, error, type, string.find, string.gsub, \ninstead_savepath(), instead_gamepath());\nos.remove = build_sandbox_remove(instead_realpath, error, type, string.find, string.gsub, \ninstead_savepath(), instead_gamepath());\nos.rename = build_sandbox_rename(instead_realpath, error, type, string.find, string.gsub, \ninstead_savepath(), instead_gamepath());\nio.output = build_sandbox_output(instead_realpath, error, type, string.find, string.gsub, \ninstead_savepath(), instead_gamepath());\nos.execute = function(s)\nprint (\"Warning: trying to do os.execute: \"..s);\nend\nio.popen = function(s)\nprint (\"Warning: trying to do io.popen: \"..s);\nend\nos.tmpname = function(s)\nprint (\"Warning: trying to do os.tmpname\");\nend\nif not DEBUG then\ndebug = nil\nend\npackage.cpath = \"\"\npackage.preload = {}\npackage = nil\nend\n-- end of sandbox --\nstead.init = function(s)\nstead.initialized = false\nstead.started = false\nstead:objects();\ns.functions = {} -- code blocks\nlocal k,v\nfor k,v in stead.ipairs(s.modules_ini) do\nv();\nend\nif stead.type(stead.sandbox) == 'function' then\nstead.sandbox()\nstead.sandbox = nil\nend\nend\n-- those are sill in global space\nadd_sound = stead.add_sound\nset_sound = stead.set_sound\nstop_sound = stead.stop_sound\nget_sound = stead.get_sound\nget_sound_loop = stead.get_sound_loop\nget_sound_chan = stead.get_sound_chan\nget_music = stead.get_music\nget_music_fading = stead.get_music_fading\nget_music_loop = stead.get_music_loop\nset_music = stead.set_music\nset_music_fading = stead.set_music_fading\nstop_music = stead.stop_music\nsave_music = stead.save_music\nrestore_music = stead.restore_music\nis_music = stead.is_music\nref = stead.ref\nderef = stead.deref\nmouse_pos = stead.mouse_pos\nmouse_filter = stead.mouse_filter\nget_ticks = stead.ticks\npclr = stead.pclr\npget =  stead.pget\np = stead.p\npr = stead.pr\npn = stead.pn\npar = stead.par\ncat = stead.cat\nplayer_moved = stead.player_moved\nrnd = stead.rnd;\ngamefile = stead.gamefile\ntime = stead.time\ninstead_version(stead.api_version)\n-- vim:ts=4\n","theme.lua":"theme = {\nnam = 'theme';\nobject_type = true;\nsystem_type = true;\nsave = function(self, name, h, need)\nlocal k,v\nif self.name() ~= '.' then\nreturn\nend\nfor k,v in stead.pairs(self.vars) do\nh:write(stead.string.format(\"theme.set(%q, %q);\\n\", k, v))\nend\nend;\nreset = function(...)\nlocal i\nlocal a = {...};\nfor i = 1, stead.table.maxn(a) do\nlocal name = a[i]\nlocal v\nif name then\nv = theme.reset_vars[name]\nif v then\ninstead_theme_var(name, v);\ntheme.vars[name] = nil\ntheme.reset_vars[name] = nil\nend\nend\nend\nend;\nset = function(name, val)\nif val and name then\nif not theme.reset_vars[name] then\ntheme.reset_vars[name] = instead_theme_var(name)\nend\ninstead_theme_var(name, stead.tostr(val));\ntheme.vars[name] = stead.tostr(val);\nend\nend;\nname = function()\nreturn instead_theme_name(name);\nend;\nget = function(name)\nreturn instead_theme_var(name);\nend;\nwin = {\nreset = function()\ntheme.reset(\"win.x\", \"win.y\", \"win.w\", \"win.h\",\n\"win.col.fg\", \"win.col.link\", \"win.col.alink\",\n\"win.fnt.name\", \"win.fnt.size\", \"win.fnt.height\");\nend;\ngeom = function(x, y, w, h)\ntheme.set(\"win.x\", x);\ntheme.set(\"win.y\", y);\ntheme.set(\"win.w\", w);\ntheme.set(\"win.h\", h);\nend;\ncolor = function(fg, link, alink)\ntheme.set(\"win.col.fg\", fg);\ntheme.set(\"win.col.link\", link);\ntheme.set(\"win.col.alink\", alink);\nend;\nfont = function(name, size, height)\ntheme.set(\"win.fnt.name\", name);\ntheme.set(\"win.fnt.size\", size);\ntheme.set(\"win.fnt.height\", height);\nend;\ngfx = {\nreset = function()\ntheme.reset(\"win.gfx.up\", \"win.up.x\", \"win.up.y\");\ntheme.reset(\"win.gfx.down\", \"win.down.x\", \"win.down.y\");\nend;\nup = function(pic, x, y)\ntheme.set(\"win.gfx.up\", pic);\ntheme.set(\"win.up.x\", x);\ntheme.set(\"win.up.y\", y);\nend;\ndown = function(pic, x, y)\ntheme.set(\"win.gfx.down\", pic);\ntheme.set(\"win.down.x\", x);\ntheme.set(\"win.down.y\", y);\nend;\n};\n};\ninv = {\nreset = function()\ntheme.reset(\"inv.x\", \"inv.y\", \"inv.w\", \"inv.h\",\n\"inv.col.fg\", \"inv.col.link\", \"inv.col.alink\",\n\"inv.fnt.name\", \"inv.fnt.size\", \"inv.fnt.height\",\n\"inv.mode\");\nend;\ngeom = function(x, y, w, h)\ntheme.set(\"inv.x\", x);\ntheme.set(\"inv.y\", y);\ntheme.set(\"inv.w\", w);\ntheme.set(\"inv.h\", h);\nend;\ncolor = function(fg, link, alink)\ntheme.set(\"inv.col.fg\", fg);\ntheme.set(\"inv.col.link\", link);\ntheme.set(\"inv.col.alink\", alink);\nend;\nfont = function(name, size, height)\ntheme.set(\"inv.fnt.name\", name);\ntheme.set(\"inv.fnt.size\", size);\ntheme.set(\"inv.fnt.height\", height);\nend;\nmode = function(mode)\ntheme.set(\"inv.mode\", mode);\nend;\ngfx = {\nreset = function()\ntheme.reset(\"inv.gfx.up\", \"inv.up.x\", \"inv.up.y\");\ntheme.reset(\"inv.gfx.down\", \"inv.down.x\", \"inv.down.y\");\nend;\nup = function(pic, x, y)\ntheme.set(\"inv.gfx.up\", pic);\ntheme.set(\"inv.up.x\", x);\ntheme.set(\"inv.up.y\", y);\nend;\ndown = function(pic, x, y)\ntheme.set(\"inv.gfx.down\", pic);\ntheme.set(\"inv.down.x\", x);\ntheme.set(\"inv.down.y\", y);\nend;\n};\n};\nmenu = {\nreset = function()\ntheme.reset(\"menu.bw\",\n\"menu.col.fg\", \"menu.col.bg\", \"menu.col.alpha\",\n\"menu.col.link\", \"menu.col.alink\",\n\"menu.fnt.name\", \"menu.fnt.size\", \"menu.fnt.height\");\nend;\nbw = function(w)\ntheme.set(\"menu.bw\", w);\nend;\ncolor = function(fg, bg, alpha, link, alink)\ntheme.set(\"menu.col.fg\", fg);\ntheme.set(\"menu.col.bg\", bg);\ntheme.set(\"menu.col.alpha\", alpha);\ntheme.set(\"menu.col.link\", link);\ntheme.set(\"menu.col.alink\", alink);\nend;\nfont = function(name, size, height)\ntheme.set(\"menu.fnt.name\", name);\ntheme.set(\"menu.fnt.size\", size);\ntheme.set(\"menu.fnt.height\", height);\nend;\ngfx = {\nreset = function()\ntheme.reset(\"menu.gfx.button\", \"menu.button.x\", \"menu.button.y\");\nend;\nbutton = function(b, x, y)\ntheme.set(\"menu.gfx.button\", b);\ntheme.set(\"menu.button.x\", x);\ntheme.set(\"menu.button.y\", y);\nend;\n};\n};\ngfx = {\nreset = function()\ntheme.reset(\"scr.gfx.cursor.normal\", \"scr.gfx.cursor.use\",\n\"scr.gfx.cursor.x\", \"scr.gfx.cursor.y\",\n\"scr.gfx.mode\", \"scr.gfx.pad\",\n\"scr.gfx.bg\");\nend;\ncursor = function(norm, use, x, y)\ntheme.set(\"scr.gfx.cursor.normal\", norm);\ntheme.set(\"scr.gfx.cursor.use\", use);\ntheme.set(\"scr.gfx.cursor.x\", x);\ntheme.set(\"scr.gfx.cursor.y\", y);\nend;\nmode = function(mode)\ntheme.set(\"scr.gfx.mode\", mode);\nend;\npad = function(pad)\ntheme.set(\"scr.gfx.pad\", pad);\nend;\nbg = function(bg)\ntheme.set(\"scr.gfx.bg\", bg);\nend;\n};\nsnd = {\nreset = function()\ntheme.reset(\"snd.click\");\nend;\nclick = function(w)\ntheme.set(\"snd.click\", w);\nend\n}\n}\ntheme.vars = {}\ntheme.reset_vars = {}\n","timer.lua":"game.action = stead.hook(game.action, function(f, s, cmd, ...)\nif cmd == 'user_timer' then\nlocal r,v\nif stead.here().timer then\nr,v = stead.call(stead.here(), 'timer');\nelseif s.timer then\nr,v = stead.call(s, 'timer');\nend\nif r == nil and v == nil and not stead.api_atleast(1, 3, 5) then\nreturn nil, true\nend\nreturn r,v\nend\nreturn f(s, cmd, ...);\nend)\nstead.module_init(function()\ntimer.callback = function(s)\nreturn 'user_timer'\nend\nend)\n-- vim:ts=4\n","vars.lua":"function isForSave(k, v, s) -- k - key, v - value, s -- parent table\nlocal i,o\nif stead.type(s.variables_save) == 'table' and \ns.variables_save[k] then\nreturn true\nend\nif stead.type(k) == 'function' then\nreturn false\nend\nif stead.type(v) == 'function' or stead.type(v) == 'userdata' then\nreturn false\nend\nif stead.type(k) ~= 'string' then\nreturn false\nend\nreturn stead.string.find(k, '_') ==  1\nend\nlocal function __vars_add(s, v, set)\nlocal k, o\nif stead.type(s.variables) ~= 'table' then s.variables = {} end\nfor k,o in stead.pairs(v) do\nif stead.tonum(k) then\nstead.table.insert(s.variables, o);\nelseif s.variables[k] then\nerror (\"Variable overwrites variables object: \"..stead.tostr(k))\nelseif k ~= 'variable_type' then\nif set and not isObject(o) then \nif s[k] then\nif s == _G then\nprint (\"Global variable '\"..stead.tostr(k)..\"' conflicts with \"..stead.type(s[k]));\nelse\nerror (\"Variable conflict: \"..stead.tostr(k));\nend\nend\nstead.table.insert(s.variables, k);\ns[k] = o\nelse\ns.variables[k] = o\nend\nend\nend\nend\nlocal function __vars_fill(v)\nlocal k,o\nif stead.type(v) ~= 'table' then\nreturn\nend\nfor k,o in stead.ipairs(v) do\nif stead.type(o) == 'table' and o.variable_type then\n__vars_add(v, o);\nv[k] = false\nend\nend\nif stead.type(v.variables) == 'table' then\nlocal k,o\nlocal vars = {}\nv.variables_save = {}\nfor k,o in stead.pairs(v.variables) do\nif stead.tonum(k) and stead.type(o) == 'string' then\nstead.table.insert(vars, o)\nelse\nif v[k] then\nerror (\"Variable overwrites object property: \"..stead.tostr(k));\nend\nv[k] = o\nstead.table.insert(vars, k);\nend\nend\nfor k,o in stead.ipairs(vars) do\nv.variables_save[o] = true\nend\nv.variables = vars;\nend\nend\nvars_object = obj {\nnam = 'vars',\nsystem_type = true,\nini = function(s)\n__vars_fill(_G)\n__vars_fill(pl)\n__vars_fill(game)\nend\n}\nobj = stead.hook(obj, \nfunction(f, v, ...)\n__vars_fill(v)\nreturn f(v, ...)\nend)\nstead.add_var = function(s, v) \nif not v then \nv = s \ns = _G \nend\nif stead.type(v) ~= 'table' then\nerror(\"Wrong parameter to stead.add_var.\");\nend\nif not v.variable_type then\nv = var(v)\nend\n__vars_add(s, v, true)\n__vars_fill(s)\nend\nstead.module_init(function()\nlocal k,v\nif stead.type(variables) == 'nil' then\nvariables = {}\nreturn\nend \nif stead.type(variables) ~= 'table' then\nreturn\nend\nfor k,v in stead.ipairs(variables) do\n_G[v] = nil\nend\nvariables = {}\nend)\nfunction var(v)\nv.variable_type = true\nreturn v\nend\nfunction global(v)\nif stead.type(v) ~= 'table' then\nerror(\"Wrong parameter to global.\", 2);\nend\n__vars_add(_G, v, true);\nend\n-- vim:ts=4\n","walk.lua":"local function onevent(ev, ...)\nlocal vv, r\nif stead.api_atleast(1, 6, 3) then\nvv, r = stead.call(game, ev, ...);\nif r == false then\nreturn vv, false\nend\nif vv == false then\nreturn nil, false\nend\nreturn vv\nend\nend\nlocal go = function (self, where, back, noenter, noexit, nodsc)\nlocal was = self.where;\nlocal need_scene = false;\nlocal ret\nif not stead.in_walk_call then\nret = function(rc) stead.in_walk_call = false return nil end\nelse\nret = function(rc) return rc end\nend\nstead.in_walk_call = true\nif where == nil then\nreturn nil, ret(false)\nend\nif not isRoom(stead.ref(where)) then\nerror (\"Trying to go nowhere: \"..where);\nend\nif not isRoom(stead.ref(self.where)) then\nerror (\"Trying to go from nowhere: \"..self.where);\nend\nif stead.in_entered_call or stead.in_onexit_call then\nerror (\"Do not use walk from left/entered action! Use exit/enter action instead:\" .. self.where);\nend\nlocal v, r, jump;\nif not isVroom(stead.ref(where)) and not stead.in_exit_call and not noexit then\nstead.in_exit_call = true -- to break recurse\nv,r = stead.call(stead.ref(self.where), 'exit', stead.ref(where));\nstead.in_exit_call = nil\nif r == false or (stead.api_atleast(1, 3, 0) and v == false and r == nil) then\nreturn v, ret(r)\nend\nif stead.api_atleast(2, 4, 0) then\njump = PLAYER_MOVED\nelse\njump = (self.where ~= was)\nend\nif jump then\nwhere = stead.deref(self.where) -- jump\nend\nend\nlocal res = v;\nv = nil;\nif not isVroom(stead.ref(where)) then\nself.where = stead.deref(where);\nend\nif not jump and not noenter then\nv, r = stead.call(stead.ref(where), 'enter', stead.ref(was));\nif r == false or (stead.api_atleast(1, 3, 0) and v == false and r == nil) then\nself.where = was;\nreturn stead.par(stead.scene_delim, res, v), ret(r)\nend\nend\nif stead.api_atleast(2, 4, 0) then\nneed_scene = not PLAYER_MOVED;\nelse\nneed_scene = not (stead.ref(where) ~= stead.ref(self.where))\nend\nres = stead.par(stead.scene_delim, res, v);\nif not back then\nstead.ref(where).__from__ = stead.deref(was);\nend\nret()\nPLAYER_MOVED = true\nif need_scene and not nodsc then\nNEED_SCENE = true\nend\nif not stead.in_walk_call  then\nlocal to = self.where\nif not noexit then\nself.where = was\nstead.in_onexit_call = true\nv = stead.call(stead.ref(was), 'left', stead.ref(to));\nstead.in_onexit_call = false\nres = stead.par(stead.scene_delim, res, v);\nend\nself.where = stead.deref(to)\nif not noenter then\nstead.in_entered_call = true\nv = stead.call(stead.ref(to), 'entered', stead.ref(was));\nstead.in_entered_call = false\nres = stead.par(stead.scene_delim, res, v);\nend\nif stead.tonum(stead.ref(to).__visited) then\nstead.ref(to).__visited = stead.ref(to).__visited + 1;\nelseif stead.here().__visited == nil then\nstead.ref(to).__visited = 1\nend\nif not stead.api_atleast(1, 6, 3) and isDialog(stead.ref(to)) then\nstead.dialog_rescan(stead.ref(to))\nend\nend\nreturn res;\nend\nstead.player_go = function(self, where) -- cmd iface\nlocal w = stead.ref(self.where).way:srch(where);\nif not w then\nreturn nil,false\nend\nreturn self:walk(w);\nend\nstead.player_walk = function(self, where, ...) -- real work\nlocal v, r, vv;\nvv, r = onevent('onwalk', stead.ref(where), ...);\nif vv == false then\nreturn\nend\nif r == false then \nreturn vv \nend\nv, r = stead.go(self, where, ...);\nif stead.type(vv) == 'string' then\nv = stead.par(stead.space_delim, vv, v);\nend\nreturn v, r;\nend\nstead.player_back = function(self) -- deprecated\nerror (\"Do not use stead.me():back(). It's deprecated.\", 2)\nend\nstead.back = function(w)\nif isDialog(stead.here()) and not isDialog(stead.from()) then\nreturn stead.walkout(w);\nend\nreturn stead.walkback(w);\nend\nback = stead.back\nstead.walkback = function(w)\nif isRoom(stead.ref(w)) then\nreturn stead.me():walk(w, true);\nend\nreturn stead.me():walk(stead.from(), true);\nend\nwalkback = stead.walkback\nstead.walk = function(what, back, noenter, noexit, nodsc, ...)\nreturn stead.me():walk(what, back, noenter, noexit, nodsc, ...);\nend\nwalk = stead.walk\nstead.walkin = function(what)\nreturn stead.me():walk(what, false, false, true);\nend\nwalkin = stead.walkin\nstead.walkout = function(what)\nif isRoom(stead.ref(what)) then\nreturn stead.me():walk(what, true, true, false, true);\nend\nreturn stead.me():walk(stead.from(), true, true, false, true);\nend\nwalkout = stead.walkout\nfunction visited(w)\nif not w then w = stead.here() end\nw = stead.ref(w)\nif w == nil then\nreturn nil;\nend\nif not isRoom(w) then\nerror (\"Wrong parameter to visited.\", 2);\nend\nreturn w.__visited\nend\nstead.visited = visited\nfunction visits(w)\nlocal n = stead.visited(w)\nif not n then n = 0 end\nreturn n\nend\nstead.visits = visits\niface.fmt = function(self, cmd, st, moved, r, av, objs, pv) -- st -- changed state (main win), move -- loc changed\nlocal l, vv\nif st then\nav = txtem(av);\npv = txtem(pv);\n--if not PLAYER_MOVED then\nr = txtem(r)\n--end\nif isForcedsc(stead.here()) or NEED_SCENE then\nl = stead.here():scene();\nend\nend\nif moved then\nvv = stead.fmt(stead.cat(stead.par(stead.scene_delim, r, l, av, objs, pv), '^'));\nelse\nvv = stead.fmt(stead.cat(stead.par(stead.scene_delim, l, r, av, objs, pv), '^'));\nend\nreturn vv\nend\nstead.go = function(...)\nlocal r,v = go(...)\nif stead.type(r) == 'string' and stead.cctx() then \nstead.pr (r)\nend\n--if stead.in_life_call then\n--ACTION_TEXT = nil\n--end\nif r == nil and v == nil then\nif stead.cctx() then\nstead.cctx().action = true\nelse\nr = true\nend\nend\nreturn r,v\nend\niface.cmd = stead.hook(iface.cmd, function(f, ...)\nNEED_SCENE = nil\nreturn f(...)\nend)\nplayer  = stead.inherit(player, function(v)\nv.look = function(s)\nif not stead.started then\ngame:start()\nstead.started = true\nend\nif game._time == 0 then\nreturn stead.walk(stead.here(), false, false, true);\nend\nNEED_SCENE = true\nif stead.api_atleast(1, 3, 5) then\nreturn true -- force action\nend\nend\nreturn v\nend)\npl = player(pl) -- reinit\n-- vim:ts=4\n","wroom.lua":"stead.wroom_enter = function(self, ...)\nlocal w = self.where\nif stead.type(w) ~= 'table' then\nw = stead.call(self, 'where')\nend\nlocal r, v = stead.walk(w);\nif v ~= false then\nself._toggle = true\nend\nreturn r, v\nend\nstead.wroom_save = function(self, name, h, need)\nif need then\nlocal a = stead.tostring(self.oldname);\nlocal b = stead.tostring(self.newname);\nlocal c = stead.tostring(self.where);\nif a == nil or b == nil or c == nil then\nerror (\"Can not save wroom \"..name..\"\\nFunctions can not be saved, use code [[ ]]\");\nend\nlocal t = stead.string.format(\"%s = wroom(%s, %s, %s);\\n\",\nname, a, b, c);\nh:write(t);\nend\nstead.savemembers(h, self, name, false);\nend\nfunction wroom(a, b, c)\nlocal v = room { vroom_type = true, nam = a, where = c, enter = stead.wroom_enter, save = stead.wroom_save };\nv.newname = b;\nv.oldname = a;\nv._toggle = false\nif c == nil then -- only two parameters\nv.newname = nil\nv.where = b\nend\nv.nam = function(s)\nif s._toggle and s.newname then\nreturn stead.call(s, 'newname')\nelse\nreturn stead.call(s, 'oldname');\nend\nend\nreturn v\nend\n","xact.lua":"xact = function(n, f) -- just simple action!\nlocal v = {};\nif f == nil and stead.type(n) == 'table' then\nf = n[2];\nn = n[1];\nend\nif stead.type(n) ~= 'string' then\nerror (\"Wrong parameter to xact.\", 2)\nend\nv.xaction_type = true\nv.nam = n\nif stead.api_atleast(1, 6, 3) then\nv.disp = false\nend\nv.act = f;\nv = obj(v);\nv.save = function(self, name, h, need)\nif need then\nlocal f = self.act;\nf = stead.tostring(f);\nif f == nil then\nerror(\"Can not save xact: \"..name);\nend\nh:write(stead.string.format(\"%s = xact(%q, %s);\\n\", name, self.nam, f))\nend\nstead.savemembers(h, self, name, false);\nend\nreturn v\nend\nlocal __do_xact = function(str, self)\nlocal aarg = {}\nlocal function parg(v)\nstead.table.insert(aarg, v);\nreturn ''\nend\nlocal xrefrep = function(str)\nlocal s = stead.string.gsub(str,'[\\001\\002]','');\nlocal o,d,a, oo;\nlocal delim = ':'\nif stead.api_atleast(1, 2, 2) then\ndelim = stead.delim;\nend\ns = s:gsub('\\\\?[\\\\'..delim..']', { [ delim ] = '\\001', [ '\\\\'..delim ] = delim });\nlocal i = s:find('\\001', 1, true);\naarg = {}\nif i then\no = s:sub(1, i - 1);\nd = s:sub(i + 1);\ni = o:find(\"(\", 1, true);\nif i then\na = o:sub(i);\no = o:sub(1, i - 1);\na:gsub('[^,()]+', parg);\nend\nif o == '' then \nif isObject(self) then\noo = self\nelse\nerror(\"Empty link: \"..s, 3);\nend\nelse\nif stead.api_atleast(1, 6, 3) then\noo = stead.here():srch(o)\nelse\noo = objs():srch(o)\nend\nif not oo then\noo = stead.ref(o, true)\nend\nend\nelseif isObject(self) then\noo = self\nd = s;\nelse\nerror(\"Wrong link: \"..s, 3);\nend\nd = d:gsub(\"\\001\", delim);\nreturn stead.xref(d, stead.ref(oo, true), stead.unpack(aarg));\nend\nif stead.type(str) ~= 'string' then return end\nlocal s = stead.string.gsub(str, '\\\\?[\\\\{}]', \n{ ['{'] = '\\001', ['}'] = '\\002' }):gsub('\\001([^\\002]+)\\002', xrefrep):gsub('[\\001\\002]', { ['\\001'] = '{', ['\\002'] = '}' });\nreturn s;\nend\nstead.fmt = stead.hook(stead.fmt, function(f, ...)\nlocal i, res, s\nlocal a = {...}\nfor i=1,stead.table.maxn(a) do\nif stead.type(a[i]) == 'string' then\ns = __do_xact(a[i]);\nres = stead.par('', res, s):gsub('\\\\?[\\\\{}]', { [ '\\\\{' ] = '{', [ '\\\\}' ] = '}' });\nend\nend\nreturn f(res);\nend)\nobj = stead.inherit(obj, function(v)\nv.xref = function(s, str)\nreturn __do_xact(str, s);\nend\nreturn v\nend)\nfunction xdsc(n)\nlocal v = {}\nv.nam = true\nif n == nil then\nv.disp = 'xdsc'\nelseif stead.type(n) == 'string' then\nv.disp = n;\nelse\nerror(\"Wrong parameter to xdsc.\", 2);\nend\nv.dsc = function(s)\nreturn stead.call(stead.here(), s.disp);\nend\nv.save = function(self, name, h, need)\nif need then\nh:write(stead.string.format(\"%s = xdsc(%q);\\n\", name, self.disp))\nend\nstead.savemembers(h, self, name, false);\nend\nreturn obj(v)\nend\nxroom = stead.inherit(room, function(v)\nv.look = stead.hook(v.look, function(f, s,...)\nlocal xdsc = stead.call(s, 'xdsc');\nreturn stead.par(stead.space_delim, xdsc, f(s, ...));\nend)\nreturn v\nend)\nif stead.api_atleast(1, 6, 3) then\nxwalk = xact('xwalk', code [[ stead.walk(arg1) ]]);\nxwalk.system_type = true\nend\n-- vim:ts=4\n"}
